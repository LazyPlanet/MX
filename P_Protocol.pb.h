// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P_Protocol.proto

#ifndef PROTOBUF_P_5fProtocol_2eproto__INCLUDED
#define PROTOBUF_P_5fProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "P_Asset.pb.h"
// @@protoc_insertion_point(includes)

namespace Adoter {
namespace Asset {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_P_5fProtocol_2eproto();
void protobuf_AssignDesc_P_5fProtocol_2eproto();
void protobuf_ShutdownFile_P_5fProtocol_2eproto();

class Account;
class PaiElement;
class User;
class PlayerProp;
class CommonProp;
class PlayerCommonLimit;
class PlayerCommonLimit_Element;
class PlayerCoolDown;
class PlayerCoolDown_Element;
class MailAttachment;
class Mail;
class Player;
class Inventory;
class Inventory_Element;
class ItemEquipment;
class Meta;
class CreatePlayer;
class Login;
class Logout;
class EnterGame;
class Room;
class RoomOptions;
class CreateRoom;
class EnterRoom;
class Sign;
class PlayerLuckyPlate;
class GetReward;
class PaiOperationLimit;
class PaiOperationList;
class PaiOperation;
class GameOperation;
class BuySomething;
class LoadScene;
class PlayerList;
class PlayerInformation;
class AlertMessage;
class CommonOperationResponse;
class PaiNotify;
class PaiNotify_MutiPai;
class PaiNotify_SinglePai;
class CommonProperty;
class PaiOperationAlert;
class SyncCommonLimit;
class SyncCommonReward;
class RoomInformation;
class RoomInformation_Player;

enum EnterRoom_ENTER_TYPE {
  EnterRoom_ENTER_TYPE_ENTER_TYPE_ENTER = 1,
  EnterRoom_ENTER_TYPE_ENTER_TYPE_CANCEL = 2
};
bool EnterRoom_ENTER_TYPE_IsValid(int value);
const EnterRoom_ENTER_TYPE EnterRoom_ENTER_TYPE_ENTER_TYPE_MIN = EnterRoom_ENTER_TYPE_ENTER_TYPE_ENTER;
const EnterRoom_ENTER_TYPE EnterRoom_ENTER_TYPE_ENTER_TYPE_MAX = EnterRoom_ENTER_TYPE_ENTER_TYPE_CANCEL;
const int EnterRoom_ENTER_TYPE_ENTER_TYPE_ARRAYSIZE = EnterRoom_ENTER_TYPE_ENTER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnterRoom_ENTER_TYPE_descriptor();
inline const ::std::string& EnterRoom_ENTER_TYPE_Name(EnterRoom_ENTER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnterRoom_ENTER_TYPE_descriptor(), value);
}
inline bool EnterRoom_ENTER_TYPE_Parse(
    const ::std::string& name, EnterRoom_ENTER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnterRoom_ENTER_TYPE>(
    EnterRoom_ENTER_TYPE_descriptor(), name, value);
}
enum GetReward_GET_REWARD_REASON {
  GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_BONUS = 1,
  GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_ALLOWANCE = 2
};
bool GetReward_GET_REWARD_REASON_IsValid(int value);
const GetReward_GET_REWARD_REASON GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MIN = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_BONUS;
const GetReward_GET_REWARD_REASON GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MAX = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_ALLOWANCE;
const int GetReward_GET_REWARD_REASON_GET_REWARD_REASON_ARRAYSIZE = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MAX + 1;

const ::google::protobuf::EnumDescriptor* GetReward_GET_REWARD_REASON_descriptor();
inline const ::std::string& GetReward_GET_REWARD_REASON_Name(GetReward_GET_REWARD_REASON value) {
  return ::google::protobuf::internal::NameOfEnum(
    GetReward_GET_REWARD_REASON_descriptor(), value);
}
inline bool GetReward_GET_REWARD_REASON_Parse(
    const ::std::string& name, GetReward_GET_REWARD_REASON* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetReward_GET_REWARD_REASON>(
    GetReward_GET_REWARD_REASON_descriptor(), name, value);
}
enum PaiOperation_PAI_OPER_TYPE {
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_DAPAI = 1,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_HUPAI = 2,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_GANGPAI = 3,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_PENGPAI = 4,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_CHIPAI = 5,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_GIVEUP = 6,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_XUANFENG_FENG = 7,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_XUANFENG_JIAN = 8,
  PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_ANGANGPAI = 9
};
bool PaiOperation_PAI_OPER_TYPE_IsValid(int value);
const PaiOperation_PAI_OPER_TYPE PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_MIN = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_DAPAI;
const PaiOperation_PAI_OPER_TYPE PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_MAX = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_ANGANGPAI;
const int PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_ARRAYSIZE = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PaiOperation_PAI_OPER_TYPE_descriptor();
inline const ::std::string& PaiOperation_PAI_OPER_TYPE_Name(PaiOperation_PAI_OPER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PaiOperation_PAI_OPER_TYPE_descriptor(), value);
}
inline bool PaiOperation_PAI_OPER_TYPE_Parse(
    const ::std::string& name, PaiOperation_PAI_OPER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PaiOperation_PAI_OPER_TYPE>(
    PaiOperation_PAI_OPER_TYPE_descriptor(), name, value);
}
enum PaiNotify_CARDS_DATA_TYPE {
  PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_START = 1,
  PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_FAPAI = 2,
  PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_SYNC = 3
};
bool PaiNotify_CARDS_DATA_TYPE_IsValid(int value);
const PaiNotify_CARDS_DATA_TYPE PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MIN = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_START;
const PaiNotify_CARDS_DATA_TYPE PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MAX = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_SYNC;
const int PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_ARRAYSIZE = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PaiNotify_CARDS_DATA_TYPE_descriptor();
inline const ::std::string& PaiNotify_CARDS_DATA_TYPE_Name(PaiNotify_CARDS_DATA_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PaiNotify_CARDS_DATA_TYPE_descriptor(), value);
}
inline bool PaiNotify_CARDS_DATA_TYPE_Parse(
    const ::std::string& name, PaiNotify_CARDS_DATA_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PaiNotify_CARDS_DATA_TYPE>(
    PaiNotify_CARDS_DATA_TYPE_descriptor(), name, value);
}
enum CommonProperty_SYNC_REASON_TYPE {
  CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_SELF = 1,
  CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ENTER_ROOM = 2
};
bool CommonProperty_SYNC_REASON_TYPE_IsValid(int value);
const CommonProperty_SYNC_REASON_TYPE CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MIN = CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_SELF;
const CommonProperty_SYNC_REASON_TYPE CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MAX = CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ENTER_ROOM;
const int CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ARRAYSIZE = CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonProperty_SYNC_REASON_TYPE_descriptor();
inline const ::std::string& CommonProperty_SYNC_REASON_TYPE_Name(CommonProperty_SYNC_REASON_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonProperty_SYNC_REASON_TYPE_descriptor(), value);
}
inline bool CommonProperty_SYNC_REASON_TYPE_Parse(
    const ::std::string& name, CommonProperty_SYNC_REASON_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonProperty_SYNC_REASON_TYPE>(
    CommonProperty_SYNC_REASON_TYPE_descriptor(), name, value);
}
enum ERR_USE_ITEM_TYPE {
  ERR_USE_ITEM_TYPE_SUCCESS = 0,
  ERR_USE_ITEM_TYPE_LEVEL_BELOW = 1,
  ERR_USE_ITEM_TYPE_LEVEL_UP = 2
};
bool ERR_USE_ITEM_TYPE_IsValid(int value);
const ERR_USE_ITEM_TYPE ERR_USE_ITEM_TYPE_MIN = ERR_USE_ITEM_TYPE_SUCCESS;
const ERR_USE_ITEM_TYPE ERR_USE_ITEM_TYPE_MAX = ERR_USE_ITEM_TYPE_LEVEL_UP;
const int ERR_USE_ITEM_TYPE_ARRAYSIZE = ERR_USE_ITEM_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERR_USE_ITEM_TYPE_descriptor();
inline const ::std::string& ERR_USE_ITEM_TYPE_Name(ERR_USE_ITEM_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERR_USE_ITEM_TYPE_descriptor(), value);
}
inline bool ERR_USE_ITEM_TYPE_Parse(
    const ::std::string& name, ERR_USE_ITEM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERR_USE_ITEM_TYPE>(
    ERR_USE_ITEM_TYPE_descriptor(), name, value);
}
enum POSITION_TYPE {
  POSITION_TYPE_NULL = 0,
  POSITION_TYPE_EAST = 1,
  POSITION_TYPE_SOUTH = 2,
  POSITION_TYPE_WEST = 3,
  POSITION_TYPE_NORTH = 4
};
bool POSITION_TYPE_IsValid(int value);
const POSITION_TYPE POSITION_TYPE_MIN = POSITION_TYPE_NULL;
const POSITION_TYPE POSITION_TYPE_MAX = POSITION_TYPE_NORTH;
const int POSITION_TYPE_ARRAYSIZE = POSITION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* POSITION_TYPE_descriptor();
inline const ::std::string& POSITION_TYPE_Name(POSITION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    POSITION_TYPE_descriptor(), value);
}
inline bool POSITION_TYPE_Parse(
    const ::std::string& name, POSITION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<POSITION_TYPE>(
    POSITION_TYPE_descriptor(), name, value);
}
enum LOAD_SCENE_TYPE {
  LOAD_SCENE_TYPE_NULL = 1,
  LOAD_SCENE_TYPE_START = 2,
  LOAD_SCENE_TYPE_SUCCESS = 3,
  LOAD_SCENE_TYPE_FAILED = 4
};
bool LOAD_SCENE_TYPE_IsValid(int value);
const LOAD_SCENE_TYPE LOAD_SCENE_TYPE_MIN = LOAD_SCENE_TYPE_NULL;
const LOAD_SCENE_TYPE LOAD_SCENE_TYPE_MAX = LOAD_SCENE_TYPE_FAILED;
const int LOAD_SCENE_TYPE_ARRAYSIZE = LOAD_SCENE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* LOAD_SCENE_TYPE_descriptor();
inline const ::std::string& LOAD_SCENE_TYPE_Name(LOAD_SCENE_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    LOAD_SCENE_TYPE_descriptor(), value);
}
inline bool LOAD_SCENE_TYPE_Parse(
    const ::std::string& name, LOAD_SCENE_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LOAD_SCENE_TYPE>(
    LOAD_SCENE_TYPE_descriptor(), name, value);
}
enum ERROR_TYPE {
  ERROR_TYPE_NORMAL = 1,
  ERROR_TYPE_INVENTORY_FULL = 2
};
bool ERROR_TYPE_IsValid(int value);
const ERROR_TYPE ERROR_TYPE_MIN = ERROR_TYPE_NORMAL;
const ERROR_TYPE ERROR_TYPE_MAX = ERROR_TYPE_INVENTORY_FULL;
const int ERROR_TYPE_ARRAYSIZE = ERROR_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_TYPE_descriptor();
inline const ::std::string& ERROR_TYPE_Name(ERROR_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_TYPE_descriptor(), value);
}
inline bool ERROR_TYPE_Parse(
    const ::std::string& name, ERROR_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_TYPE>(
    ERROR_TYPE_descriptor(), name, value);
}
enum ERROR_SHOW_TYPE {
  ERROR_SHOW_TYPE_CHAT = 1
};
bool ERROR_SHOW_TYPE_IsValid(int value);
const ERROR_SHOW_TYPE ERROR_SHOW_TYPE_MIN = ERROR_SHOW_TYPE_CHAT;
const ERROR_SHOW_TYPE ERROR_SHOW_TYPE_MAX = ERROR_SHOW_TYPE_CHAT;
const int ERROR_SHOW_TYPE_ARRAYSIZE = ERROR_SHOW_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_SHOW_TYPE_descriptor();
inline const ::std::string& ERROR_SHOW_TYPE_Name(ERROR_SHOW_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_SHOW_TYPE_descriptor(), value);
}
inline bool ERROR_SHOW_TYPE_Parse(
    const ::std::string& name, ERROR_SHOW_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_SHOW_TYPE>(
    ERROR_SHOW_TYPE_descriptor(), name, value);
}
enum ERROR_CODE {
  ERROR_SUCCESS = 0,
  ERROR_INNER = 1,
  ERROR_DIAMOND_NOT_ENOUGH = 2,
  ERROR_BEANS_NOT_ENOUGH = 3,
  ERROR_INVENTORY_FULL = 4,
  ERROR_REWARD_HAS_GOT = 5,
  ERROR_HUANLEDOU_LIMIT = 6,
  ERROR_MALL_NOT_FOUND = 7,
  ERROR_ACTIVITY_NOT_OPEN = 8,
  ERROR_CLIENT_DATA = 9,
  ERROR_HAS_NO_PLAYER = 10,
  ERROR_ROOM_NOT_FOUNT = 20,
  ERROR_ROOM_PASSWORD = 21,
  ERROR_ROOM_IS_FULL = 22,
  ERROR_ROOM_NOT_AVAILABLE = 23,
  ERROR_ROOM_NO_PERMISSION = 24,
  ERROR_ROOM_BEANS_MIN_LIMIT = 25,
  ERROR_ROOM_BEANS_MAX_LIMIT = 26,
  ERROR_ROOM_TYPE_NOT_FOUND = 27,
  ERROR_ROOM_HAS_BEEN_IN = 28,
  ERROR_GAME_NO_PERMISSION = 40,
  ERROR_GAME_PAI_UNSATISFIED = 41
};
bool ERROR_CODE_IsValid(int value);
const ERROR_CODE ERROR_CODE_MIN = ERROR_SUCCESS;
const ERROR_CODE ERROR_CODE_MAX = ERROR_GAME_PAI_UNSATISFIED;
const int ERROR_CODE_ARRAYSIZE = ERROR_CODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERROR_CODE_descriptor();
inline const ::std::string& ERROR_CODE_Name(ERROR_CODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERROR_CODE_descriptor(), value);
}
inline bool ERROR_CODE_Parse(
    const ::std::string& name, ERROR_CODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERROR_CODE>(
    ERROR_CODE_descriptor(), name, value);
}
enum META_TYPE {
  META_TYPE_SHARE_BEGIN = 1,
  META_TYPE_SHARE_CREATE_PLAYER = 2,
  META_TYPE_SHARE_CREATE_ROOM = 3,
  META_TYPE_SHARE_PAI_OPERATION = 4,
  META_TYPE_SHARE_GAME_OPERATION = 5,
  META_TYPE_SHARE_COMMON_PROPERTY = 6,
  META_TYPE_SHARE_BUY_SOMETHING = 7,
  META_TYPE_SHARE_ENTER_ROOM = 8,
  META_TYPE_SHARE_SIGN = 9,
  META_TYPE_SHARE_LUCKY_PLATE = 10,
  META_TYPE_SHARE_COUNT = 50,
  META_TYPE_C2S_BEGIN = 51,
  META_TYPE_C2S_LOGIN = 52,
  META_TYPE_C2S_LOGOUT = 53,
  META_TYPE_C2S_SELECT_SERVER = 54,
  META_TYPE_C2S_ENTER_GAME = 55,
  META_TYPE_C2S_GET_REWARD = 56,
  META_TYPE_C2S_LOAD_SCENE = 57,
  META_TYPE_C2S_COUNT = 255,
  META_TYPE_S2C_BEGIN = 501,
  META_TYPE_S2C_TICKET = 502,
  META_TYPE_S2C_SERVER_LIST = 503,
  META_TYPE_S2C_PLAYERS = 504,
  META_TYPE_S2C_PLAYER_INFO = 505,
  META_TYPE_S2C_ALERT_ERROR = 507,
  META_TYPE_S2C_COMMON_OPERATION_RESPONSE = 508,
  META_TYPE_S2C_PAI_NOTIFY = 509,
  META_TYPE_S2C_PAI_OPERATION_ALERT = 510,
  META_TYPE_S2C_COMMON_LIMIT = 511,
  META_TYPE_S2C_COMMON_REWARD = 512,
  META_TYPE_S2C_ROOM_INFO = 513,
  META_TYPE_S2C_COUNT = 1000,
  META_TYPE_S2S_BEGIN = 1001,
  META_TYPE_S2S_REGISTER = 1002,
  META_TYPE_S2S_COUNT = 1500
};
bool META_TYPE_IsValid(int value);
const META_TYPE META_TYPE_MIN = META_TYPE_SHARE_BEGIN;
const META_TYPE META_TYPE_MAX = META_TYPE_S2S_COUNT;
const int META_TYPE_ARRAYSIZE = META_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* META_TYPE_descriptor();
inline const ::std::string& META_TYPE_Name(META_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    META_TYPE_descriptor(), value);
}
inline bool META_TYPE_Parse(
    const ::std::string& name, META_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<META_TYPE>(
    META_TYPE_descriptor(), name, value);
}
enum ROOM_MODEL_TYPE {
  ROOM_MODEL_TYPE_CLASSICAL = 1,
  ROOM_MODEL_TYPE_MULTIPLE = 2,
  ROOM_MODEL_TYPE_PAO_TRIPLE = 3
};
bool ROOM_MODEL_TYPE_IsValid(int value);
const ROOM_MODEL_TYPE ROOM_MODEL_TYPE_MIN = ROOM_MODEL_TYPE_CLASSICAL;
const ROOM_MODEL_TYPE ROOM_MODEL_TYPE_MAX = ROOM_MODEL_TYPE_PAO_TRIPLE;
const int ROOM_MODEL_TYPE_ARRAYSIZE = ROOM_MODEL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROOM_MODEL_TYPE_descriptor();
inline const ::std::string& ROOM_MODEL_TYPE_Name(ROOM_MODEL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROOM_MODEL_TYPE_descriptor(), value);
}
inline bool ROOM_MODEL_TYPE_Parse(
    const ::std::string& name, ROOM_MODEL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROOM_MODEL_TYPE>(
    ROOM_MODEL_TYPE_descriptor(), name, value);
}
enum ROOM_EXTEND_TYPE {
  ROOM_EXTEND_TYPE_JIAHU = 1,
  ROOM_EXTEND_TYPE_BAOPAI = 2,
  ROOM_EXTEND_TYPE_XUANFENGGANG = 3,
  ROOM_EXTEND_TYPE_ZHANLIHU = 4,
  ROOM_EXTEND_TYPE_DUANMEN = 5,
  ROOM_EXTEND_TYPE_HUIPAI = 6
};
bool ROOM_EXTEND_TYPE_IsValid(int value);
const ROOM_EXTEND_TYPE ROOM_EXTEND_TYPE_MIN = ROOM_EXTEND_TYPE_JIAHU;
const ROOM_EXTEND_TYPE ROOM_EXTEND_TYPE_MAX = ROOM_EXTEND_TYPE_HUIPAI;
const int ROOM_EXTEND_TYPE_ARRAYSIZE = ROOM_EXTEND_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROOM_EXTEND_TYPE_descriptor();
inline const ::std::string& ROOM_EXTEND_TYPE_Name(ROOM_EXTEND_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROOM_EXTEND_TYPE_descriptor(), value);
}
inline bool ROOM_EXTEND_TYPE_Parse(
    const ::std::string& name, ROOM_EXTEND_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROOM_EXTEND_TYPE>(
    ROOM_EXTEND_TYPE_descriptor(), name, value);
}
enum PAI_CHECK_RETURN {
  PAI_CHECK_RETURN_NULL = 0,
  PAI_CHECK_RETURN_HU = 1,
  PAI_CHECK_RETURN_GANG = 2,
  PAI_CHECK_RETURN_PENG = 3,
  PAI_CHECK_RETURN_CHI = 4,
  PAI_CHECK_GANG_XUANFENG_FENG = 5,
  PAI_CHECK_GANG_XUANFENG_JIAN = 6,
  PAI_CHECK_RETURN_ANGANG = 7
};
bool PAI_CHECK_RETURN_IsValid(int value);
const PAI_CHECK_RETURN PAI_CHECK_RETURN_MIN = PAI_CHECK_RETURN_NULL;
const PAI_CHECK_RETURN PAI_CHECK_RETURN_MAX = PAI_CHECK_RETURN_ANGANG;
const int PAI_CHECK_RETURN_ARRAYSIZE = PAI_CHECK_RETURN_MAX + 1;

const ::google::protobuf::EnumDescriptor* PAI_CHECK_RETURN_descriptor();
inline const ::std::string& PAI_CHECK_RETURN_Name(PAI_CHECK_RETURN value) {
  return ::google::protobuf::internal::NameOfEnum(
    PAI_CHECK_RETURN_descriptor(), value);
}
inline bool PAI_CHECK_RETURN_Parse(
    const ::std::string& name, PAI_CHECK_RETURN* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PAI_CHECK_RETURN>(
    PAI_CHECK_RETURN_descriptor(), name, value);
}
enum GAME_OPER_TYPE {
  GAME_OPER_TYPE_NULL = 1,
  GAME_OPER_TYPE_START = 2,
  GAME_OPER_TYPE_LEAVE = 3,
  GAME_OPER_TYPE_KICKOUT = 4
};
bool GAME_OPER_TYPE_IsValid(int value);
const GAME_OPER_TYPE GAME_OPER_TYPE_MIN = GAME_OPER_TYPE_NULL;
const GAME_OPER_TYPE GAME_OPER_TYPE_MAX = GAME_OPER_TYPE_KICKOUT;
const int GAME_OPER_TYPE_ARRAYSIZE = GAME_OPER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GAME_OPER_TYPE_descriptor();
inline const ::std::string& GAME_OPER_TYPE_Name(GAME_OPER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GAME_OPER_TYPE_descriptor(), value);
}
inline bool GAME_OPER_TYPE_Parse(
    const ::std::string& name, GAME_OPER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GAME_OPER_TYPE>(
    GAME_OPER_TYPE_descriptor(), name, value);
}
// ===================================================================

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Account)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* username_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class PaiElement : public ::google::protobuf::Message {
 public:
  PaiElement();
  virtual ~PaiElement();

  PaiElement(const PaiElement& from);

  inline PaiElement& operator=(const PaiElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiElement& default_instance();

  void Swap(PaiElement* other);

  // implements Message ----------------------------------------------

  PaiElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiElement& from);
  void MergeFrom(const PaiElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // optional int32 card_value = 2;
  inline bool has_card_value() const;
  inline void clear_card_value();
  static const int kCardValueFieldNumber = 2;
  inline ::google::protobuf::int32 card_value() const;
  inline void set_card_value(::google::protobuf::int32 value);

  // optional int32 card_index = 3;
  inline bool has_card_index() const;
  inline void clear_card_index();
  static const int kCardIndexFieldNumber = 3;
  inline ::google::protobuf::int32 card_index() const;
  inline void set_card_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiElement)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_card_value();
  inline void clear_has_card_value();
  inline void set_has_card_index();
  inline void clear_has_card_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int card_type_;
  ::google::protobuf::int32 card_value_;
  ::google::protobuf::int32 card_index_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiElement* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.Account account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::Adoter::Asset::Account& account() const;
  inline ::Adoter::Asset::Account* mutable_account();
  inline ::Adoter::Asset::Account* release_account();
  inline void set_allocated_account(::Adoter::Asset::Account* account);

  // repeated int64 player_list = 2;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 2;
  inline ::google::protobuf::int64 player_list(int index) const;
  inline void set_player_list(int index, ::google::protobuf::int64 value);
  inline void add_player_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      player_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.User)
 private:
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Account* account_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > player_list_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class PlayerProp : public ::google::protobuf::Message {
 public:
  PlayerProp();
  virtual ~PlayerProp();

  PlayerProp(const PlayerProp& from);

  inline PlayerProp& operator=(const PlayerProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerProp& default_instance();

  void Swap(PlayerProp* other);

  // implements Message ----------------------------------------------

  PlayerProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerProp& from);
  void MergeFrom(const PlayerProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool online = 1;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 1;
  inline bool online() const;
  inline void set_online(bool value);

  // optional .Adoter.Asset.POSITION_TYPE position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional int64 room_id = 3;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 3;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 4;
  inline bool has_load_type() const;
  inline void clear_load_type();
  static const int kLoadTypeFieldNumber = 4;
  inline ::Adoter::Asset::LOAD_SCENE_TYPE load_type() const;
  inline void set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value);

  // optional .Adoter.Asset.GAME_OPER_TYPE game_oper_state = 5;
  inline bool has_game_oper_state() const;
  inline void clear_game_oper_state();
  static const int kGameOperStateFieldNumber = 5;
  inline ::Adoter::Asset::GAME_OPER_TYPE game_oper_state() const;
  inline void set_game_oper_state(::Adoter::Asset::GAME_OPER_TYPE value);

  // optional bool check_feng_gang = 6;
  inline bool has_check_feng_gang() const;
  inline void clear_check_feng_gang();
  static const int kCheckFengGangFieldNumber = 6;
  inline bool check_feng_gang() const;
  inline void set_check_feng_gang(bool value);

  // optional bool check_jian_gang = 7;
  inline bool has_check_jian_gang() const;
  inline void clear_check_jian_gang();
  static const int kCheckJianGangFieldNumber = 7;
  inline bool check_jian_gang() const;
  inline void set_check_jian_gang(bool value);

  // optional int32 pai_oper_count = 8;
  inline bool has_pai_oper_count() const;
  inline void clear_pai_oper_count();
  static const int kPaiOperCountFieldNumber = 8;
  inline ::google::protobuf::int32 pai_oper_count() const;
  inline void set_pai_oper_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerProp)
 private:
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_load_type();
  inline void clear_has_load_type();
  inline void set_has_game_oper_state();
  inline void clear_has_game_oper_state();
  inline void set_has_check_feng_gang();
  inline void clear_has_check_feng_gang();
  inline void set_has_check_jian_gang();
  inline void clear_has_check_jian_gang();
  inline void set_has_pai_oper_count();
  inline void clear_has_pai_oper_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  int position_;
  int load_type_;
  bool online_;
  bool check_feng_gang_;
  bool check_jian_gang_;
  int game_oper_state_;
  ::google::protobuf::int32 pai_oper_count_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerProp* default_instance_;
};
// -------------------------------------------------------------------

class CommonProp : public ::google::protobuf::Message {
 public:
  CommonProp();
  virtual ~CommonProp();

  CommonProp(const CommonProp& from);

  inline CommonProp& operator=(const CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonProp& default_instance();

  void Swap(CommonProp* other);

  // implements Message ----------------------------------------------

  CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonProp& from);
  void MergeFrom(const CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int32 local_server_id = 2;
  inline bool has_local_server_id() const;
  inline void clear_local_server_id();
  static const int kLocalServerIdFieldNumber = 2;
  inline ::google::protobuf::int32 local_server_id() const;
  inline void set_local_server_id(::google::protobuf::int32 value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 level = 4 [default = 1];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional .Adoter.Asset.GENDER_TYPE gender = 5 [default = GENDER_TYPE_MAN];
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 5;
  inline ::Adoter::Asset::GENDER_TYPE gender() const;
  inline void set_gender(::Adoter::Asset::GENDER_TYPE value);

  // optional int64 diamond = 6;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 6;
  inline ::google::protobuf::int64 diamond() const;
  inline void set_diamond(::google::protobuf::int64 value);

  // optional int64 huanledou = 7;
  inline bool has_huanledou() const;
  inline void clear_huanledou();
  static const int kHuanledouFieldNumber = 7;
  inline ::google::protobuf::int64 huanledou() const;
  inline void set_huanledou(::google::protobuf::int64 value);

  // optional int64 total_rounds = 8;
  inline bool has_total_rounds() const;
  inline void clear_total_rounds();
  static const int kTotalRoundsFieldNumber = 8;
  inline ::google::protobuf::int64 total_rounds() const;
  inline void set_total_rounds(::google::protobuf::int64 value);

  // optional int64 total_win_rounds = 9;
  inline bool has_total_win_rounds() const;
  inline void clear_total_win_rounds();
  static const int kTotalWinRoundsFieldNumber = 9;
  inline ::google::protobuf::int64 total_win_rounds() const;
  inline void set_total_win_rounds(::google::protobuf::int64 value);

  // optional int64 streak_wins = 10;
  inline bool has_streak_wins() const;
  inline void clear_streak_wins();
  static const int kStreakWinsFieldNumber = 10;
  inline ::google::protobuf::int64 streak_wins() const;
  inline void set_streak_wins(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonProp)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_local_server_id();
  inline void clear_has_local_server_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  inline void set_has_huanledou();
  inline void clear_has_huanledou();
  inline void set_has_total_rounds();
  inline void clear_has_total_rounds();
  inline void set_has_total_win_rounds();
  inline void clear_has_total_win_rounds();
  inline void set_has_streak_wins();
  inline void clear_has_streak_wins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::std::string* name_;
  ::google::protobuf::int32 local_server_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int64 diamond_;
  ::google::protobuf::int64 huanledou_;
  ::google::protobuf::int64 total_rounds_;
  ::google::protobuf::int64 total_win_rounds_;
  ::google::protobuf::int64 streak_wins_;
  int gender_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCommonLimit_Element : public ::google::protobuf::Message {
 public:
  PlayerCommonLimit_Element();
  virtual ~PlayerCommonLimit_Element();

  PlayerCommonLimit_Element(const PlayerCommonLimit_Element& from);

  inline PlayerCommonLimit_Element& operator=(const PlayerCommonLimit_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommonLimit_Element& default_instance();

  void Swap(PlayerCommonLimit_Element* other);

  // implements Message ----------------------------------------------

  PlayerCommonLimit_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCommonLimit_Element& from);
  void MergeFrom(const PlayerCommonLimit_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 common_limit_id = 1;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 1;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // optional int32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::int32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int32 value);

  // optional int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCommonLimit.Element)
 private:
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_limit_id_;
  ::google::protobuf::int32 time_stamp_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCommonLimit_Element* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCommonLimit : public ::google::protobuf::Message {
 public:
  PlayerCommonLimit();
  virtual ~PlayerCommonLimit();

  PlayerCommonLimit(const PlayerCommonLimit& from);

  inline PlayerCommonLimit& operator=(const PlayerCommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCommonLimit& default_instance();

  void Swap(PlayerCommonLimit* other);

  // implements Message ----------------------------------------------

  PlayerCommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCommonLimit& from);
  void MergeFrom(const PlayerCommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerCommonLimit_Element Element;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.PlayerCommonLimit.Element elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Adoter::Asset::PlayerCommonLimit_Element& elements(int index) const;
  inline ::Adoter::Asset::PlayerCommonLimit_Element* mutable_elements(int index);
  inline ::Adoter::Asset::PlayerCommonLimit_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCommonLimit)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element > elements_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCoolDown_Element : public ::google::protobuf::Message {
 public:
  PlayerCoolDown_Element();
  virtual ~PlayerCoolDown_Element();

  PlayerCoolDown_Element(const PlayerCoolDown_Element& from);

  inline PlayerCoolDown_Element& operator=(const PlayerCoolDown_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCoolDown_Element& default_instance();

  void Swap(PlayerCoolDown_Element* other);

  // implements Message ----------------------------------------------

  PlayerCoolDown_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCoolDown_Element& from);
  void MergeFrom(const PlayerCoolDown_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 cool_down_id = 1;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 1;
  inline ::google::protobuf::int64 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int64 value);

  // optional int32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::int32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCoolDown.Element)
 private:
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 cool_down_id_;
  ::google::protobuf::int32 time_stamp_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCoolDown_Element* default_instance_;
};
// -------------------------------------------------------------------

class PlayerCoolDown : public ::google::protobuf::Message {
 public:
  PlayerCoolDown();
  virtual ~PlayerCoolDown();

  PlayerCoolDown(const PlayerCoolDown& from);

  inline PlayerCoolDown& operator=(const PlayerCoolDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerCoolDown& default_instance();

  void Swap(PlayerCoolDown* other);

  // implements Message ----------------------------------------------

  PlayerCoolDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerCoolDown& from);
  void MergeFrom(const PlayerCoolDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PlayerCoolDown_Element Element;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.PlayerCoolDown.Element elements = 1;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 1;
  inline const ::Adoter::Asset::PlayerCoolDown_Element& elements(int index) const;
  inline ::Adoter::Asset::PlayerCoolDown_Element* mutable_elements(int index);
  inline ::Adoter::Asset::PlayerCoolDown_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerCoolDown)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element > elements_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerCoolDown* default_instance_;
};
// -------------------------------------------------------------------

class MailAttachment : public ::google::protobuf::Message {
 public:
  MailAttachment();
  virtual ~MailAttachment();

  MailAttachment(const MailAttachment& from);

  inline MailAttachment& operator=(const MailAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MailAttachment& default_instance();

  void Swap(MailAttachment* other);

  // implements Message ----------------------------------------------

  MailAttachment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MailAttachment& from);
  void MergeFrom(const MailAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 common_reward_id = 1;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 1;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MailAttachment)
 private:
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_reward_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static MailAttachment* default_instance_;
};
// -------------------------------------------------------------------

class Mail : public ::google::protobuf::Message {
 public:
  Mail();
  virtual ~Mail();

  Mail(const Mail& from);

  inline Mail& operator=(const Mail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mail& default_instance();

  void Swap(Mail* other);

  // implements Message ----------------------------------------------

  Mail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mail& from);
  void MergeFrom(const Mail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const void* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional bytes send_player = 2 [default = "\347\263\273\347\273\237\351\202\256\344\273\266"];
  inline bool has_send_player() const;
  inline void clear_send_player();
  static const int kSendPlayerFieldNumber = 2;
  inline const ::std::string& send_player() const;
  inline void set_send_player(const ::std::string& value);
  inline void set_send_player(const char* value);
  inline void set_send_player(const void* value, size_t size);
  inline ::std::string* mutable_send_player();
  inline ::std::string* release_send_player();
  inline void set_allocated_send_player(::std::string* send_player);

  // optional bytes content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional int32 send_time = 4;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 4;
  inline ::google::protobuf::int32 send_time() const;
  inline void set_send_time(::google::protobuf::int32 value);

  // optional bool readed = 5;
  inline bool has_readed() const;
  inline void clear_readed();
  static const int kReadedFieldNumber = 5;
  inline bool readed() const;
  inline void set_readed(bool value);

  // optional .Adoter.Asset.MailAttachment attachment = 6;
  inline bool has_attachment() const;
  inline void clear_attachment();
  static const int kAttachmentFieldNumber = 6;
  inline const ::Adoter::Asset::MailAttachment& attachment() const;
  inline ::Adoter::Asset::MailAttachment* mutable_attachment();
  inline ::Adoter::Asset::MailAttachment* release_attachment();
  inline void set_allocated_attachment(::Adoter::Asset::MailAttachment* attachment);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Mail)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_send_player();
  inline void clear_has_send_player();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_send_time();
  inline void clear_has_send_time();
  inline void set_has_readed();
  inline void clear_has_readed();
  inline void set_has_attachment();
  inline void clear_has_attachment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* title_;
  static ::std::string* _default_send_player_;
  ::std::string* send_player_;
  ::std::string* content_;
  ::google::protobuf::int32 send_time_;
  bool readed_;
  ::Adoter::Asset::MailAttachment* attachment_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Mail* default_instance_;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CommonProp common_prop = 1;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 1;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // optional int64 server_id = 2;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 2;
  inline ::google::protobuf::int64 server_id() const;
  inline void set_server_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.Inventory inventory = 3;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 3;
  inline const ::Adoter::Asset::Inventory& inventory() const;
  inline ::Adoter::Asset::Inventory* mutable_inventory();
  inline ::Adoter::Asset::Inventory* release_inventory();
  inline void set_allocated_inventory(::Adoter::Asset::Inventory* inventory);

  // optional .Adoter.Asset.PlayerCommonLimit common_limit = 4;
  inline bool has_common_limit() const;
  inline void clear_common_limit();
  static const int kCommonLimitFieldNumber = 4;
  inline const ::Adoter::Asset::PlayerCommonLimit& common_limit() const;
  inline ::Adoter::Asset::PlayerCommonLimit* mutable_common_limit();
  inline ::Adoter::Asset::PlayerCommonLimit* release_common_limit();
  inline void set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit);

  // optional .Adoter.Asset.PlayerCoolDown cool_down = 5;
  inline bool has_cool_down() const;
  inline void clear_cool_down();
  static const int kCoolDownFieldNumber = 5;
  inline const ::Adoter::Asset::PlayerCoolDown& cool_down() const;
  inline ::Adoter::Asset::PlayerCoolDown* mutable_cool_down();
  inline ::Adoter::Asset::PlayerCoolDown* release_cool_down();
  inline void set_allocated_cool_down(::Adoter::Asset::PlayerCoolDown* cool_down);

  // optional int32 login_time = 6;
  inline bool has_login_time() const;
  inline void clear_login_time();
  static const int kLoginTimeFieldNumber = 6;
  inline ::google::protobuf::int32 login_time() const;
  inline void set_login_time(::google::protobuf::int32 value);

  // optional int32 logout_time = 7;
  inline bool has_logout_time() const;
  inline void clear_logout_time();
  static const int kLogoutTimeFieldNumber = 7;
  inline ::google::protobuf::int32 logout_time() const;
  inline void set_logout_time(::google::protobuf::int32 value);

  // repeated int32 sign_time = 8;
  inline int sign_time_size() const;
  inline void clear_sign_time();
  static const int kSignTimeFieldNumber = 8;
  inline ::google::protobuf::int32 sign_time(int index) const;
  inline void set_sign_time(int index, ::google::protobuf::int32 value);
  inline void add_sign_time(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      sign_time() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_sign_time();

  // repeated .Adoter.Asset.Mail mail_list = 10;
  inline int mail_list_size() const;
  inline void clear_mail_list();
  static const int kMailListFieldNumber = 10;
  inline const ::Adoter::Asset::Mail& mail_list(int index) const;
  inline ::Adoter::Asset::Mail* mutable_mail_list(int index);
  inline ::Adoter::Asset::Mail* add_mail_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >&
      mail_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >*
      mutable_mail_list();

  // optional .Adoter.Asset.PlayerProp player_prop = 20;
  inline bool has_player_prop() const;
  inline void clear_player_prop();
  static const int kPlayerPropFieldNumber = 20;
  inline const ::Adoter::Asset::PlayerProp& player_prop() const;
  inline ::Adoter::Asset::PlayerProp* mutable_player_prop();
  inline ::Adoter::Asset::PlayerProp* release_player_prop();
  inline void set_allocated_player_prop(::Adoter::Asset::PlayerProp* player_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Player)
 private:
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_common_limit();
  inline void clear_has_common_limit();
  inline void set_has_cool_down();
  inline void clear_has_cool_down();
  inline void set_has_login_time();
  inline void clear_has_login_time();
  inline void set_has_logout_time();
  inline void clear_has_logout_time();
  inline void set_has_player_prop();
  inline void clear_has_player_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::CommonProp* common_prop_;
  ::google::protobuf::int64 server_id_;
  ::Adoter::Asset::Inventory* inventory_;
  ::Adoter::Asset::PlayerCommonLimit* common_limit_;
  ::Adoter::Asset::PlayerCoolDown* cool_down_;
  ::google::protobuf::int32 login_time_;
  ::google::protobuf::int32 logout_time_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > sign_time_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail > mail_list_;
  ::Adoter::Asset::PlayerProp* player_prop_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Player* default_instance_;
};
// -------------------------------------------------------------------

class Inventory_Element : public ::google::protobuf::Message {
 public:
  Inventory_Element();
  virtual ~Inventory_Element();

  Inventory_Element(const Inventory_Element& from);

  inline Inventory_Element& operator=(const Inventory_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inventory_Element& default_instance();

  void Swap(Inventory_Element* other);

  // implements Message ----------------------------------------------

  Inventory_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Inventory_Element& from);
  void MergeFrom(const Inventory_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.INVENTORY_TYPE inventory_type = 1;
  inline bool has_inventory_type() const;
  inline void clear_inventory_type();
  static const int kInventoryTypeFieldNumber = 1;
  inline ::Adoter::Asset::INVENTORY_TYPE inventory_type() const;
  inline void set_inventory_type(::Adoter::Asset::INVENTORY_TYPE value);

  // repeated .Adoter.Asset.Item_Item items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::Adoter::Asset::Item_Item& items(int index) const;
  inline ::Adoter::Asset::Item_Item* mutable_items(int index);
  inline ::Adoter::Asset::Item_Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Inventory.Element)
 private:
  inline void set_has_inventory_type();
  inline void clear_has_inventory_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item > items_;
  int inventory_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Inventory_Element* default_instance_;
};
// -------------------------------------------------------------------

class Inventory : public ::google::protobuf::Message {
 public:
  Inventory();
  virtual ~Inventory();

  Inventory(const Inventory& from);

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inventory& default_instance();

  void Swap(Inventory* other);

  // implements Message ----------------------------------------------

  Inventory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Inventory& from);
  void MergeFrom(const Inventory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Inventory_Element Element;

  // accessors -------------------------------------------------------

  // repeated .Adoter.Asset.Inventory.Element inventory = 1;
  inline int inventory_size() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 1;
  inline const ::Adoter::Asset::Inventory_Element& inventory(int index) const;
  inline ::Adoter::Asset::Inventory_Element* mutable_inventory(int index);
  inline ::Adoter::Asset::Inventory_Element* add_inventory();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >&
      inventory() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >*
      mutable_inventory();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Inventory)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element > inventory_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Inventory* default_instance_;
};
// -------------------------------------------------------------------

class ItemEquipment : public ::google::protobuf::Message {
 public:
  ItemEquipment();
  virtual ~ItemEquipment();

  ItemEquipment(const ItemEquipment& from);

  inline ItemEquipment& operator=(const ItemEquipment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemEquipment& default_instance();

  void Swap(ItemEquipment* other);

  // implements Message ----------------------------------------------

  ItemEquipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemEquipment& from);
  void MergeFrom(const ItemEquipment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 star = 1;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 1;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.ItemEquipment)
 private:
  inline void set_has_star();
  inline void clear_has_star();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 star_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static ItemEquipment* default_instance_;
};
// -------------------------------------------------------------------

class Meta : public ::google::protobuf::Message {
 public:
  Meta();
  virtual ~Meta();

  Meta(const Meta& from);

  inline Meta& operator=(const Meta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Meta& default_instance();

  void Swap(Meta* other);

  // implements Message ----------------------------------------------

  Meta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Meta& from);
  void MergeFrom(const Meta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1;
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes stuff = 2;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 2;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const void* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Meta)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_stuff();
  inline void clear_has_stuff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stuff_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Meta* default_instance_;
};
// -------------------------------------------------------------------

class CreatePlayer : public ::google::protobuf::Message {
 public:
  CreatePlayer();
  virtual ~CreatePlayer();

  CreatePlayer(const CreatePlayer& from);

  inline CreatePlayer& operator=(const CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayer& default_instance();

  void Swap(CreatePlayer* other);

  // implements Message ----------------------------------------------

  CreatePlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePlayer& from);
  void MergeFrom(const CreatePlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_PLAYER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CreatePlayer)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CreatePlayer* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Account account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::Adoter::Asset::Account& account() const;
  inline ::Adoter::Asset::Account* mutable_account();
  inline ::Adoter::Asset::Account* release_account();
  inline void set_allocated_account(::Adoter::Asset::Account* account);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Login)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Account* account_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  void Swap(Logout* other);

  // implements Message ----------------------------------------------

  Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGOUT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Logout)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Logout* default_instance_;
};
// -------------------------------------------------------------------

class EnterGame : public ::google::protobuf::Message {
 public:
  EnterGame();
  virtual ~EnterGame();

  EnterGame(const EnterGame& from);

  inline EnterGame& operator=(const EnterGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterGame& default_instance();

  void Swap(EnterGame* other);

  // implements Message ----------------------------------------------

  EnterGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterGame& from);
  void MergeFrom(const EnterGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_ENTER_GAME];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 player_id = 2;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.EnterGame)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player_id();
  inline void clear_has_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static EnterGame* default_instance_;
};
// -------------------------------------------------------------------

class Room : public ::google::protobuf::Message {
 public:
  Room();
  virtual ~Room();

  Room(const Room& from);

  inline Room& operator=(const Room& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Room& default_instance();

  void Swap(Room* other);

  // implements Message ----------------------------------------------

  Room* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Room& from);
  void MergeFrom(const Room& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 room_id = 1;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 1;
  inline ::google::protobuf::int64 room_id() const;
  inline void set_room_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.ROOM_TYPE room_type = 2;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 2;
  inline ::Adoter::Asset::ROOM_TYPE room_type() const;
  inline void set_room_type(::Adoter::Asset::ROOM_TYPE value);

  // optional bytes enter_password = 3;
  inline bool has_enter_password() const;
  inline void clear_enter_password();
  static const int kEnterPasswordFieldNumber = 3;
  inline const ::std::string& enter_password() const;
  inline void set_enter_password(const ::std::string& value);
  inline void set_enter_password(const char* value);
  inline void set_enter_password(const void* value, size_t size);
  inline ::std::string* mutable_enter_password();
  inline ::std::string* release_enter_password();
  inline void set_allocated_enter_password(::std::string* enter_password);

  // optional .Adoter.Asset.RoomOptions options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::Adoter::Asset::RoomOptions& options() const;
  inline ::Adoter::Asset::RoomOptions* mutable_options();
  inline ::Adoter::Asset::RoomOptions* release_options();
  inline void set_allocated_options(::Adoter::Asset::RoomOptions* options);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Room)
 private:
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_room_type();
  inline void clear_has_room_type();
  inline void set_has_enter_password();
  inline void clear_has_enter_password();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 room_id_;
  ::std::string* enter_password_;
  ::Adoter::Asset::RoomOptions* options_;
  int room_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Room* default_instance_;
};
// -------------------------------------------------------------------

class RoomOptions : public ::google::protobuf::Message {
 public:
  RoomOptions();
  virtual ~RoomOptions();

  RoomOptions(const RoomOptions& from);

  inline RoomOptions& operator=(const RoomOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomOptions& default_instance();

  void Swap(RoomOptions* other);

  // implements Message ----------------------------------------------

  RoomOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomOptions& from);
  void MergeFrom(const RoomOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ROOM_MODEL_TYPE model = 1;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 1;
  inline ::Adoter::Asset::ROOM_MODEL_TYPE model() const;
  inline void set_model(::Adoter::Asset::ROOM_MODEL_TYPE value);

  // repeated .Adoter.Asset.ROOM_EXTEND_TYPE extend_type = 2;
  inline int extend_type_size() const;
  inline void clear_extend_type();
  static const int kExtendTypeFieldNumber = 2;
  inline ::Adoter::Asset::ROOM_EXTEND_TYPE extend_type(int index) const;
  inline void set_extend_type(int index, ::Adoter::Asset::ROOM_EXTEND_TYPE value);
  inline void add_extend_type(::Adoter::Asset::ROOM_EXTEND_TYPE value);
  inline const ::google::protobuf::RepeatedField<int>& extend_type() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_extend_type();

  // optional int32 top_mutiple = 3;
  inline bool has_top_mutiple() const;
  inline void clear_top_mutiple();
  static const int kTopMutipleFieldNumber = 3;
  inline ::google::protobuf::int32 top_mutiple() const;
  inline void set_top_mutiple(::google::protobuf::int32 value);

  // optional int32 open_rands = 4;
  inline bool has_open_rands() const;
  inline void clear_open_rands();
  static const int kOpenRandsFieldNumber = 4;
  inline ::google::protobuf::int32 open_rands() const;
  inline void set_open_rands(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomOptions)
 private:
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_top_mutiple();
  inline void clear_has_top_mutiple();
  inline void set_has_open_rands();
  inline void clear_has_open_rands();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> extend_type_;
  int model_;
  ::google::protobuf::int32 top_mutiple_;
  ::google::protobuf::int32 open_rands_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomOptions* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom : public ::google::protobuf::Message {
 public:
  CreateRoom();
  virtual ~CreateRoom();

  CreateRoom(const CreateRoom& from);

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoom& default_instance();

  void Swap(CreateRoom* other);

  // implements Message ----------------------------------------------

  CreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Room room = 2;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 2;
  inline const ::Adoter::Asset::Room& room() const;
  inline ::Adoter::Asset::Room* mutable_room();
  inline ::Adoter::Asset::Room* release_room();
  inline void set_allocated_room(::Adoter::Asset::Room* room);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CreateRoom)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room();
  inline void clear_has_room();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Room* room_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoom : public ::google::protobuf::Message {
 public:
  EnterRoom();
  virtual ~EnterRoom();

  EnterRoom(const EnterRoom& from);

  inline EnterRoom& operator=(const EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoom& default_instance();

  void Swap(EnterRoom* other);

  // implements Message ----------------------------------------------

  EnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoom& from);
  void MergeFrom(const EnterRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef EnterRoom_ENTER_TYPE ENTER_TYPE;
  static const ENTER_TYPE ENTER_TYPE_ENTER = EnterRoom_ENTER_TYPE_ENTER_TYPE_ENTER;
  static const ENTER_TYPE ENTER_TYPE_CANCEL = EnterRoom_ENTER_TYPE_ENTER_TYPE_CANCEL;
  static inline bool ENTER_TYPE_IsValid(int value) {
    return EnterRoom_ENTER_TYPE_IsValid(value);
  }
  static const ENTER_TYPE ENTER_TYPE_MIN =
    EnterRoom_ENTER_TYPE_ENTER_TYPE_MIN;
  static const ENTER_TYPE ENTER_TYPE_MAX =
    EnterRoom_ENTER_TYPE_ENTER_TYPE_MAX;
  static const int ENTER_TYPE_ARRAYSIZE =
    EnterRoom_ENTER_TYPE_ENTER_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ENTER_TYPE_descriptor() {
    return EnterRoom_ENTER_TYPE_descriptor();
  }
  static inline const ::std::string& ENTER_TYPE_Name(ENTER_TYPE value) {
    return EnterRoom_ENTER_TYPE_Name(value);
  }
  static inline bool ENTER_TYPE_Parse(const ::std::string& name,
      ENTER_TYPE* value) {
    return EnterRoom_ENTER_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_ENTER_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Room room = 2;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 2;
  inline const ::Adoter::Asset::Room& room() const;
  inline ::Adoter::Asset::Room* mutable_room();
  inline ::Adoter::Asset::Room* release_room();
  inline void set_allocated_room(::Adoter::Asset::Room* room);

  // optional .Adoter.Asset.ERROR_CODE error_code = 3;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 3;
  inline ::Adoter::Asset::ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::ERROR_CODE value);

  // optional .Adoter.Asset.EnterRoom.ENTER_TYPE enter_type = 4;
  inline bool has_enter_type() const;
  inline void clear_enter_type();
  static const int kEnterTypeFieldNumber = 4;
  inline ::Adoter::Asset::EnterRoom_ENTER_TYPE enter_type() const;
  inline void set_enter_type(::Adoter::Asset::EnterRoom_ENTER_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.EnterRoom)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_enter_type();
  inline void clear_has_enter_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Room* room_;
  int type_t_;
  int error_code_;
  int enter_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static EnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class Sign : public ::google::protobuf::Message {
 public:
  Sign();
  virtual ~Sign();

  Sign(const Sign& from);

  inline Sign& operator=(const Sign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sign& default_instance();

  void Swap(Sign* other);

  // implements Message ----------------------------------------------

  Sign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sign& from);
  void MergeFrom(const Sign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SIGN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional bool success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline bool success() const;
  inline void set_success(bool value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Sign)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  bool success_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static Sign* default_instance_;
};
// -------------------------------------------------------------------

class PlayerLuckyPlate : public ::google::protobuf::Message {
 public:
  PlayerLuckyPlate();
  virtual ~PlayerLuckyPlate();

  PlayerLuckyPlate(const PlayerLuckyPlate& from);

  inline PlayerLuckyPlate& operator=(const PlayerLuckyPlate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLuckyPlate& default_instance();

  void Swap(PlayerLuckyPlate* other);

  // implements Message ----------------------------------------------

  PlayerLuckyPlate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerLuckyPlate& from);
  void MergeFrom(const PlayerLuckyPlate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_LUCKY_PLATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 plate_id = 2;
  inline bool has_plate_id() const;
  inline void clear_plate_id();
  static const int kPlateIdFieldNumber = 2;
  inline ::google::protobuf::int64 plate_id() const;
  inline void set_plate_id(::google::protobuf::int64 value);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerLuckyPlate)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_plate_id();
  inline void clear_has_plate_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 plate_id_;
  int type_t_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerLuckyPlate* default_instance_;
};
// -------------------------------------------------------------------

class GetReward : public ::google::protobuf::Message {
 public:
  GetReward();
  virtual ~GetReward();

  GetReward(const GetReward& from);

  inline GetReward& operator=(const GetReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetReward& default_instance();

  void Swap(GetReward* other);

  // implements Message ----------------------------------------------

  GetReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetReward& from);
  void MergeFrom(const GetReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GetReward_GET_REWARD_REASON GET_REWARD_REASON;
  static const GET_REWARD_REASON GET_REWARD_REASON_DAILY_BONUS = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_BONUS;
  static const GET_REWARD_REASON GET_REWARD_REASON_DAILY_ALLOWANCE = GetReward_GET_REWARD_REASON_GET_REWARD_REASON_DAILY_ALLOWANCE;
  static inline bool GET_REWARD_REASON_IsValid(int value) {
    return GetReward_GET_REWARD_REASON_IsValid(value);
  }
  static const GET_REWARD_REASON GET_REWARD_REASON_MIN =
    GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MIN;
  static const GET_REWARD_REASON GET_REWARD_REASON_MAX =
    GetReward_GET_REWARD_REASON_GET_REWARD_REASON_MAX;
  static const int GET_REWARD_REASON_ARRAYSIZE =
    GetReward_GET_REWARD_REASON_GET_REWARD_REASON_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GET_REWARD_REASON_descriptor() {
    return GetReward_GET_REWARD_REASON_descriptor();
  }
  static inline const ::std::string& GET_REWARD_REASON_Name(GET_REWARD_REASON value) {
    return GetReward_GET_REWARD_REASON_Name(value);
  }
  static inline bool GET_REWARD_REASON_Parse(const ::std::string& name,
      GET_REWARD_REASON* value) {
    return GetReward_GET_REWARD_REASON_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_GET_REWARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.GetReward.GET_REWARD_REASON reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::Adoter::Asset::GetReward_GET_REWARD_REASON reason() const;
  inline void set_reason(::Adoter::Asset::GetReward_GET_REWARD_REASON value);

  // optional int64 reward_id = 3;
  inline bool has_reward_id() const;
  inline void clear_reward_id();
  static const int kRewardIdFieldNumber = 3;
  inline ::google::protobuf::int64 reward_id() const;
  inline void set_reward_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GetReward)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_reward_id();
  inline void clear_has_reward_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int reason_;
  ::google::protobuf::int64 reward_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GetReward* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperationLimit : public ::google::protobuf::Message {
 public:
  PaiOperationLimit();
  virtual ~PaiOperationLimit();

  PaiOperationLimit(const PaiOperationLimit& from);

  inline PaiOperationLimit& operator=(const PaiOperationLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperationLimit& default_instance();

  void Swap(PaiOperationLimit* other);

  // implements Message ----------------------------------------------

  PaiOperationLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperationLimit& from);
  void MergeFrom(const PaiOperationLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int64 from_player_id = 2;
  inline bool has_from_player_id() const;
  inline void clear_from_player_id();
  static const int kFromPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 from_player_id() const;
  inline void set_from_player_id(::google::protobuf::int64 value);

  // optional int32 time_out = 3;
  inline bool has_time_out() const;
  inline void clear_time_out();
  static const int kTimeOutFieldNumber = 3;
  inline ::google::protobuf::int32 time_out() const;
  inline void set_time_out(::google::protobuf::int32 value);

  // optional .Adoter.Asset.PaiElement pai = 4;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // optional .Adoter.Asset.PAI_CHECK_RETURN oper_limit = 5;
  inline bool has_oper_limit() const;
  inline void clear_oper_limit();
  static const int kOperLimitFieldNumber = 5;
  inline ::Adoter::Asset::PAI_CHECK_RETURN oper_limit() const;
  inline void set_oper_limit(::Adoter::Asset::PAI_CHECK_RETURN value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperationLimit)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_from_player_id();
  inline void clear_has_from_player_id();
  inline void set_has_time_out();
  inline void clear_has_time_out();
  inline void set_has_pai();
  inline void clear_has_pai();
  inline void set_has_oper_limit();
  inline void clear_has_oper_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::google::protobuf::int64 from_player_id_;
  ::Adoter::Asset::PaiElement* pai_;
  ::google::protobuf::int32 time_out_;
  int oper_limit_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperationLimit* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperationList : public ::google::protobuf::Message {
 public:
  PaiOperationList();
  virtual ~PaiOperationList();

  PaiOperationList(const PaiOperationList& from);

  inline PaiOperationList& operator=(const PaiOperationList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperationList& default_instance();

  void Swap(PaiOperationList* other);

  // implements Message ----------------------------------------------

  PaiOperationList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperationList& from);
  void MergeFrom(const PaiOperationList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 player_id = 1;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional int64 from_player_id = 2;
  inline bool has_from_player_id() const;
  inline void clear_from_player_id();
  static const int kFromPlayerIdFieldNumber = 2;
  inline ::google::protobuf::int64 from_player_id() const;
  inline void set_from_player_id(::google::protobuf::int64 value);

  // optional int32 time_out = 3;
  inline bool has_time_out() const;
  inline void clear_time_out();
  static const int kTimeOutFieldNumber = 3;
  inline ::google::protobuf::int32 time_out() const;
  inline void set_time_out(::google::protobuf::int32 value);

  // optional .Adoter.Asset.PaiElement pai = 4;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // repeated .Adoter.Asset.PAI_CHECK_RETURN oper_list = 5;
  inline int oper_list_size() const;
  inline void clear_oper_list();
  static const int kOperListFieldNumber = 5;
  inline ::Adoter::Asset::PAI_CHECK_RETURN oper_list(int index) const;
  inline void set_oper_list(int index, ::Adoter::Asset::PAI_CHECK_RETURN value);
  inline void add_oper_list(::Adoter::Asset::PAI_CHECK_RETURN value);
  inline const ::google::protobuf::RepeatedField<int>& oper_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_oper_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperationList)
 private:
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_from_player_id();
  inline void clear_has_from_player_id();
  inline void set_has_time_out();
  inline void clear_has_time_out();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 player_id_;
  ::google::protobuf::int64 from_player_id_;
  ::Adoter::Asset::PaiElement* pai_;
  ::google::protobuf::RepeatedField<int> oper_list_;
  ::google::protobuf::int32 time_out_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperationList* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperation : public ::google::protobuf::Message {
 public:
  PaiOperation();
  virtual ~PaiOperation();

  PaiOperation(const PaiOperation& from);

  inline PaiOperation& operator=(const PaiOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperation& default_instance();

  void Swap(PaiOperation* other);

  // implements Message ----------------------------------------------

  PaiOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperation& from);
  void MergeFrom(const PaiOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PaiOperation_PAI_OPER_TYPE PAI_OPER_TYPE;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_DAPAI = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_DAPAI;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_HUPAI = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_HUPAI;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_GANGPAI = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_GANGPAI;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_PENGPAI = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_PENGPAI;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_CHIPAI = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_CHIPAI;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_GIVEUP = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_GIVEUP;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_XUANFENG_FENG = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_XUANFENG_FENG;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_XUANFENG_JIAN = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_XUANFENG_JIAN;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_ANGANGPAI = PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_ANGANGPAI;
  static inline bool PAI_OPER_TYPE_IsValid(int value) {
    return PaiOperation_PAI_OPER_TYPE_IsValid(value);
  }
  static const PAI_OPER_TYPE PAI_OPER_TYPE_MIN =
    PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_MIN;
  static const PAI_OPER_TYPE PAI_OPER_TYPE_MAX =
    PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_MAX;
  static const int PAI_OPER_TYPE_ARRAYSIZE =
    PaiOperation_PAI_OPER_TYPE_PAI_OPER_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PAI_OPER_TYPE_descriptor() {
    return PaiOperation_PAI_OPER_TYPE_descriptor();
  }
  static inline const ::std::string& PAI_OPER_TYPE_Name(PAI_OPER_TYPE value) {
    return PaiOperation_PAI_OPER_TYPE_Name(value);
  }
  static inline bool PAI_OPER_TYPE_Parse(const ::std::string& name,
      PAI_OPER_TYPE* value) {
    return PaiOperation_PAI_OPER_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_PAI_OPERATION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.PaiOperation.PAI_OPER_TYPE oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::Adoter::Asset::PaiOperation_PAI_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::PaiOperation_PAI_OPER_TYPE value);

  // optional .Adoter.Asset.POSITION_TYPE position = 3;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 3;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // repeated .Adoter.Asset.PaiElement pais = 4;
  inline int pais_size() const;
  inline void clear_pais();
  static const int kPaisFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pais(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_pais(int index);
  inline ::Adoter::Asset::PaiElement* add_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_pais();

  // optional .Adoter.Asset.PaiElement pai = 5;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 5;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int oper_type_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > pais_;
  ::Adoter::Asset::PaiElement* pai_;
  int position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperation* default_instance_;
};
// -------------------------------------------------------------------

class GameOperation : public ::google::protobuf::Message {
 public:
  GameOperation();
  virtual ~GameOperation();

  GameOperation(const GameOperation& from);

  inline GameOperation& operator=(const GameOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameOperation& default_instance();

  void Swap(GameOperation* other);

  // implements Message ----------------------------------------------

  GameOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameOperation& from);
  void MergeFrom(const GameOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GAME_OPERATION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 2;
  inline bool has_oper_type() const;
  inline void clear_oper_type();
  static const int kOperTypeFieldNumber = 2;
  inline ::Adoter::Asset::GAME_OPER_TYPE oper_type() const;
  inline void set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value);

  // optional int64 source_player_id = 3;
  inline bool has_source_player_id() const;
  inline void clear_source_player_id();
  static const int kSourcePlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 source_player_id() const;
  inline void set_source_player_id(::google::protobuf::int64 value);

  // optional int64 destination_player_id = 4;
  inline bool has_destination_player_id() const;
  inline void clear_destination_player_id();
  static const int kDestinationPlayerIdFieldNumber = 4;
  inline ::google::protobuf::int64 destination_player_id() const;
  inline void set_destination_player_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.GameOperation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_oper_type();
  inline void clear_has_oper_type();
  inline void set_has_source_player_id();
  inline void clear_has_source_player_id();
  inline void set_has_destination_player_id();
  inline void clear_has_destination_player_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int oper_type_;
  ::google::protobuf::int64 source_player_id_;
  ::google::protobuf::int64 destination_player_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static GameOperation* default_instance_;
};
// -------------------------------------------------------------------

class BuySomething : public ::google::protobuf::Message {
 public:
  BuySomething();
  virtual ~BuySomething();

  BuySomething(const BuySomething& from);

  inline BuySomething& operator=(const BuySomething& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuySomething& default_instance();

  void Swap(BuySomething* other);

  // implements Message ----------------------------------------------

  BuySomething* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuySomething& from);
  void MergeFrom(const BuySomething& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_BUY_SOMETHING];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 mall_id = 2;
  inline bool has_mall_id() const;
  inline void clear_mall_id();
  static const int kMallIdFieldNumber = 2;
  inline ::google::protobuf::int64 mall_id() const;
  inline void set_mall_id(::google::protobuf::int64 value);

  // optional int32 result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.BuySomething)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_mall_id();
  inline void clear_has_mall_id();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 mall_id_;
  int type_t_;
  ::google::protobuf::int32 result_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static BuySomething* default_instance_;
};
// -------------------------------------------------------------------

class LoadScene : public ::google::protobuf::Message {
 public:
  LoadScene();
  virtual ~LoadScene();

  LoadScene(const LoadScene& from);

  inline LoadScene& operator=(const LoadScene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadScene& default_instance();

  void Swap(LoadScene* other);

  // implements Message ----------------------------------------------

  LoadScene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadScene& from);
  void MergeFrom(const LoadScene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOAD_SCENE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 2;
  inline bool has_load_type() const;
  inline void clear_load_type();
  static const int kLoadTypeFieldNumber = 2;
  inline ::Adoter::Asset::LOAD_SCENE_TYPE load_type() const;
  inline void set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value);

  // optional int64 scene_id = 3;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 3;
  inline ::google::protobuf::int64 scene_id() const;
  inline void set_scene_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LoadScene)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_load_type();
  inline void clear_has_load_type();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int load_type_;
  ::google::protobuf::int64 scene_id_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static LoadScene* default_instance_;
};
// -------------------------------------------------------------------

class PlayerList : public ::google::protobuf::Message {
 public:
  PlayerList();
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerList& default_instance();

  void Swap(PlayerList* other);

  // implements Message ----------------------------------------------

  PlayerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYERS];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated int64 player_list = 2;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 2;
  inline ::google::protobuf::int64 player_list(int index) const;
  inline void set_player_list(int index, ::google::protobuf::int64 value);
  inline void add_player_list(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      player_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerList)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > player_list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerList* default_instance_;
};
// -------------------------------------------------------------------

class PlayerInformation : public ::google::protobuf::Message {
 public:
  PlayerInformation();
  virtual ~PlayerInformation();

  PlayerInformation(const PlayerInformation& from);

  inline PlayerInformation& operator=(const PlayerInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInformation& default_instance();

  void Swap(PlayerInformation* other);

  // implements Message ----------------------------------------------

  PlayerInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInformation& from);
  void MergeFrom(const PlayerInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYER_INFO];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.Player player = 2;
  inline bool has_player() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 2;
  inline const ::Adoter::Asset::Player& player() const;
  inline ::Adoter::Asset::Player* mutable_player();
  inline ::Adoter::Asset::Player* release_player();
  inline void set_allocated_player(::Adoter::Asset::Player* player);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PlayerInformation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_player();
  inline void clear_has_player();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Player* player_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PlayerInformation* default_instance_;
};
// -------------------------------------------------------------------

class AlertMessage : public ::google::protobuf::Message {
 public:
  AlertMessage();
  virtual ~AlertMessage();

  AlertMessage(const AlertMessage& from);

  inline AlertMessage& operator=(const AlertMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertMessage& default_instance();

  void Swap(AlertMessage* other);

  // implements Message ----------------------------------------------

  AlertMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertMessage& from);
  void MergeFrom(const AlertMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ALERT_ERROR];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.ERROR_TYPE error_type = 2;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 2;
  inline ::Adoter::Asset::ERROR_TYPE error_type() const;
  inline void set_error_type(::Adoter::Asset::ERROR_TYPE value);

  // optional .Adoter.Asset.ERROR_SHOW_TYPE error_show_type = 3;
  inline bool has_error_show_type() const;
  inline void clear_error_show_type();
  static const int kErrorShowTypeFieldNumber = 3;
  inline ::Adoter::Asset::ERROR_SHOW_TYPE error_show_type() const;
  inline void set_error_show_type(::Adoter::Asset::ERROR_SHOW_TYPE value);

  // optional .Adoter.Asset.ERROR_CODE error_code = 4;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 4;
  inline ::Adoter::Asset::ERROR_CODE error_code() const;
  inline void set_error_code(::Adoter::Asset::ERROR_CODE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.AlertMessage)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_error_show_type();
  inline void clear_has_error_show_type();
  inline void set_has_error_code();
  inline void clear_has_error_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int error_type_;
  int error_show_type_;
  int error_code_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static AlertMessage* default_instance_;
};
// -------------------------------------------------------------------

class CommonOperationResponse : public ::google::protobuf::Message {
 public:
  CommonOperationResponse();
  virtual ~CommonOperationResponse();

  CommonOperationResponse(const CommonOperationResponse& from);

  inline CommonOperationResponse& operator=(const CommonOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonOperationResponse& default_instance();

  void Swap(CommonOperationResponse* other);

  // implements Message ----------------------------------------------

  CommonOperationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonOperationResponse& from);
  void MergeFrom(const CommonOperationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_OPERATION_RESPONSE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.META_TYPE client_type_t = 2;
  inline bool has_client_type_t() const;
  inline void clear_client_type_t();
  static const int kClientTypeTFieldNumber = 2;
  inline ::Adoter::Asset::META_TYPE client_type_t() const;
  inline void set_client_type_t(::Adoter::Asset::META_TYPE value);

  // optional bytes client_message = 3;
  inline bool has_client_message() const;
  inline void clear_client_message();
  static const int kClientMessageFieldNumber = 3;
  inline const ::std::string& client_message() const;
  inline void set_client_message(const ::std::string& value);
  inline void set_client_message(const char* value);
  inline void set_client_message(const void* value, size_t size);
  inline ::std::string* mutable_client_message();
  inline ::std::string* release_client_message();
  inline void set_allocated_client_message(::std::string* client_message);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonOperationResponse)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_client_type_t();
  inline void clear_has_client_type_t();
  inline void set_has_client_message();
  inline void clear_has_client_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int client_type_t_;
  ::std::string* client_message_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CommonOperationResponse* default_instance_;
};
// -------------------------------------------------------------------

class PaiNotify_MutiPai : public ::google::protobuf::Message {
 public:
  PaiNotify_MutiPai();
  virtual ~PaiNotify_MutiPai();

  PaiNotify_MutiPai(const PaiNotify_MutiPai& from);

  inline PaiNotify_MutiPai& operator=(const PaiNotify_MutiPai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiNotify_MutiPai& default_instance();

  void Swap(PaiNotify_MutiPai* other);

  // implements Message ----------------------------------------------

  PaiNotify_MutiPai* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiNotify_MutiPai& from);
  void MergeFrom(const PaiNotify_MutiPai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // repeated int32 cards = 2;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 2;
  inline ::google::protobuf::int32 cards(int index) const;
  inline void set_cards(int index, ::google::protobuf::int32 value);
  inline void add_cards(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cards() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cards();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiNotify.MutiPai)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cards_;
  int card_type_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiNotify_MutiPai* default_instance_;
};
// -------------------------------------------------------------------

class PaiNotify_SinglePai : public ::google::protobuf::Message {
 public:
  PaiNotify_SinglePai();
  virtual ~PaiNotify_SinglePai();

  PaiNotify_SinglePai(const PaiNotify_SinglePai& from);

  inline PaiNotify_SinglePai& operator=(const PaiNotify_SinglePai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiNotify_SinglePai& default_instance();

  void Swap(PaiNotify_SinglePai* other);

  // implements Message ----------------------------------------------

  PaiNotify_SinglePai* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiNotify_SinglePai& from);
  void MergeFrom(const PaiNotify_SinglePai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CARD_TYPE card_type = 1;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // optional int32 card_value = 2;
  inline bool has_card_value() const;
  inline void clear_card_value();
  static const int kCardValueFieldNumber = 2;
  inline ::google::protobuf::int32 card_value() const;
  inline void set_card_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiNotify.SinglePai)
 private:
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_card_value();
  inline void clear_has_card_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int card_type_;
  ::google::protobuf::int32 card_value_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiNotify_SinglePai* default_instance_;
};
// -------------------------------------------------------------------

class PaiNotify : public ::google::protobuf::Message {
 public:
  PaiNotify();
  virtual ~PaiNotify();

  PaiNotify(const PaiNotify& from);

  inline PaiNotify& operator=(const PaiNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiNotify& default_instance();

  void Swap(PaiNotify* other);

  // implements Message ----------------------------------------------

  PaiNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiNotify& from);
  void MergeFrom(const PaiNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PaiNotify_MutiPai MutiPai;
  typedef PaiNotify_SinglePai SinglePai;

  typedef PaiNotify_CARDS_DATA_TYPE CARDS_DATA_TYPE;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_START = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_START;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_FAPAI = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_FAPAI;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_SYNC = PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_SYNC;
  static inline bool CARDS_DATA_TYPE_IsValid(int value) {
    return PaiNotify_CARDS_DATA_TYPE_IsValid(value);
  }
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_MIN =
    PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MIN;
  static const CARDS_DATA_TYPE CARDS_DATA_TYPE_MAX =
    PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_MAX;
  static const int CARDS_DATA_TYPE_ARRAYSIZE =
    PaiNotify_CARDS_DATA_TYPE_CARDS_DATA_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CARDS_DATA_TYPE_descriptor() {
    return PaiNotify_CARDS_DATA_TYPE_descriptor();
  }
  static inline const ::std::string& CARDS_DATA_TYPE_Name(CARDS_DATA_TYPE value) {
    return PaiNotify_CARDS_DATA_TYPE_Name(value);
  }
  static inline bool CARDS_DATA_TYPE_Parse(const ::std::string& name,
      CARDS_DATA_TYPE* value) {
    return PaiNotify_CARDS_DATA_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_NOTIFY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.PaiNotify.CARDS_DATA_TYPE data_type = 2;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  inline ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE data_type() const;
  inline void set_data_type(::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE value);

  // repeated .Adoter.Asset.PaiNotify.MutiPai pais = 3;
  inline int pais_size() const;
  inline void clear_pais();
  static const int kPaisFieldNumber = 3;
  inline const ::Adoter::Asset::PaiNotify_MutiPai& pais(int index) const;
  inline ::Adoter::Asset::PaiNotify_MutiPai* mutable_pais(int index);
  inline ::Adoter::Asset::PaiNotify_MutiPai* add_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >&
      pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >*
      mutable_pais();

  // optional .Adoter.Asset.PaiNotify.SinglePai pai = 4;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 4;
  inline const ::Adoter::Asset::PaiNotify_SinglePai& pai() const;
  inline ::Adoter::Asset::PaiNotify_SinglePai* mutable_pai();
  inline ::Adoter::Asset::PaiNotify_SinglePai* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiNotify_SinglePai* pai);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiNotify)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_data_type();
  inline void clear_has_data_type();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int data_type_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai > pais_;
  ::Adoter::Asset::PaiNotify_SinglePai* pai_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiNotify* default_instance_;
};
// -------------------------------------------------------------------

class CommonProperty : public ::google::protobuf::Message {
 public:
  CommonProperty();
  virtual ~CommonProperty();

  CommonProperty(const CommonProperty& from);

  inline CommonProperty& operator=(const CommonProperty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonProperty& default_instance();

  void Swap(CommonProperty* other);

  // implements Message ----------------------------------------------

  CommonProperty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonProperty& from);
  void MergeFrom(const CommonProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommonProperty_SYNC_REASON_TYPE SYNC_REASON_TYPE;
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_SELF = CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_SELF;
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_ENTER_ROOM = CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ENTER_ROOM;
  static inline bool SYNC_REASON_TYPE_IsValid(int value) {
    return CommonProperty_SYNC_REASON_TYPE_IsValid(value);
  }
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_MIN =
    CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MIN;
  static const SYNC_REASON_TYPE SYNC_REASON_TYPE_MAX =
    CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_MAX;
  static const int SYNC_REASON_TYPE_ARRAYSIZE =
    CommonProperty_SYNC_REASON_TYPE_SYNC_REASON_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SYNC_REASON_TYPE_descriptor() {
    return CommonProperty_SYNC_REASON_TYPE_descriptor();
  }
  static inline const ::std::string& SYNC_REASON_TYPE_Name(SYNC_REASON_TYPE value) {
    return CommonProperty_SYNC_REASON_TYPE_Name(value);
  }
  static inline bool SYNC_REASON_TYPE_Parse(const ::std::string& name,
      SYNC_REASON_TYPE* value) {
    return CommonProperty_SYNC_REASON_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_COMMON_PROPERTY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.CommonProperty.SYNC_REASON_TYPE reason_type = 2;
  inline bool has_reason_type() const;
  inline void clear_reason_type();
  static const int kReasonTypeFieldNumber = 2;
  inline ::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE reason_type() const;
  inline void set_reason_type(::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE value);

  // optional int64 player_id = 3;
  inline bool has_player_id() const;
  inline void clear_player_id();
  static const int kPlayerIdFieldNumber = 3;
  inline ::google::protobuf::int64 player_id() const;
  inline void set_player_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.CommonProp common_prop = 4;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 4;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonProperty)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_reason_type();
  inline void clear_has_reason_type();
  inline void set_has_player_id();
  inline void clear_has_player_id();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_t_;
  int reason_type_;
  ::google::protobuf::int64 player_id_;
  ::Adoter::Asset::CommonProp* common_prop_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static CommonProperty* default_instance_;
};
// -------------------------------------------------------------------

class PaiOperationAlert : public ::google::protobuf::Message {
 public:
  PaiOperationAlert();
  virtual ~PaiOperationAlert();

  PaiOperationAlert(const PaiOperationAlert& from);

  inline PaiOperationAlert& operator=(const PaiOperationAlert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PaiOperationAlert& default_instance();

  void Swap(PaiOperationAlert* other);

  // implements Message ----------------------------------------------

  PaiOperationAlert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PaiOperationAlert& from);
  void MergeFrom(const PaiOperationAlert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_OPERATION_ALERT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.PAI_CHECK_RETURN check_return = 2;
  inline int check_return_size() const;
  inline void clear_check_return();
  static const int kCheckReturnFieldNumber = 2;
  inline ::Adoter::Asset::PAI_CHECK_RETURN check_return(int index) const;
  inline void set_check_return(int index, ::Adoter::Asset::PAI_CHECK_RETURN value);
  inline void add_check_return(::Adoter::Asset::PAI_CHECK_RETURN value);
  inline const ::google::protobuf::RepeatedField<int>& check_return() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_check_return();

  // optional .Adoter.Asset.PaiElement pai = 3;
  inline bool has_pai() const;
  inline void clear_pai();
  static const int kPaiFieldNumber = 3;
  inline const ::Adoter::Asset::PaiElement& pai() const;
  inline ::Adoter::Asset::PaiElement* mutable_pai();
  inline ::Adoter::Asset::PaiElement* release_pai();
  inline void set_allocated_pai(::Adoter::Asset::PaiElement* pai);

  // repeated .Adoter.Asset.PaiElement pais = 4;
  inline int pais_size() const;
  inline void clear_pais();
  static const int kPaisFieldNumber = 4;
  inline const ::Adoter::Asset::PaiElement& pais(int index) const;
  inline ::Adoter::Asset::PaiElement* mutable_pais(int index);
  inline ::Adoter::Asset::PaiElement* add_pais();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
      pais() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
      mutable_pais();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.PaiOperationAlert)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_pai();
  inline void clear_has_pai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> check_return_;
  ::Adoter::Asset::PaiElement* pai_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement > pais_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static PaiOperationAlert* default_instance_;
};
// -------------------------------------------------------------------

class SyncCommonLimit : public ::google::protobuf::Message {
 public:
  SyncCommonLimit();
  virtual ~SyncCommonLimit();

  SyncCommonLimit(const SyncCommonLimit& from);

  inline SyncCommonLimit& operator=(const SyncCommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncCommonLimit& default_instance();

  void Swap(SyncCommonLimit* other);

  // implements Message ----------------------------------------------

  SyncCommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncCommonLimit& from);
  void MergeFrom(const SyncCommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_LIMIT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional .Adoter.Asset.PlayerCommonLimit common_limit = 2;
  inline bool has_common_limit() const;
  inline void clear_common_limit();
  static const int kCommonLimitFieldNumber = 2;
  inline const ::Adoter::Asset::PlayerCommonLimit& common_limit() const;
  inline ::Adoter::Asset::PlayerCommonLimit* mutable_common_limit();
  inline ::Adoter::Asset::PlayerCommonLimit* release_common_limit();
  inline void set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncCommonLimit)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_limit();
  inline void clear_has_common_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::PlayerCommonLimit* common_limit_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncCommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class SyncCommonReward : public ::google::protobuf::Message {
 public:
  SyncCommonReward();
  virtual ~SyncCommonReward();

  SyncCommonReward(const SyncCommonReward& from);

  inline SyncCommonReward& operator=(const SyncCommonReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncCommonReward& default_instance();

  void Swap(SyncCommonReward* other);

  // implements Message ----------------------------------------------

  SyncCommonReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncCommonReward& from);
  void MergeFrom(const SyncCommonReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_REWARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // optional int64 common_reward_id = 2;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 2;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.SyncCommonReward)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_reward_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static SyncCommonReward* default_instance_;
};
// -------------------------------------------------------------------

class RoomInformation_Player : public ::google::protobuf::Message {
 public:
  RoomInformation_Player();
  virtual ~RoomInformation_Player();

  RoomInformation_Player(const RoomInformation_Player& from);

  inline RoomInformation_Player& operator=(const RoomInformation_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInformation_Player& default_instance();

  void Swap(RoomInformation_Player* other);

  // implements Message ----------------------------------------------

  RoomInformation_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInformation_Player& from);
  void MergeFrom(const RoomInformation_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.POSITION_TYPE position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::Adoter::Asset::POSITION_TYPE position() const;
  inline void set_position(::Adoter::Asset::POSITION_TYPE value);

  // optional .Adoter.Asset.CommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::CommonProp& common_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_common_prop();
  inline ::Adoter::Asset::CommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomInformation.Player)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::CommonProp* common_prop_;
  int position_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomInformation_Player* default_instance_;
};
// -------------------------------------------------------------------

class RoomInformation : public ::google::protobuf::Message {
 public:
  RoomInformation();
  virtual ~RoomInformation();

  RoomInformation(const RoomInformation& from);

  inline RoomInformation& operator=(const RoomInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInformation& default_instance();

  void Swap(RoomInformation* other);

  // implements Message ----------------------------------------------

  RoomInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInformation& from);
  void MergeFrom(const RoomInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomInformation_Player Player;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_INFO];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::META_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::META_TYPE value);

  // repeated .Adoter.Asset.RoomInformation.Player player_list = 2;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 2;
  inline const ::Adoter::Asset::RoomInformation_Player& player_list(int index) const;
  inline ::Adoter::Asset::RoomInformation_Player* mutable_player_list(int index);
  inline ::Adoter::Asset::RoomInformation_Player* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomInformation)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player > player_list_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fProtocol_2eproto();
  friend void protobuf_AssignDesc_P_5fProtocol_2eproto();
  friend void protobuf_ShutdownFile_P_5fProtocol_2eproto();

  void InitAsDefaultInstance();
  static RoomInformation* default_instance_;
};
// ===================================================================


// ===================================================================

// Account

// optional bytes username = 1;
inline bool Account::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Account::username() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Account.username)
  return *username_;
}
inline void Account::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Account.username)
}
inline void Account::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Account.username)
}
inline void Account::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Account.username)
}
inline ::std::string* Account::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Account.username)
  return username_;
}
inline ::std::string* Account::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Account.username)
}

// optional bytes password = 2;
inline bool Account::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Account::password() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Account.password)
  return *password_;
}
inline void Account::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Account.password)
}
inline void Account::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Account.password)
}
inline void Account::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Account.password)
}
inline ::std::string* Account::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Account.password)
  return password_;
}
inline ::std::string* Account::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Account.password)
}

// -------------------------------------------------------------------

// PaiElement

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool PaiElement::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiElement::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiElement::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiElement::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE PaiElement::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void PaiElement::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.card_type)
}

// optional int32 card_value = 2;
inline bool PaiElement::has_card_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiElement::set_has_card_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiElement::clear_has_card_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiElement::clear_card_value() {
  card_value_ = 0;
  clear_has_card_value();
}
inline ::google::protobuf::int32 PaiElement::card_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.card_value)
  return card_value_;
}
inline void PaiElement::set_card_value(::google::protobuf::int32 value) {
  set_has_card_value();
  card_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.card_value)
}

// optional int32 card_index = 3;
inline bool PaiElement::has_card_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiElement::set_has_card_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiElement::clear_has_card_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiElement::clear_card_index() {
  card_index_ = 0;
  clear_has_card_index();
}
inline ::google::protobuf::int32 PaiElement::card_index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiElement.card_index)
  return card_index_;
}
inline void PaiElement::set_card_index(::google::protobuf::int32 value) {
  set_has_card_index();
  card_index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiElement.card_index)
}

// -------------------------------------------------------------------

// User

// optional .Adoter.Asset.Account account = 1;
inline bool User::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_account() {
  if (account_ != NULL) account_->::Adoter::Asset::Account::Clear();
  clear_has_account();
}
inline const ::Adoter::Asset::Account& User::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Adoter::Asset::Account* User::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::Adoter::Asset::Account;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.User.account)
  return account_;
}
inline ::Adoter::Asset::Account* User::release_account() {
  clear_has_account();
  ::Adoter::Asset::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void User::set_allocated_account(::Adoter::Asset::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.User.account)
}

// repeated int64 player_list = 2;
inline int User::player_list_size() const {
  return player_list_.size();
}
inline void User::clear_player_list() {
  player_list_.Clear();
}
inline ::google::protobuf::int64 User::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.User.player_list)
  return player_list_.Get(index);
}
inline void User::set_player_list(int index, ::google::protobuf::int64 value) {
  player_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.User.player_list)
}
inline void User::add_player_list(::google::protobuf::int64 value) {
  player_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.User.player_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
User::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.User.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
User::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.User.player_list)
  return &player_list_;
}

// -------------------------------------------------------------------

// PlayerProp

// optional bool online = 1;
inline bool PlayerProp::has_online() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerProp::set_has_online() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerProp::clear_has_online() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerProp::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool PlayerProp::online() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.online)
  return online_;
}
inline void PlayerProp::set_online(bool value) {
  set_has_online();
  online_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.online)
}

// optional .Adoter.Asset.POSITION_TYPE position = 2;
inline bool PlayerProp::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerProp::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerProp::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerProp::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE PlayerProp::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void PlayerProp::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.position)
}

// optional int64 room_id = 3;
inline bool PlayerProp::has_room_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerProp::set_has_room_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerProp::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerProp::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 PlayerProp::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.room_id)
  return room_id_;
}
inline void PlayerProp::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.room_id)
}

// optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 4;
inline bool PlayerProp::has_load_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerProp::set_has_load_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerProp::clear_has_load_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerProp::clear_load_type() {
  load_type_ = 1;
  clear_has_load_type();
}
inline ::Adoter::Asset::LOAD_SCENE_TYPE PlayerProp::load_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.load_type)
  return static_cast< ::Adoter::Asset::LOAD_SCENE_TYPE >(load_type_);
}
inline void PlayerProp::set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value) {
  assert(::Adoter::Asset::LOAD_SCENE_TYPE_IsValid(value));
  set_has_load_type();
  load_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.load_type)
}

// optional .Adoter.Asset.GAME_OPER_TYPE game_oper_state = 5;
inline bool PlayerProp::has_game_oper_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerProp::set_has_game_oper_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerProp::clear_has_game_oper_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerProp::clear_game_oper_state() {
  game_oper_state_ = 1;
  clear_has_game_oper_state();
}
inline ::Adoter::Asset::GAME_OPER_TYPE PlayerProp::game_oper_state() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.game_oper_state)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(game_oper_state_);
}
inline void PlayerProp::set_game_oper_state(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_game_oper_state();
  game_oper_state_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.game_oper_state)
}

// optional bool check_feng_gang = 6;
inline bool PlayerProp::has_check_feng_gang() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerProp::set_has_check_feng_gang() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerProp::clear_has_check_feng_gang() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerProp::clear_check_feng_gang() {
  check_feng_gang_ = false;
  clear_has_check_feng_gang();
}
inline bool PlayerProp::check_feng_gang() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.check_feng_gang)
  return check_feng_gang_;
}
inline void PlayerProp::set_check_feng_gang(bool value) {
  set_has_check_feng_gang();
  check_feng_gang_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.check_feng_gang)
}

// optional bool check_jian_gang = 7;
inline bool PlayerProp::has_check_jian_gang() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerProp::set_has_check_jian_gang() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerProp::clear_has_check_jian_gang() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerProp::clear_check_jian_gang() {
  check_jian_gang_ = false;
  clear_has_check_jian_gang();
}
inline bool PlayerProp::check_jian_gang() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.check_jian_gang)
  return check_jian_gang_;
}
inline void PlayerProp::set_check_jian_gang(bool value) {
  set_has_check_jian_gang();
  check_jian_gang_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.check_jian_gang)
}

// optional int32 pai_oper_count = 8;
inline bool PlayerProp::has_pai_oper_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerProp::set_has_pai_oper_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerProp::clear_has_pai_oper_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerProp::clear_pai_oper_count() {
  pai_oper_count_ = 0;
  clear_has_pai_oper_count();
}
inline ::google::protobuf::int32 PlayerProp::pai_oper_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerProp.pai_oper_count)
  return pai_oper_count_;
}
inline void PlayerProp::set_pai_oper_count(::google::protobuf::int32 value) {
  set_has_pai_oper_count();
  pai_oper_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerProp.pai_oper_count)
}

// -------------------------------------------------------------------

// CommonProp

// optional int64 player_id = 1;
inline bool CommonProp::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonProp::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonProp::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonProp::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 CommonProp::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.player_id)
  return player_id_;
}
inline void CommonProp::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.player_id)
}

// optional int32 local_server_id = 2;
inline bool CommonProp::has_local_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonProp::set_has_local_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonProp::clear_has_local_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonProp::clear_local_server_id() {
  local_server_id_ = 0;
  clear_has_local_server_id();
}
inline ::google::protobuf::int32 CommonProp::local_server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.local_server_id)
  return local_server_id_;
}
inline void CommonProp::set_local_server_id(::google::protobuf::int32 value) {
  set_has_local_server_id();
  local_server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.local_server_id)
}

// optional bytes name = 3;
inline bool CommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CommonProp::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.name)
  return *name_;
}
inline void CommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.name)
}
inline void CommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.CommonProp.name)
}
inline void CommonProp::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.CommonProp.name)
}
inline ::std::string* CommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonProp.name)
  return name_;
}
inline ::std::string* CommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonProp.name)
}

// optional int32 level = 4 [default = 1];
inline bool CommonProp::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonProp::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonProp::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonProp::clear_level() {
  level_ = 1;
  clear_has_level();
}
inline ::google::protobuf::int32 CommonProp::level() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.level)
  return level_;
}
inline void CommonProp::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.level)
}

// optional .Adoter.Asset.GENDER_TYPE gender = 5 [default = GENDER_TYPE_MAN];
inline bool CommonProp::has_gender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonProp::set_has_gender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonProp::clear_has_gender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonProp::clear_gender() {
  gender_ = 1;
  clear_has_gender();
}
inline ::Adoter::Asset::GENDER_TYPE CommonProp::gender() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.gender)
  return static_cast< ::Adoter::Asset::GENDER_TYPE >(gender_);
}
inline void CommonProp::set_gender(::Adoter::Asset::GENDER_TYPE value) {
  assert(::Adoter::Asset::GENDER_TYPE_IsValid(value));
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.gender)
}

// optional int64 diamond = 6;
inline bool CommonProp::has_diamond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonProp::set_has_diamond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonProp::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonProp::clear_diamond() {
  diamond_ = GOOGLE_LONGLONG(0);
  clear_has_diamond();
}
inline ::google::protobuf::int64 CommonProp::diamond() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.diamond)
  return diamond_;
}
inline void CommonProp::set_diamond(::google::protobuf::int64 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.diamond)
}

// optional int64 huanledou = 7;
inline bool CommonProp::has_huanledou() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonProp::set_has_huanledou() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonProp::clear_has_huanledou() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonProp::clear_huanledou() {
  huanledou_ = GOOGLE_LONGLONG(0);
  clear_has_huanledou();
}
inline ::google::protobuf::int64 CommonProp::huanledou() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.huanledou)
  return huanledou_;
}
inline void CommonProp::set_huanledou(::google::protobuf::int64 value) {
  set_has_huanledou();
  huanledou_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.huanledou)
}

// optional int64 total_rounds = 8;
inline bool CommonProp::has_total_rounds() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonProp::set_has_total_rounds() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonProp::clear_has_total_rounds() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonProp::clear_total_rounds() {
  total_rounds_ = GOOGLE_LONGLONG(0);
  clear_has_total_rounds();
}
inline ::google::protobuf::int64 CommonProp::total_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.total_rounds)
  return total_rounds_;
}
inline void CommonProp::set_total_rounds(::google::protobuf::int64 value) {
  set_has_total_rounds();
  total_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.total_rounds)
}

// optional int64 total_win_rounds = 9;
inline bool CommonProp::has_total_win_rounds() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonProp::set_has_total_win_rounds() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonProp::clear_has_total_win_rounds() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonProp::clear_total_win_rounds() {
  total_win_rounds_ = GOOGLE_LONGLONG(0);
  clear_has_total_win_rounds();
}
inline ::google::protobuf::int64 CommonProp::total_win_rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.total_win_rounds)
  return total_win_rounds_;
}
inline void CommonProp::set_total_win_rounds(::google::protobuf::int64 value) {
  set_has_total_win_rounds();
  total_win_rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.total_win_rounds)
}

// optional int64 streak_wins = 10;
inline bool CommonProp::has_streak_wins() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonProp::set_has_streak_wins() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonProp::clear_has_streak_wins() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonProp::clear_streak_wins() {
  streak_wins_ = GOOGLE_LONGLONG(0);
  clear_has_streak_wins();
}
inline ::google::protobuf::int64 CommonProp::streak_wins() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.streak_wins)
  return streak_wins_;
}
inline void CommonProp::set_streak_wins(::google::protobuf::int64 value) {
  set_has_streak_wins();
  streak_wins_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.streak_wins)
}

// -------------------------------------------------------------------

// PlayerCommonLimit_Element

// optional int64 common_limit_id = 1;
inline bool PlayerCommonLimit_Element::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCommonLimit_Element::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCommonLimit_Element::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCommonLimit_Element::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 PlayerCommonLimit_Element::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.Element.common_limit_id)
  return common_limit_id_;
}
inline void PlayerCommonLimit_Element::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCommonLimit.Element.common_limit_id)
}

// optional int32 time_stamp = 2;
inline bool PlayerCommonLimit_Element::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCommonLimit_Element::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCommonLimit_Element::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCommonLimit_Element::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline ::google::protobuf::int32 PlayerCommonLimit_Element::time_stamp() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.Element.time_stamp)
  return time_stamp_;
}
inline void PlayerCommonLimit_Element::set_time_stamp(::google::protobuf::int32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCommonLimit.Element.time_stamp)
}

// optional int32 count = 3;
inline bool PlayerCommonLimit_Element::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerCommonLimit_Element::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerCommonLimit_Element::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerCommonLimit_Element::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 PlayerCommonLimit_Element::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.Element.count)
  return count_;
}
inline void PlayerCommonLimit_Element::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCommonLimit.Element.count)
}

// -------------------------------------------------------------------

// PlayerCommonLimit

// repeated .Adoter.Asset.PlayerCommonLimit.Element elements = 1;
inline int PlayerCommonLimit::elements_size() const {
  return elements_.size();
}
inline void PlayerCommonLimit::clear_elements() {
  elements_.Clear();
}
inline const ::Adoter::Asset::PlayerCommonLimit_Element& PlayerCommonLimit::elements(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_.Get(index);
}
inline ::Adoter::Asset::PlayerCommonLimit_Element* PlayerCommonLimit::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_.Mutable(index);
}
inline ::Adoter::Asset::PlayerCommonLimit_Element* PlayerCommonLimit::add_elements() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >&
PlayerCommonLimit::elements() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayerCommonLimit.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCommonLimit_Element >*
PlayerCommonLimit::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayerCommonLimit.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// PlayerCoolDown_Element

// optional int64 cool_down_id = 1;
inline bool PlayerCoolDown_Element::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerCoolDown_Element::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerCoolDown_Element::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerCoolDown_Element::clear_cool_down_id() {
  cool_down_id_ = GOOGLE_LONGLONG(0);
  clear_has_cool_down_id();
}
inline ::google::protobuf::int64 PlayerCoolDown_Element::cool_down_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCoolDown.Element.cool_down_id)
  return cool_down_id_;
}
inline void PlayerCoolDown_Element::set_cool_down_id(::google::protobuf::int64 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCoolDown.Element.cool_down_id)
}

// optional int32 time_stamp = 2;
inline bool PlayerCoolDown_Element::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerCoolDown_Element::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerCoolDown_Element::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerCoolDown_Element::clear_time_stamp() {
  time_stamp_ = 0;
  clear_has_time_stamp();
}
inline ::google::protobuf::int32 PlayerCoolDown_Element::time_stamp() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCoolDown.Element.time_stamp)
  return time_stamp_;
}
inline void PlayerCoolDown_Element::set_time_stamp(::google::protobuf::int32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerCoolDown.Element.time_stamp)
}

// -------------------------------------------------------------------

// PlayerCoolDown

// repeated .Adoter.Asset.PlayerCoolDown.Element elements = 1;
inline int PlayerCoolDown::elements_size() const {
  return elements_.size();
}
inline void PlayerCoolDown::clear_elements() {
  elements_.Clear();
}
inline const ::Adoter::Asset::PlayerCoolDown_Element& PlayerCoolDown::elements(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerCoolDown.elements)
  return elements_.Get(index);
}
inline ::Adoter::Asset::PlayerCoolDown_Element* PlayerCoolDown::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerCoolDown.elements)
  return elements_.Mutable(index);
}
inline ::Adoter::Asset::PlayerCoolDown_Element* PlayerCoolDown::add_elements() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayerCoolDown.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >&
PlayerCoolDown::elements() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayerCoolDown.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PlayerCoolDown_Element >*
PlayerCoolDown::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayerCoolDown.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// MailAttachment

// optional int64 common_reward_id = 1;
inline bool MailAttachment::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailAttachment::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailAttachment::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailAttachment::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 MailAttachment::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MailAttachment.common_reward_id)
  return common_reward_id_;
}
inline void MailAttachment::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MailAttachment.common_reward_id)
}

// -------------------------------------------------------------------

// Mail

// optional bytes title = 1;
inline bool Mail::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mail::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mail::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mail::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Mail::title() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.title)
  return *title_;
}
inline void Mail::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.title)
}
inline void Mail::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Mail.title)
}
inline void Mail::set_title(const void* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Mail.title)
}
inline ::std::string* Mail::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.title)
  return title_;
}
inline ::std::string* Mail::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mail::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.title)
}

// optional bytes send_player = 2 [default = "\347\263\273\347\273\237\351\202\256\344\273\266"];
inline bool Mail::has_send_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mail::set_has_send_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mail::clear_has_send_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mail::clear_send_player() {
  if (send_player_ != _default_send_player_) {
    send_player_->assign(*_default_send_player_);
  }
  clear_has_send_player();
}
inline const ::std::string& Mail::send_player() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.send_player)
  return *send_player_;
}
inline void Mail::set_send_player(const ::std::string& value) {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string;
  }
  send_player_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.send_player)
}
inline void Mail::set_send_player(const char* value) {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string;
  }
  send_player_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Mail.send_player)
}
inline void Mail::set_send_player(const void* value, size_t size) {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string;
  }
  send_player_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Mail.send_player)
}
inline ::std::string* Mail::mutable_send_player() {
  set_has_send_player();
  if (send_player_ == _default_send_player_) {
    send_player_ = new ::std::string(*_default_send_player_);
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.send_player)
  return send_player_;
}
inline ::std::string* Mail::release_send_player() {
  clear_has_send_player();
  if (send_player_ == _default_send_player_) {
    return NULL;
  } else {
    ::std::string* temp = send_player_;
    send_player_ = const_cast< ::std::string*>(_default_send_player_);
    return temp;
  }
}
inline void Mail::set_allocated_send_player(::std::string* send_player) {
  if (send_player_ != _default_send_player_) {
    delete send_player_;
  }
  if (send_player) {
    set_has_send_player();
    send_player_ = send_player;
  } else {
    clear_has_send_player();
    send_player_ = const_cast< ::std::string*>(_default_send_player_);
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.send_player)
}

// optional bytes content = 3;
inline bool Mail::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mail::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mail::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mail::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Mail::content() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.content)
  return *content_;
}
inline void Mail::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.content)
}
inline void Mail::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Mail.content)
}
inline void Mail::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Mail.content)
}
inline ::std::string* Mail::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.content)
  return content_;
}
inline ::std::string* Mail::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mail::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.content)
}

// optional int32 send_time = 4;
inline bool Mail::has_send_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mail::set_has_send_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mail::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mail::clear_send_time() {
  send_time_ = 0;
  clear_has_send_time();
}
inline ::google::protobuf::int32 Mail::send_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.send_time)
  return send_time_;
}
inline void Mail::set_send_time(::google::protobuf::int32 value) {
  set_has_send_time();
  send_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.send_time)
}

// optional bool readed = 5;
inline bool Mail::has_readed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mail::set_has_readed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mail::clear_has_readed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mail::clear_readed() {
  readed_ = false;
  clear_has_readed();
}
inline bool Mail::readed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.readed)
  return readed_;
}
inline void Mail::set_readed(bool value) {
  set_has_readed();
  readed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mail.readed)
}

// optional .Adoter.Asset.MailAttachment attachment = 6;
inline bool Mail::has_attachment() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mail::set_has_attachment() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Mail::clear_has_attachment() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Mail::clear_attachment() {
  if (attachment_ != NULL) attachment_->::Adoter::Asset::MailAttachment::Clear();
  clear_has_attachment();
}
inline const ::Adoter::Asset::MailAttachment& Mail::attachment() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mail.attachment)
  return attachment_ != NULL ? *attachment_ : *default_instance_->attachment_;
}
inline ::Adoter::Asset::MailAttachment* Mail::mutable_attachment() {
  set_has_attachment();
  if (attachment_ == NULL) attachment_ = new ::Adoter::Asset::MailAttachment;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mail.attachment)
  return attachment_;
}
inline ::Adoter::Asset::MailAttachment* Mail::release_attachment() {
  clear_has_attachment();
  ::Adoter::Asset::MailAttachment* temp = attachment_;
  attachment_ = NULL;
  return temp;
}
inline void Mail::set_allocated_attachment(::Adoter::Asset::MailAttachment* attachment) {
  delete attachment_;
  attachment_ = attachment;
  if (attachment) {
    set_has_attachment();
  } else {
    clear_has_attachment();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mail.attachment)
}

// -------------------------------------------------------------------

// Player

// optional .Adoter.Asset.CommonProp common_prop = 1;
inline bool Player::has_common_prop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_common_prop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& Player::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* Player::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* Player::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Player::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.common_prop)
}

// optional int64 server_id = 2;
inline bool Player::has_server_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_server_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_server_id() {
  server_id_ = GOOGLE_LONGLONG(0);
  clear_has_server_id();
}
inline ::google::protobuf::int64 Player::server_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.server_id)
  return server_id_;
}
inline void Player::set_server_id(::google::protobuf::int64 value) {
  set_has_server_id();
  server_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.server_id)
}

// optional .Adoter.Asset.Inventory inventory = 3;
inline bool Player::has_inventory() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player::set_has_inventory() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player::clear_inventory() {
  if (inventory_ != NULL) inventory_->::Adoter::Asset::Inventory::Clear();
  clear_has_inventory();
}
inline const ::Adoter::Asset::Inventory& Player::inventory() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.inventory)
  return inventory_ != NULL ? *inventory_ : *default_instance_->inventory_;
}
inline ::Adoter::Asset::Inventory* Player::mutable_inventory() {
  set_has_inventory();
  if (inventory_ == NULL) inventory_ = new ::Adoter::Asset::Inventory;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.inventory)
  return inventory_;
}
inline ::Adoter::Asset::Inventory* Player::release_inventory() {
  clear_has_inventory();
  ::Adoter::Asset::Inventory* temp = inventory_;
  inventory_ = NULL;
  return temp;
}
inline void Player::set_allocated_inventory(::Adoter::Asset::Inventory* inventory) {
  delete inventory_;
  inventory_ = inventory;
  if (inventory) {
    set_has_inventory();
  } else {
    clear_has_inventory();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.inventory)
}

// optional .Adoter.Asset.PlayerCommonLimit common_limit = 4;
inline bool Player::has_common_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::set_has_common_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player::clear_has_common_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player::clear_common_limit() {
  if (common_limit_ != NULL) common_limit_->::Adoter::Asset::PlayerCommonLimit::Clear();
  clear_has_common_limit();
}
inline const ::Adoter::Asset::PlayerCommonLimit& Player::common_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.common_limit)
  return common_limit_ != NULL ? *common_limit_ : *default_instance_->common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* Player::mutable_common_limit() {
  set_has_common_limit();
  if (common_limit_ == NULL) common_limit_ = new ::Adoter::Asset::PlayerCommonLimit;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.common_limit)
  return common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* Player::release_common_limit() {
  clear_has_common_limit();
  ::Adoter::Asset::PlayerCommonLimit* temp = common_limit_;
  common_limit_ = NULL;
  return temp;
}
inline void Player::set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit) {
  delete common_limit_;
  common_limit_ = common_limit;
  if (common_limit) {
    set_has_common_limit();
  } else {
    clear_has_common_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.common_limit)
}

// optional .Adoter.Asset.PlayerCoolDown cool_down = 5;
inline bool Player::has_cool_down() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player::set_has_cool_down() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player::clear_has_cool_down() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player::clear_cool_down() {
  if (cool_down_ != NULL) cool_down_->::Adoter::Asset::PlayerCoolDown::Clear();
  clear_has_cool_down();
}
inline const ::Adoter::Asset::PlayerCoolDown& Player::cool_down() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.cool_down)
  return cool_down_ != NULL ? *cool_down_ : *default_instance_->cool_down_;
}
inline ::Adoter::Asset::PlayerCoolDown* Player::mutable_cool_down() {
  set_has_cool_down();
  if (cool_down_ == NULL) cool_down_ = new ::Adoter::Asset::PlayerCoolDown;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.cool_down)
  return cool_down_;
}
inline ::Adoter::Asset::PlayerCoolDown* Player::release_cool_down() {
  clear_has_cool_down();
  ::Adoter::Asset::PlayerCoolDown* temp = cool_down_;
  cool_down_ = NULL;
  return temp;
}
inline void Player::set_allocated_cool_down(::Adoter::Asset::PlayerCoolDown* cool_down) {
  delete cool_down_;
  cool_down_ = cool_down;
  if (cool_down) {
    set_has_cool_down();
  } else {
    clear_has_cool_down();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.cool_down)
}

// optional int32 login_time = 6;
inline bool Player::has_login_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player::set_has_login_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player::clear_has_login_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player::clear_login_time() {
  login_time_ = 0;
  clear_has_login_time();
}
inline ::google::protobuf::int32 Player::login_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.login_time)
  return login_time_;
}
inline void Player::set_login_time(::google::protobuf::int32 value) {
  set_has_login_time();
  login_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.login_time)
}

// optional int32 logout_time = 7;
inline bool Player::has_logout_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player::set_has_logout_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player::clear_has_logout_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player::clear_logout_time() {
  logout_time_ = 0;
  clear_has_logout_time();
}
inline ::google::protobuf::int32 Player::logout_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.logout_time)
  return logout_time_;
}
inline void Player::set_logout_time(::google::protobuf::int32 value) {
  set_has_logout_time();
  logout_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.logout_time)
}

// repeated int32 sign_time = 8;
inline int Player::sign_time_size() const {
  return sign_time_.size();
}
inline void Player::clear_sign_time() {
  sign_time_.Clear();
}
inline ::google::protobuf::int32 Player::sign_time(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.sign_time)
  return sign_time_.Get(index);
}
inline void Player::set_sign_time(int index, ::google::protobuf::int32 value) {
  sign_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Player.sign_time)
}
inline void Player::add_sign_time(::google::protobuf::int32 value) {
  sign_time_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.sign_time)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Player::sign_time() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.sign_time)
  return sign_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Player::mutable_sign_time() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.sign_time)
  return &sign_time_;
}

// repeated .Adoter.Asset.Mail mail_list = 10;
inline int Player::mail_list_size() const {
  return mail_list_.size();
}
inline void Player::clear_mail_list() {
  mail_list_.Clear();
}
inline const ::Adoter::Asset::Mail& Player::mail_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.mail_list)
  return mail_list_.Get(index);
}
inline ::Adoter::Asset::Mail* Player::mutable_mail_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.mail_list)
  return mail_list_.Mutable(index);
}
inline ::Adoter::Asset::Mail* Player::add_mail_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Player.mail_list)
  return mail_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >&
Player::mail_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Player.mail_list)
  return mail_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Mail >*
Player::mutable_mail_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Player.mail_list)
  return &mail_list_;
}

// optional .Adoter.Asset.PlayerProp player_prop = 20;
inline bool Player::has_player_prop() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Player::set_has_player_prop() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Player::clear_has_player_prop() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Player::clear_player_prop() {
  if (player_prop_ != NULL) player_prop_->::Adoter::Asset::PlayerProp::Clear();
  clear_has_player_prop();
}
inline const ::Adoter::Asset::PlayerProp& Player::player_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Player.player_prop)
  return player_prop_ != NULL ? *player_prop_ : *default_instance_->player_prop_;
}
inline ::Adoter::Asset::PlayerProp* Player::mutable_player_prop() {
  set_has_player_prop();
  if (player_prop_ == NULL) player_prop_ = new ::Adoter::Asset::PlayerProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Player.player_prop)
  return player_prop_;
}
inline ::Adoter::Asset::PlayerProp* Player::release_player_prop() {
  clear_has_player_prop();
  ::Adoter::Asset::PlayerProp* temp = player_prop_;
  player_prop_ = NULL;
  return temp;
}
inline void Player::set_allocated_player_prop(::Adoter::Asset::PlayerProp* player_prop) {
  delete player_prop_;
  player_prop_ = player_prop;
  if (player_prop) {
    set_has_player_prop();
  } else {
    clear_has_player_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Player.player_prop)
}

// -------------------------------------------------------------------

// Inventory_Element

// optional .Adoter.Asset.INVENTORY_TYPE inventory_type = 1;
inline bool Inventory_Element::has_inventory_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Inventory_Element::set_has_inventory_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Inventory_Element::clear_has_inventory_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Inventory_Element::clear_inventory_type() {
  inventory_type_ = 1;
  clear_has_inventory_type();
}
inline ::Adoter::Asset::INVENTORY_TYPE Inventory_Element::inventory_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Inventory.Element.inventory_type)
  return static_cast< ::Adoter::Asset::INVENTORY_TYPE >(inventory_type_);
}
inline void Inventory_Element::set_inventory_type(::Adoter::Asset::INVENTORY_TYPE value) {
  assert(::Adoter::Asset::INVENTORY_TYPE_IsValid(value));
  set_has_inventory_type();
  inventory_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Inventory.Element.inventory_type)
}

// repeated .Adoter.Asset.Item_Item items = 2;
inline int Inventory_Element::items_size() const {
  return items_.size();
}
inline void Inventory_Element::clear_items() {
  items_.Clear();
}
inline const ::Adoter::Asset::Item_Item& Inventory_Element::items(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Inventory.Element.items)
  return items_.Get(index);
}
inline ::Adoter::Asset::Item_Item* Inventory_Element::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Inventory.Element.items)
  return items_.Mutable(index);
}
inline ::Adoter::Asset::Item_Item* Inventory_Element::add_items() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Inventory.Element.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >&
Inventory_Element::items() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Inventory.Element.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Item_Item >*
Inventory_Element::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Inventory.Element.items)
  return &items_;
}

// -------------------------------------------------------------------

// Inventory

// repeated .Adoter.Asset.Inventory.Element inventory = 1;
inline int Inventory::inventory_size() const {
  return inventory_.size();
}
inline void Inventory::clear_inventory() {
  inventory_.Clear();
}
inline const ::Adoter::Asset::Inventory_Element& Inventory::inventory(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Inventory.inventory)
  return inventory_.Get(index);
}
inline ::Adoter::Asset::Inventory_Element* Inventory::mutable_inventory(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Inventory.inventory)
  return inventory_.Mutable(index);
}
inline ::Adoter::Asset::Inventory_Element* Inventory::add_inventory() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.Inventory.inventory)
  return inventory_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >&
Inventory::inventory() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Inventory.inventory)
  return inventory_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::Inventory_Element >*
Inventory::mutable_inventory() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Inventory.inventory)
  return &inventory_;
}

// -------------------------------------------------------------------

// ItemEquipment

// optional int32 star = 1;
inline bool ItemEquipment::has_star() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemEquipment::set_has_star() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemEquipment::clear_has_star() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemEquipment::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 ItemEquipment::star() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.ItemEquipment.star)
  return star_;
}
inline void ItemEquipment::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.ItemEquipment.star)
}

// -------------------------------------------------------------------

// Meta

// optional .Adoter.Asset.META_TYPE type_t = 1;
inline bool Meta::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Meta::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Meta::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Meta::clear_type_t() {
  type_t_ = 1;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Meta::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Meta.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Meta::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Meta.type_t)
}

// optional bytes stuff = 2;
inline bool Meta::has_stuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Meta::set_has_stuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Meta::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Meta::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& Meta::stuff() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Meta.stuff)
  return *stuff_;
}
inline void Meta::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Meta.stuff)
}
inline void Meta::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Meta.stuff)
}
inline void Meta::set_stuff(const void* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Meta.stuff)
}
inline ::std::string* Meta::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Meta.stuff)
  return stuff_;
}
inline ::std::string* Meta::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Meta::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Meta.stuff)
}

// -------------------------------------------------------------------

// CreatePlayer

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_PLAYER];
inline bool CreatePlayer::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePlayer::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePlayer::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePlayer::clear_type_t() {
  type_t_ = 2;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE CreatePlayer::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreatePlayer.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void CreatePlayer::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CreatePlayer.type_t)
}

// optional int64 player_id = 2;
inline bool CreatePlayer::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePlayer::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePlayer::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePlayer::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 CreatePlayer::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreatePlayer.player_id)
  return player_id_;
}
inline void CreatePlayer::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CreatePlayer.player_id)
}

// -------------------------------------------------------------------

// Login

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGIN];
inline bool Login::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_type_t() {
  type_t_ = 52;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Login::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Login.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Login::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Login.type_t)
}

// optional .Adoter.Asset.Account account = 2;
inline bool Login::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_account() {
  if (account_ != NULL) account_->::Adoter::Asset::Account::Clear();
  clear_has_account();
}
inline const ::Adoter::Asset::Account& Login::account() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Login.account)
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Adoter::Asset::Account* Login::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::Adoter::Asset::Account;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Login.account)
  return account_;
}
inline ::Adoter::Asset::Account* Login::release_account() {
  clear_has_account();
  ::Adoter::Asset::Account* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Login::set_allocated_account(::Adoter::Asset::Account* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Login.account)
}

// -------------------------------------------------------------------

// Logout

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOGOUT];
inline bool Logout::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logout::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logout::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logout::clear_type_t() {
  type_t_ = 53;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Logout::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Logout.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Logout::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Logout.type_t)
}

// -------------------------------------------------------------------

// EnterGame

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_ENTER_GAME];
inline bool EnterGame::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGame::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGame::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGame::clear_type_t() {
  type_t_ = 55;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE EnterGame::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterGame.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void EnterGame::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterGame.type_t)
}

// optional int64 player_id = 2;
inline bool EnterGame::has_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGame::set_has_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGame::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGame::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 EnterGame::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterGame.player_id)
  return player_id_;
}
inline void EnterGame::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterGame.player_id)
}

// -------------------------------------------------------------------

// Room

// optional int64 room_id = 1;
inline bool Room::has_room_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Room::set_has_room_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Room::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Room::clear_room_id() {
  room_id_ = GOOGLE_LONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::int64 Room::room_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.room_id)
  return room_id_;
}
inline void Room::set_room_id(::google::protobuf::int64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.room_id)
}

// optional .Adoter.Asset.ROOM_TYPE room_type = 2;
inline bool Room::has_room_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Room::set_has_room_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Room::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Room::clear_room_type() {
  room_type_ = 1;
  clear_has_room_type();
}
inline ::Adoter::Asset::ROOM_TYPE Room::room_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.room_type)
  return static_cast< ::Adoter::Asset::ROOM_TYPE >(room_type_);
}
inline void Room::set_room_type(::Adoter::Asset::ROOM_TYPE value) {
  assert(::Adoter::Asset::ROOM_TYPE_IsValid(value));
  set_has_room_type();
  room_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.room_type)
}

// optional bytes enter_password = 3;
inline bool Room::has_enter_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Room::set_has_enter_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Room::clear_has_enter_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Room::clear_enter_password() {
  if (enter_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_->clear();
  }
  clear_has_enter_password();
}
inline const ::std::string& Room::enter_password() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.enter_password)
  return *enter_password_;
}
inline void Room::set_enter_password(const ::std::string& value) {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  enter_password_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Room.enter_password)
}
inline void Room::set_enter_password(const char* value) {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  enter_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Room.enter_password)
}
inline void Room::set_enter_password(const void* value, size_t size) {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  enter_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Room.enter_password)
}
inline ::std::string* Room::mutable_enter_password() {
  set_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enter_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Room.enter_password)
  return enter_password_;
}
inline ::std::string* Room::release_enter_password() {
  clear_has_enter_password();
  if (enter_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enter_password_;
    enter_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Room::set_allocated_enter_password(::std::string* enter_password) {
  if (enter_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enter_password_;
  }
  if (enter_password) {
    set_has_enter_password();
    enter_password_ = enter_password;
  } else {
    clear_has_enter_password();
    enter_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Room.enter_password)
}

// optional .Adoter.Asset.RoomOptions options = 4;
inline bool Room::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Room::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Room::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Room::clear_options() {
  if (options_ != NULL) options_->::Adoter::Asset::RoomOptions::Clear();
  clear_has_options();
}
inline const ::Adoter::Asset::RoomOptions& Room::options() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Room.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::Adoter::Asset::RoomOptions* Room::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::Adoter::Asset::RoomOptions;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Room.options)
  return options_;
}
inline ::Adoter::Asset::RoomOptions* Room::release_options() {
  clear_has_options();
  ::Adoter::Asset::RoomOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void Room::set_allocated_options(::Adoter::Asset::RoomOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Room.options)
}

// -------------------------------------------------------------------

// RoomOptions

// optional .Adoter.Asset.ROOM_MODEL_TYPE model = 1;
inline bool RoomOptions::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomOptions::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomOptions::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomOptions::clear_model() {
  model_ = 1;
  clear_has_model();
}
inline ::Adoter::Asset::ROOM_MODEL_TYPE RoomOptions::model() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOptions.model)
  return static_cast< ::Adoter::Asset::ROOM_MODEL_TYPE >(model_);
}
inline void RoomOptions::set_model(::Adoter::Asset::ROOM_MODEL_TYPE value) {
  assert(::Adoter::Asset::ROOM_MODEL_TYPE_IsValid(value));
  set_has_model();
  model_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOptions.model)
}

// repeated .Adoter.Asset.ROOM_EXTEND_TYPE extend_type = 2;
inline int RoomOptions::extend_type_size() const {
  return extend_type_.size();
}
inline void RoomOptions::clear_extend_type() {
  extend_type_.Clear();
}
inline ::Adoter::Asset::ROOM_EXTEND_TYPE RoomOptions::extend_type(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOptions.extend_type)
  return static_cast< ::Adoter::Asset::ROOM_EXTEND_TYPE >(extend_type_.Get(index));
}
inline void RoomOptions::set_extend_type(int index, ::Adoter::Asset::ROOM_EXTEND_TYPE value) {
  assert(::Adoter::Asset::ROOM_EXTEND_TYPE_IsValid(value));
  extend_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOptions.extend_type)
}
inline void RoomOptions::add_extend_type(::Adoter::Asset::ROOM_EXTEND_TYPE value) {
  assert(::Adoter::Asset::ROOM_EXTEND_TYPE_IsValid(value));
  extend_type_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomOptions.extend_type)
}
inline const ::google::protobuf::RepeatedField<int>&
RoomOptions::extend_type() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomOptions.extend_type)
  return extend_type_;
}
inline ::google::protobuf::RepeatedField<int>*
RoomOptions::mutable_extend_type() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomOptions.extend_type)
  return &extend_type_;
}

// optional int32 top_mutiple = 3;
inline bool RoomOptions::has_top_mutiple() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomOptions::set_has_top_mutiple() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomOptions::clear_has_top_mutiple() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomOptions::clear_top_mutiple() {
  top_mutiple_ = 0;
  clear_has_top_mutiple();
}
inline ::google::protobuf::int32 RoomOptions::top_mutiple() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOptions.top_mutiple)
  return top_mutiple_;
}
inline void RoomOptions::set_top_mutiple(::google::protobuf::int32 value) {
  set_has_top_mutiple();
  top_mutiple_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOptions.top_mutiple)
}

// optional int32 open_rands = 4;
inline bool RoomOptions::has_open_rands() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomOptions::set_has_open_rands() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomOptions::clear_has_open_rands() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomOptions::clear_open_rands() {
  open_rands_ = 0;
  clear_has_open_rands();
}
inline ::google::protobuf::int32 RoomOptions::open_rands() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOptions.open_rands)
  return open_rands_;
}
inline void RoomOptions::set_open_rands(::google::protobuf::int32 value) {
  set_has_open_rands();
  open_rands_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOptions.open_rands)
}

// -------------------------------------------------------------------

// CreateRoom

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_CREATE_ROOM];
inline bool CreateRoom::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom::clear_type_t() {
  type_t_ = 3;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE CreateRoom::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreateRoom.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void CreateRoom::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CreateRoom.type_t)
}

// optional .Adoter.Asset.Room room = 2;
inline bool CreateRoom::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoom::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoom::clear_room() {
  if (room_ != NULL) room_->::Adoter::Asset::Room::Clear();
  clear_has_room();
}
inline const ::Adoter::Asset::Room& CreateRoom::room() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CreateRoom.room)
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::Adoter::Asset::Room* CreateRoom::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::Adoter::Asset::Room;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CreateRoom.room)
  return room_;
}
inline ::Adoter::Asset::Room* CreateRoom::release_room() {
  clear_has_room();
  ::Adoter::Asset::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline void CreateRoom::set_allocated_room(::Adoter::Asset::Room* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CreateRoom.room)
}

// -------------------------------------------------------------------

// EnterRoom

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_ENTER_ROOM];
inline bool EnterRoom::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoom::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoom::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoom::clear_type_t() {
  type_t_ = 8;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE EnterRoom::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void EnterRoom::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterRoom.type_t)
}

// optional .Adoter.Asset.Room room = 2;
inline bool EnterRoom::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoom::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoom::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoom::clear_room() {
  if (room_ != NULL) room_->::Adoter::Asset::Room::Clear();
  clear_has_room();
}
inline const ::Adoter::Asset::Room& EnterRoom::room() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.room)
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::Adoter::Asset::Room* EnterRoom::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::Adoter::Asset::Room;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.EnterRoom.room)
  return room_;
}
inline ::Adoter::Asset::Room* EnterRoom::release_room() {
  clear_has_room();
  ::Adoter::Asset::Room* temp = room_;
  room_ = NULL;
  return temp;
}
inline void EnterRoom::set_allocated_room(::Adoter::Asset::Room* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.EnterRoom.room)
}

// optional .Adoter.Asset.ERROR_CODE error_code = 3;
inline bool EnterRoom::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoom::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoom::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoom::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::ERROR_CODE EnterRoom::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.error_code)
  return static_cast< ::Adoter::Asset::ERROR_CODE >(error_code_);
}
inline void EnterRoom::set_error_code(::Adoter::Asset::ERROR_CODE value) {
  assert(::Adoter::Asset::ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterRoom.error_code)
}

// optional .Adoter.Asset.EnterRoom.ENTER_TYPE enter_type = 4;
inline bool EnterRoom::has_enter_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EnterRoom::set_has_enter_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EnterRoom::clear_has_enter_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EnterRoom::clear_enter_type() {
  enter_type_ = 1;
  clear_has_enter_type();
}
inline ::Adoter::Asset::EnterRoom_ENTER_TYPE EnterRoom::enter_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.EnterRoom.enter_type)
  return static_cast< ::Adoter::Asset::EnterRoom_ENTER_TYPE >(enter_type_);
}
inline void EnterRoom::set_enter_type(::Adoter::Asset::EnterRoom_ENTER_TYPE value) {
  assert(::Adoter::Asset::EnterRoom_ENTER_TYPE_IsValid(value));
  set_has_enter_type();
  enter_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.EnterRoom.enter_type)
}

// -------------------------------------------------------------------

// Sign

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_SIGN];
inline bool Sign::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sign::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sign::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sign::clear_type_t() {
  type_t_ = 9;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE Sign::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Sign.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void Sign::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Sign.type_t)
}

// optional bool success = 2;
inline bool Sign::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sign::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sign::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sign::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Sign::success() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Sign.success)
  return success_;
}
inline void Sign::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Sign.success)
}

// -------------------------------------------------------------------

// PlayerLuckyPlate

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_LUCKY_PLATE];
inline bool PlayerLuckyPlate::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerLuckyPlate::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerLuckyPlate::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerLuckyPlate::clear_type_t() {
  type_t_ = 10;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerLuckyPlate::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerLuckyPlate.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerLuckyPlate::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerLuckyPlate.type_t)
}

// optional int64 plate_id = 2;
inline bool PlayerLuckyPlate::has_plate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerLuckyPlate::set_has_plate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerLuckyPlate::clear_has_plate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerLuckyPlate::clear_plate_id() {
  plate_id_ = GOOGLE_LONGLONG(0);
  clear_has_plate_id();
}
inline ::google::protobuf::int64 PlayerLuckyPlate::plate_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerLuckyPlate.plate_id)
  return plate_id_;
}
inline void PlayerLuckyPlate::set_plate_id(::google::protobuf::int64 value) {
  set_has_plate_id();
  plate_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerLuckyPlate.plate_id)
}

// optional int32 result = 3;
inline bool PlayerLuckyPlate::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerLuckyPlate::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerLuckyPlate::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerLuckyPlate::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 PlayerLuckyPlate::result() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerLuckyPlate.result)
  return result_;
}
inline void PlayerLuckyPlate::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerLuckyPlate.result)
}

// -------------------------------------------------------------------

// GetReward

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_GET_REWARD];
inline bool GetReward::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetReward::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetReward::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetReward::clear_type_t() {
  type_t_ = 56;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GetReward::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetReward.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GetReward::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetReward.type_t)
}

// optional .Adoter.Asset.GetReward.GET_REWARD_REASON reason = 2;
inline bool GetReward::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetReward::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetReward::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetReward::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::Adoter::Asset::GetReward_GET_REWARD_REASON GetReward::reason() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetReward.reason)
  return static_cast< ::Adoter::Asset::GetReward_GET_REWARD_REASON >(reason_);
}
inline void GetReward::set_reason(::Adoter::Asset::GetReward_GET_REWARD_REASON value) {
  assert(::Adoter::Asset::GetReward_GET_REWARD_REASON_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetReward.reason)
}

// optional int64 reward_id = 3;
inline bool GetReward::has_reward_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetReward::set_has_reward_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetReward::clear_has_reward_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetReward::clear_reward_id() {
  reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_reward_id();
}
inline ::google::protobuf::int64 GetReward::reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GetReward.reward_id)
  return reward_id_;
}
inline void GetReward::set_reward_id(::google::protobuf::int64 value) {
  set_has_reward_id();
  reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GetReward.reward_id)
}

// -------------------------------------------------------------------

// PaiOperationLimit

// optional int64 player_id = 1;
inline bool PaiOperationLimit::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperationLimit::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperationLimit::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperationLimit::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PaiOperationLimit::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationLimit.player_id)
  return player_id_;
}
inline void PaiOperationLimit::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationLimit.player_id)
}

// optional int64 from_player_id = 2;
inline bool PaiOperationLimit::has_from_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiOperationLimit::set_has_from_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiOperationLimit::clear_has_from_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiOperationLimit::clear_from_player_id() {
  from_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_from_player_id();
}
inline ::google::protobuf::int64 PaiOperationLimit::from_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationLimit.from_player_id)
  return from_player_id_;
}
inline void PaiOperationLimit::set_from_player_id(::google::protobuf::int64 value) {
  set_has_from_player_id();
  from_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationLimit.from_player_id)
}

// optional int32 time_out = 3;
inline bool PaiOperationLimit::has_time_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiOperationLimit::set_has_time_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiOperationLimit::clear_has_time_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiOperationLimit::clear_time_out() {
  time_out_ = 0;
  clear_has_time_out();
}
inline ::google::protobuf::int32 PaiOperationLimit::time_out() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationLimit.time_out)
  return time_out_;
}
inline void PaiOperationLimit::set_time_out(::google::protobuf::int32 value) {
  set_has_time_out();
  time_out_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationLimit.time_out)
}

// optional .Adoter.Asset.PaiElement pai = 4;
inline bool PaiOperationLimit::has_pai() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaiOperationLimit::set_has_pai() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaiOperationLimit::clear_has_pai() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaiOperationLimit::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationLimit::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationLimit.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationLimit::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationLimit.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationLimit::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperationLimit::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperationLimit.pai)
}

// optional .Adoter.Asset.PAI_CHECK_RETURN oper_limit = 5;
inline bool PaiOperationLimit::has_oper_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaiOperationLimit::set_has_oper_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaiOperationLimit::clear_has_oper_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaiOperationLimit::clear_oper_limit() {
  oper_limit_ = 0;
  clear_has_oper_limit();
}
inline ::Adoter::Asset::PAI_CHECK_RETURN PaiOperationLimit::oper_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationLimit.oper_limit)
  return static_cast< ::Adoter::Asset::PAI_CHECK_RETURN >(oper_limit_);
}
inline void PaiOperationLimit::set_oper_limit(::Adoter::Asset::PAI_CHECK_RETURN value) {
  assert(::Adoter::Asset::PAI_CHECK_RETURN_IsValid(value));
  set_has_oper_limit();
  oper_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationLimit.oper_limit)
}

// -------------------------------------------------------------------

// PaiOperationList

// optional int64 player_id = 1;
inline bool PaiOperationList::has_player_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperationList::set_has_player_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperationList::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperationList::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 PaiOperationList::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationList.player_id)
  return player_id_;
}
inline void PaiOperationList::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationList.player_id)
}

// optional int64 from_player_id = 2;
inline bool PaiOperationList::has_from_player_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiOperationList::set_has_from_player_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiOperationList::clear_has_from_player_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiOperationList::clear_from_player_id() {
  from_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_from_player_id();
}
inline ::google::protobuf::int64 PaiOperationList::from_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationList.from_player_id)
  return from_player_id_;
}
inline void PaiOperationList::set_from_player_id(::google::protobuf::int64 value) {
  set_has_from_player_id();
  from_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationList.from_player_id)
}

// optional int32 time_out = 3;
inline bool PaiOperationList::has_time_out() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiOperationList::set_has_time_out() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiOperationList::clear_has_time_out() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiOperationList::clear_time_out() {
  time_out_ = 0;
  clear_has_time_out();
}
inline ::google::protobuf::int32 PaiOperationList::time_out() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationList.time_out)
  return time_out_;
}
inline void PaiOperationList::set_time_out(::google::protobuf::int32 value) {
  set_has_time_out();
  time_out_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationList.time_out)
}

// optional .Adoter.Asset.PaiElement pai = 4;
inline bool PaiOperationList::has_pai() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaiOperationList::set_has_pai() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaiOperationList::clear_has_pai() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaiOperationList::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationList::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationList.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationList::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationList.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationList::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperationList::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperationList.pai)
}

// repeated .Adoter.Asset.PAI_CHECK_RETURN oper_list = 5;
inline int PaiOperationList::oper_list_size() const {
  return oper_list_.size();
}
inline void PaiOperationList::clear_oper_list() {
  oper_list_.Clear();
}
inline ::Adoter::Asset::PAI_CHECK_RETURN PaiOperationList::oper_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationList.oper_list)
  return static_cast< ::Adoter::Asset::PAI_CHECK_RETURN >(oper_list_.Get(index));
}
inline void PaiOperationList::set_oper_list(int index, ::Adoter::Asset::PAI_CHECK_RETURN value) {
  assert(::Adoter::Asset::PAI_CHECK_RETURN_IsValid(value));
  oper_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationList.oper_list)
}
inline void PaiOperationList::add_oper_list(::Adoter::Asset::PAI_CHECK_RETURN value) {
  assert(::Adoter::Asset::PAI_CHECK_RETURN_IsValid(value));
  oper_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationList.oper_list)
}
inline const ::google::protobuf::RepeatedField<int>&
PaiOperationList::oper_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationList.oper_list)
  return oper_list_;
}
inline ::google::protobuf::RepeatedField<int>*
PaiOperationList::mutable_oper_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationList.oper_list)
  return &oper_list_;
}

// -------------------------------------------------------------------

// PaiOperation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_PAI_OPERATION];
inline bool PaiOperation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperation::clear_type_t() {
  type_t_ = 4;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiOperation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiOperation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperation.type_t)
}

// optional .Adoter.Asset.PaiOperation.PAI_OPER_TYPE oper_type = 2;
inline bool PaiOperation::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiOperation::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiOperation::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiOperation::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::PaiOperation_PAI_OPER_TYPE PaiOperation::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.oper_type)
  return static_cast< ::Adoter::Asset::PaiOperation_PAI_OPER_TYPE >(oper_type_);
}
inline void PaiOperation::set_oper_type(::Adoter::Asset::PaiOperation_PAI_OPER_TYPE value) {
  assert(::Adoter::Asset::PaiOperation_PAI_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperation.oper_type)
}

// optional .Adoter.Asset.POSITION_TYPE position = 3;
inline bool PaiOperation::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiOperation::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiOperation::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiOperation::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE PaiOperation::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void PaiOperation::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperation.position)
}

// repeated .Adoter.Asset.PaiElement pais = 4;
inline int PaiOperation::pais_size() const {
  return pais_.size();
}
inline void PaiOperation::clear_pais() {
  pais_.Clear();
}
inline const ::Adoter::Asset::PaiElement& PaiOperation::pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.pais)
  return pais_.Get(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperation::mutable_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperation.pais)
  return pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperation::add_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperation.pais)
  return pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
PaiOperation::pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperation.pais)
  return pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
PaiOperation::mutable_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperation.pais)
  return &pais_;
}

// optional .Adoter.Asset.PaiElement pai = 5;
inline bool PaiOperation::has_pai() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PaiOperation::set_has_pai() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PaiOperation::clear_has_pai() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PaiOperation::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperation::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperation.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperation::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperation.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperation::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperation::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperation.pai)
}

// -------------------------------------------------------------------

// GameOperation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_GAME_OPERATION];
inline bool GameOperation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameOperation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameOperation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameOperation::clear_type_t() {
  type_t_ = 5;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE GameOperation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void GameOperation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.type_t)
}

// optional .Adoter.Asset.GAME_OPER_TYPE oper_type = 2;
inline bool GameOperation::has_oper_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameOperation::set_has_oper_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameOperation::clear_has_oper_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameOperation::clear_oper_type() {
  oper_type_ = 1;
  clear_has_oper_type();
}
inline ::Adoter::Asset::GAME_OPER_TYPE GameOperation::oper_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.oper_type)
  return static_cast< ::Adoter::Asset::GAME_OPER_TYPE >(oper_type_);
}
inline void GameOperation::set_oper_type(::Adoter::Asset::GAME_OPER_TYPE value) {
  assert(::Adoter::Asset::GAME_OPER_TYPE_IsValid(value));
  set_has_oper_type();
  oper_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.oper_type)
}

// optional int64 source_player_id = 3;
inline bool GameOperation::has_source_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameOperation::set_has_source_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameOperation::clear_has_source_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameOperation::clear_source_player_id() {
  source_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_source_player_id();
}
inline ::google::protobuf::int64 GameOperation::source_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.source_player_id)
  return source_player_id_;
}
inline void GameOperation::set_source_player_id(::google::protobuf::int64 value) {
  set_has_source_player_id();
  source_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.source_player_id)
}

// optional int64 destination_player_id = 4;
inline bool GameOperation::has_destination_player_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameOperation::set_has_destination_player_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameOperation::clear_has_destination_player_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameOperation::clear_destination_player_id() {
  destination_player_id_ = GOOGLE_LONGLONG(0);
  clear_has_destination_player_id();
}
inline ::google::protobuf::int64 GameOperation::destination_player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.GameOperation.destination_player_id)
  return destination_player_id_;
}
inline void GameOperation::set_destination_player_id(::google::protobuf::int64 value) {
  set_has_destination_player_id();
  destination_player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.GameOperation.destination_player_id)
}

// -------------------------------------------------------------------

// BuySomething

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_BUY_SOMETHING];
inline bool BuySomething::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuySomething::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuySomething::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuySomething::clear_type_t() {
  type_t_ = 7;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE BuySomething::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BuySomething.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void BuySomething::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BuySomething.type_t)
}

// optional int64 mall_id = 2;
inline bool BuySomething::has_mall_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuySomething::set_has_mall_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuySomething::clear_has_mall_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuySomething::clear_mall_id() {
  mall_id_ = GOOGLE_LONGLONG(0);
  clear_has_mall_id();
}
inline ::google::protobuf::int64 BuySomething::mall_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BuySomething.mall_id)
  return mall_id_;
}
inline void BuySomething::set_mall_id(::google::protobuf::int64 value) {
  set_has_mall_id();
  mall_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BuySomething.mall_id)
}

// optional int32 result = 3;
inline bool BuySomething::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuySomething::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuySomething::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuySomething::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BuySomething::result() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.BuySomething.result)
  return result_;
}
inline void BuySomething::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.BuySomething.result)
}

// -------------------------------------------------------------------

// LoadScene

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_C2S_LOAD_SCENE];
inline bool LoadScene::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadScene::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadScene::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadScene::clear_type_t() {
  type_t_ = 57;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE LoadScene::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LoadScene.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void LoadScene::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LoadScene.type_t)
}

// optional .Adoter.Asset.LOAD_SCENE_TYPE load_type = 2;
inline bool LoadScene::has_load_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadScene::set_has_load_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadScene::clear_has_load_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadScene::clear_load_type() {
  load_type_ = 1;
  clear_has_load_type();
}
inline ::Adoter::Asset::LOAD_SCENE_TYPE LoadScene::load_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LoadScene.load_type)
  return static_cast< ::Adoter::Asset::LOAD_SCENE_TYPE >(load_type_);
}
inline void LoadScene::set_load_type(::Adoter::Asset::LOAD_SCENE_TYPE value) {
  assert(::Adoter::Asset::LOAD_SCENE_TYPE_IsValid(value));
  set_has_load_type();
  load_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LoadScene.load_type)
}

// optional int64 scene_id = 3;
inline bool LoadScene::has_scene_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadScene::set_has_scene_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadScene::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadScene::clear_scene_id() {
  scene_id_ = GOOGLE_LONGLONG(0);
  clear_has_scene_id();
}
inline ::google::protobuf::int64 LoadScene::scene_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LoadScene.scene_id)
  return scene_id_;
}
inline void LoadScene::set_scene_id(::google::protobuf::int64 value) {
  set_has_scene_id();
  scene_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LoadScene.scene_id)
}

// -------------------------------------------------------------------

// PlayerList

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYERS];
inline bool PlayerList::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerList::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerList::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerList::clear_type_t() {
  type_t_ = 504;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerList::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerList.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerList::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerList.type_t)
}

// repeated int64 player_list = 2;
inline int PlayerList::player_list_size() const {
  return player_list_.size();
}
inline void PlayerList::clear_player_list() {
  player_list_.Clear();
}
inline ::google::protobuf::int64 PlayerList::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerList.player_list)
  return player_list_.Get(index);
}
inline void PlayerList::set_player_list(int index, ::google::protobuf::int64 value) {
  player_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerList.player_list)
}
inline void PlayerList::add_player_list(::google::protobuf::int64 value) {
  player_list_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PlayerList.player_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PlayerList::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PlayerList.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PlayerList::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PlayerList.player_list)
  return &player_list_;
}

// -------------------------------------------------------------------

// PlayerInformation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PLAYER_INFO];
inline bool PlayerInformation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInformation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInformation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInformation::clear_type_t() {
  type_t_ = 505;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PlayerInformation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerInformation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PlayerInformation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PlayerInformation.type_t)
}

// optional .Adoter.Asset.Player player = 2;
inline bool PlayerInformation::has_player() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInformation::set_has_player() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInformation::clear_has_player() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInformation::clear_player() {
  if (player_ != NULL) player_->::Adoter::Asset::Player::Clear();
  clear_has_player();
}
inline const ::Adoter::Asset::Player& PlayerInformation::player() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PlayerInformation.player)
  return player_ != NULL ? *player_ : *default_instance_->player_;
}
inline ::Adoter::Asset::Player* PlayerInformation::mutable_player() {
  set_has_player();
  if (player_ == NULL) player_ = new ::Adoter::Asset::Player;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PlayerInformation.player)
  return player_;
}
inline ::Adoter::Asset::Player* PlayerInformation::release_player() {
  clear_has_player();
  ::Adoter::Asset::Player* temp = player_;
  player_ = NULL;
  return temp;
}
inline void PlayerInformation::set_allocated_player(::Adoter::Asset::Player* player) {
  delete player_;
  player_ = player;
  if (player) {
    set_has_player();
  } else {
    clear_has_player();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PlayerInformation.player)
}

// -------------------------------------------------------------------

// AlertMessage

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ALERT_ERROR];
inline bool AlertMessage::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertMessage::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertMessage::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertMessage::clear_type_t() {
  type_t_ = 507;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE AlertMessage::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void AlertMessage::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.type_t)
}

// optional .Adoter.Asset.ERROR_TYPE error_type = 2;
inline bool AlertMessage::has_error_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlertMessage::set_has_error_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlertMessage::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlertMessage::clear_error_type() {
  error_type_ = 1;
  clear_has_error_type();
}
inline ::Adoter::Asset::ERROR_TYPE AlertMessage::error_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.error_type)
  return static_cast< ::Adoter::Asset::ERROR_TYPE >(error_type_);
}
inline void AlertMessage::set_error_type(::Adoter::Asset::ERROR_TYPE value) {
  assert(::Adoter::Asset::ERROR_TYPE_IsValid(value));
  set_has_error_type();
  error_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.error_type)
}

// optional .Adoter.Asset.ERROR_SHOW_TYPE error_show_type = 3;
inline bool AlertMessage::has_error_show_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlertMessage::set_has_error_show_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlertMessage::clear_has_error_show_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlertMessage::clear_error_show_type() {
  error_show_type_ = 1;
  clear_has_error_show_type();
}
inline ::Adoter::Asset::ERROR_SHOW_TYPE AlertMessage::error_show_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.error_show_type)
  return static_cast< ::Adoter::Asset::ERROR_SHOW_TYPE >(error_show_type_);
}
inline void AlertMessage::set_error_show_type(::Adoter::Asset::ERROR_SHOW_TYPE value) {
  assert(::Adoter::Asset::ERROR_SHOW_TYPE_IsValid(value));
  set_has_error_show_type();
  error_show_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.error_show_type)
}

// optional .Adoter.Asset.ERROR_CODE error_code = 4;
inline bool AlertMessage::has_error_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlertMessage::set_has_error_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlertMessage::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlertMessage::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::Adoter::Asset::ERROR_CODE AlertMessage::error_code() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AlertMessage.error_code)
  return static_cast< ::Adoter::Asset::ERROR_CODE >(error_code_);
}
inline void AlertMessage::set_error_code(::Adoter::Asset::ERROR_CODE value) {
  assert(::Adoter::Asset::ERROR_CODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AlertMessage.error_code)
}

// -------------------------------------------------------------------

// CommonOperationResponse

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_OPERATION_RESPONSE];
inline bool CommonOperationResponse::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonOperationResponse::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonOperationResponse::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonOperationResponse::clear_type_t() {
  type_t_ = 508;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE CommonOperationResponse::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonOperationResponse.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void CommonOperationResponse::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonOperationResponse.type_t)
}

// optional .Adoter.Asset.META_TYPE client_type_t = 2;
inline bool CommonOperationResponse::has_client_type_t() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonOperationResponse::set_has_client_type_t() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonOperationResponse::clear_has_client_type_t() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonOperationResponse::clear_client_type_t() {
  client_type_t_ = 1;
  clear_has_client_type_t();
}
inline ::Adoter::Asset::META_TYPE CommonOperationResponse::client_type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonOperationResponse.client_type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(client_type_t_);
}
inline void CommonOperationResponse::set_client_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_client_type_t();
  client_type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonOperationResponse.client_type_t)
}

// optional bytes client_message = 3;
inline bool CommonOperationResponse::has_client_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonOperationResponse::set_has_client_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonOperationResponse::clear_has_client_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonOperationResponse::clear_client_message() {
  if (client_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_message_->clear();
  }
  clear_has_client_message();
}
inline const ::std::string& CommonOperationResponse::client_message() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonOperationResponse.client_message)
  return *client_message_;
}
inline void CommonOperationResponse::set_client_message(const ::std::string& value) {
  set_has_client_message();
  if (client_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_message_ = new ::std::string;
  }
  client_message_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonOperationResponse.client_message)
}
inline void CommonOperationResponse::set_client_message(const char* value) {
  set_has_client_message();
  if (client_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_message_ = new ::std::string;
  }
  client_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.CommonOperationResponse.client_message)
}
inline void CommonOperationResponse::set_client_message(const void* value, size_t size) {
  set_has_client_message();
  if (client_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_message_ = new ::std::string;
  }
  client_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.CommonOperationResponse.client_message)
}
inline ::std::string* CommonOperationResponse::mutable_client_message() {
  set_has_client_message();
  if (client_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonOperationResponse.client_message)
  return client_message_;
}
inline ::std::string* CommonOperationResponse::release_client_message() {
  clear_has_client_message();
  if (client_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_message_;
    client_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonOperationResponse::set_allocated_client_message(::std::string* client_message) {
  if (client_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_message_;
  }
  if (client_message) {
    set_has_client_message();
    client_message_ = client_message;
  } else {
    clear_has_client_message();
    client_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonOperationResponse.client_message)
}

// -------------------------------------------------------------------

// PaiNotify_MutiPai

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool PaiNotify_MutiPai::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiNotify_MutiPai::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiNotify_MutiPai::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiNotify_MutiPai::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE PaiNotify_MutiPai::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.MutiPai.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void PaiNotify_MutiPai::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.MutiPai.card_type)
}

// repeated int32 cards = 2;
inline int PaiNotify_MutiPai::cards_size() const {
  return cards_.size();
}
inline void PaiNotify_MutiPai::clear_cards() {
  cards_.Clear();
}
inline ::google::protobuf::int32 PaiNotify_MutiPai::cards(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.MutiPai.cards)
  return cards_.Get(index);
}
inline void PaiNotify_MutiPai::set_cards(int index, ::google::protobuf::int32 value) {
  cards_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.MutiPai.cards)
}
inline void PaiNotify_MutiPai::add_cards(::google::protobuf::int32 value) {
  cards_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiNotify.MutiPai.cards)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PaiNotify_MutiPai::cards() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiNotify.MutiPai.cards)
  return cards_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PaiNotify_MutiPai::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiNotify.MutiPai.cards)
  return &cards_;
}

// -------------------------------------------------------------------

// PaiNotify_SinglePai

// optional .Adoter.Asset.CARD_TYPE card_type = 1;
inline bool PaiNotify_SinglePai::has_card_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiNotify_SinglePai::set_has_card_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiNotify_SinglePai::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiNotify_SinglePai::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE PaiNotify_SinglePai::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.SinglePai.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void PaiNotify_SinglePai::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.SinglePai.card_type)
}

// optional int32 card_value = 2;
inline bool PaiNotify_SinglePai::has_card_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiNotify_SinglePai::set_has_card_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiNotify_SinglePai::clear_has_card_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiNotify_SinglePai::clear_card_value() {
  card_value_ = 0;
  clear_has_card_value();
}
inline ::google::protobuf::int32 PaiNotify_SinglePai::card_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.SinglePai.card_value)
  return card_value_;
}
inline void PaiNotify_SinglePai::set_card_value(::google::protobuf::int32 value) {
  set_has_card_value();
  card_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.SinglePai.card_value)
}

// -------------------------------------------------------------------

// PaiNotify

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_NOTIFY];
inline bool PaiNotify::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiNotify::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiNotify::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiNotify::clear_type_t() {
  type_t_ = 509;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiNotify::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiNotify::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.type_t)
}

// optional .Adoter.Asset.PaiNotify.CARDS_DATA_TYPE data_type = 2;
inline bool PaiNotify::has_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PaiNotify::set_has_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PaiNotify::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PaiNotify::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE PaiNotify::data_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.data_type)
  return static_cast< ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE >(data_type_);
}
inline void PaiNotify::set_data_type(::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE value) {
  assert(::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiNotify.data_type)
}

// repeated .Adoter.Asset.PaiNotify.MutiPai pais = 3;
inline int PaiNotify::pais_size() const {
  return pais_.size();
}
inline void PaiNotify::clear_pais() {
  pais_.Clear();
}
inline const ::Adoter::Asset::PaiNotify_MutiPai& PaiNotify::pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.pais)
  return pais_.Get(index);
}
inline ::Adoter::Asset::PaiNotify_MutiPai* PaiNotify::mutable_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiNotify.pais)
  return pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiNotify_MutiPai* PaiNotify::add_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiNotify.pais)
  return pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >&
PaiNotify::pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiNotify.pais)
  return pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiNotify_MutiPai >*
PaiNotify::mutable_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiNotify.pais)
  return &pais_;
}

// optional .Adoter.Asset.PaiNotify.SinglePai pai = 4;
inline bool PaiNotify::has_pai() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PaiNotify::set_has_pai() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PaiNotify::clear_has_pai() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PaiNotify::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiNotify_SinglePai::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiNotify_SinglePai& PaiNotify::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiNotify.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiNotify_SinglePai* PaiNotify::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiNotify_SinglePai;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiNotify.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiNotify_SinglePai* PaiNotify::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiNotify_SinglePai* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiNotify::set_allocated_pai(::Adoter::Asset::PaiNotify_SinglePai* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiNotify.pai)
}

// -------------------------------------------------------------------

// CommonProperty

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_SHARE_COMMON_PROPERTY];
inline bool CommonProperty::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonProperty::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonProperty::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonProperty::clear_type_t() {
  type_t_ = 6;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE CommonProperty::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProperty.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void CommonProperty::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProperty.type_t)
}

// optional .Adoter.Asset.CommonProperty.SYNC_REASON_TYPE reason_type = 2;
inline bool CommonProperty::has_reason_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonProperty::set_has_reason_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonProperty::clear_has_reason_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonProperty::clear_reason_type() {
  reason_type_ = 1;
  clear_has_reason_type();
}
inline ::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE CommonProperty::reason_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProperty.reason_type)
  return static_cast< ::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE >(reason_type_);
}
inline void CommonProperty::set_reason_type(::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE value) {
  assert(::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE_IsValid(value));
  set_has_reason_type();
  reason_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProperty.reason_type)
}

// optional int64 player_id = 3;
inline bool CommonProperty::has_player_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonProperty::set_has_player_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonProperty::clear_has_player_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonProperty::clear_player_id() {
  player_id_ = GOOGLE_LONGLONG(0);
  clear_has_player_id();
}
inline ::google::protobuf::int64 CommonProperty::player_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProperty.player_id)
  return player_id_;
}
inline void CommonProperty::set_player_id(::google::protobuf::int64 value) {
  set_has_player_id();
  player_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProperty.player_id)
}

// optional .Adoter.Asset.CommonProp common_prop = 4;
inline bool CommonProperty::has_common_prop() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonProperty::set_has_common_prop() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonProperty::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonProperty::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& CommonProperty::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProperty.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* CommonProperty::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonProperty.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* CommonProperty::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonProperty::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonProperty.common_prop)
}

// -------------------------------------------------------------------

// PaiOperationAlert

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_PAI_OPERATION_ALERT];
inline bool PaiOperationAlert::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PaiOperationAlert::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PaiOperationAlert::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PaiOperationAlert::clear_type_t() {
  type_t_ = 510;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE PaiOperationAlert::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void PaiOperationAlert::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationAlert.type_t)
}

// repeated .Adoter.Asset.PAI_CHECK_RETURN check_return = 2;
inline int PaiOperationAlert::check_return_size() const {
  return check_return_.size();
}
inline void PaiOperationAlert::clear_check_return() {
  check_return_.Clear();
}
inline ::Adoter::Asset::PAI_CHECK_RETURN PaiOperationAlert::check_return(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.check_return)
  return static_cast< ::Adoter::Asset::PAI_CHECK_RETURN >(check_return_.Get(index));
}
inline void PaiOperationAlert::set_check_return(int index, ::Adoter::Asset::PAI_CHECK_RETURN value) {
  assert(::Adoter::Asset::PAI_CHECK_RETURN_IsValid(value));
  check_return_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.PaiOperationAlert.check_return)
}
inline void PaiOperationAlert::add_check_return(::Adoter::Asset::PAI_CHECK_RETURN value) {
  assert(::Adoter::Asset::PAI_CHECK_RETURN_IsValid(value));
  check_return_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationAlert.check_return)
}
inline const ::google::protobuf::RepeatedField<int>&
PaiOperationAlert::check_return() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationAlert.check_return)
  return check_return_;
}
inline ::google::protobuf::RepeatedField<int>*
PaiOperationAlert::mutable_check_return() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationAlert.check_return)
  return &check_return_;
}

// optional .Adoter.Asset.PaiElement pai = 3;
inline bool PaiOperationAlert::has_pai() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PaiOperationAlert::set_has_pai() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PaiOperationAlert::clear_has_pai() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PaiOperationAlert::clear_pai() {
  if (pai_ != NULL) pai_->::Adoter::Asset::PaiElement::Clear();
  clear_has_pai();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationAlert::pai() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.pai)
  return pai_ != NULL ? *pai_ : *default_instance_->pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationAlert::mutable_pai() {
  set_has_pai();
  if (pai_ == NULL) pai_ = new ::Adoter::Asset::PaiElement;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationAlert.pai)
  return pai_;
}
inline ::Adoter::Asset::PaiElement* PaiOperationAlert::release_pai() {
  clear_has_pai();
  ::Adoter::Asset::PaiElement* temp = pai_;
  pai_ = NULL;
  return temp;
}
inline void PaiOperationAlert::set_allocated_pai(::Adoter::Asset::PaiElement* pai) {
  delete pai_;
  pai_ = pai;
  if (pai) {
    set_has_pai();
  } else {
    clear_has_pai();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.PaiOperationAlert.pai)
}

// repeated .Adoter.Asset.PaiElement pais = 4;
inline int PaiOperationAlert::pais_size() const {
  return pais_.size();
}
inline void PaiOperationAlert::clear_pais() {
  pais_.Clear();
}
inline const ::Adoter::Asset::PaiElement& PaiOperationAlert::pais(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.PaiOperationAlert.pais)
  return pais_.Get(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperationAlert::mutable_pais(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.PaiOperationAlert.pais)
  return pais_.Mutable(index);
}
inline ::Adoter::Asset::PaiElement* PaiOperationAlert::add_pais() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.PaiOperationAlert.pais)
  return pais_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >&
PaiOperationAlert::pais() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.PaiOperationAlert.pais)
  return pais_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::PaiElement >*
PaiOperationAlert::mutable_pais() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.PaiOperationAlert.pais)
  return &pais_;
}

// -------------------------------------------------------------------

// SyncCommonLimit

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_LIMIT];
inline bool SyncCommonLimit::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncCommonLimit::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncCommonLimit::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncCommonLimit::clear_type_t() {
  type_t_ = 511;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SyncCommonLimit::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonLimit.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SyncCommonLimit::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonLimit.type_t)
}

// optional .Adoter.Asset.PlayerCommonLimit common_limit = 2;
inline bool SyncCommonLimit::has_common_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncCommonLimit::set_has_common_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncCommonLimit::clear_has_common_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncCommonLimit::clear_common_limit() {
  if (common_limit_ != NULL) common_limit_->::Adoter::Asset::PlayerCommonLimit::Clear();
  clear_has_common_limit();
}
inline const ::Adoter::Asset::PlayerCommonLimit& SyncCommonLimit::common_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonLimit.common_limit)
  return common_limit_ != NULL ? *common_limit_ : *default_instance_->common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* SyncCommonLimit::mutable_common_limit() {
  set_has_common_limit();
  if (common_limit_ == NULL) common_limit_ = new ::Adoter::Asset::PlayerCommonLimit;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.SyncCommonLimit.common_limit)
  return common_limit_;
}
inline ::Adoter::Asset::PlayerCommonLimit* SyncCommonLimit::release_common_limit() {
  clear_has_common_limit();
  ::Adoter::Asset::PlayerCommonLimit* temp = common_limit_;
  common_limit_ = NULL;
  return temp;
}
inline void SyncCommonLimit::set_allocated_common_limit(::Adoter::Asset::PlayerCommonLimit* common_limit) {
  delete common_limit_;
  common_limit_ = common_limit;
  if (common_limit) {
    set_has_common_limit();
  } else {
    clear_has_common_limit();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.SyncCommonLimit.common_limit)
}

// -------------------------------------------------------------------

// SyncCommonReward

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_COMMON_REWARD];
inline bool SyncCommonReward::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncCommonReward::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncCommonReward::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncCommonReward::clear_type_t() {
  type_t_ = 512;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE SyncCommonReward::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonReward.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void SyncCommonReward::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonReward.type_t)
}

// optional int64 common_reward_id = 2;
inline bool SyncCommonReward::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncCommonReward::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncCommonReward::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncCommonReward::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 SyncCommonReward::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.SyncCommonReward.common_reward_id)
  return common_reward_id_;
}
inline void SyncCommonReward::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.SyncCommonReward.common_reward_id)
}

// -------------------------------------------------------------------

// RoomInformation_Player

// optional .Adoter.Asset.POSITION_TYPE position = 1;
inline bool RoomInformation_Player::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInformation_Player::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInformation_Player::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInformation_Player::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::Adoter::Asset::POSITION_TYPE RoomInformation_Player::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.position)
  return static_cast< ::Adoter::Asset::POSITION_TYPE >(position_);
}
inline void RoomInformation_Player::set_position(::Adoter::Asset::POSITION_TYPE value) {
  assert(::Adoter::Asset::POSITION_TYPE_IsValid(value));
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.Player.position)
}

// optional .Adoter.Asset.CommonProp common_prop = 2;
inline bool RoomInformation_Player::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInformation_Player::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInformation_Player::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInformation_Player::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::CommonProp& RoomInformation_Player::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.Player.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::CommonProp* RoomInformation_Player::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.Player.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::CommonProp* RoomInformation_Player::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::CommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void RoomInformation_Player::set_allocated_common_prop(::Adoter::Asset::CommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomInformation.Player.common_prop)
}

// -------------------------------------------------------------------

// RoomInformation

// optional .Adoter.Asset.META_TYPE type_t = 1 [default = META_TYPE_S2C_ROOM_INFO];
inline bool RoomInformation::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInformation::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInformation::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInformation::clear_type_t() {
  type_t_ = 513;
  clear_has_type_t();
}
inline ::Adoter::Asset::META_TYPE RoomInformation::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.type_t)
  return static_cast< ::Adoter::Asset::META_TYPE >(type_t_);
}
inline void RoomInformation::set_type_t(::Adoter::Asset::META_TYPE value) {
  assert(::Adoter::Asset::META_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomInformation.type_t)
}

// repeated .Adoter.Asset.RoomInformation.Player player_list = 2;
inline int RoomInformation::player_list_size() const {
  return player_list_.size();
}
inline void RoomInformation::clear_player_list() {
  player_list_.Clear();
}
inline const ::Adoter::Asset::RoomInformation_Player& RoomInformation::player_list(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomInformation.player_list)
  return player_list_.Get(index);
}
inline ::Adoter::Asset::RoomInformation_Player* RoomInformation::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomInformation.player_list)
  return player_list_.Mutable(index);
}
inline ::Adoter::Asset::RoomInformation_Player* RoomInformation::add_player_list() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomInformation.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >&
RoomInformation::player_list() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomInformation.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomInformation_Player >*
RoomInformation::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomInformation.player_list)
  return &player_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Asset
}  // namespace Adoter

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Adoter::Asset::EnterRoom_ENTER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::EnterRoom_ENTER_TYPE>() {
  return ::Adoter::Asset::EnterRoom_ENTER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::GetReward_GET_REWARD_REASON> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::GetReward_GET_REWARD_REASON>() {
  return ::Adoter::Asset::GetReward_GET_REWARD_REASON_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::PaiOperation_PAI_OPER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::PaiOperation_PAI_OPER_TYPE>() {
  return ::Adoter::Asset::PaiOperation_PAI_OPER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE>() {
  return ::Adoter::Asset::PaiNotify_CARDS_DATA_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE>() {
  return ::Adoter::Asset::CommonProperty_SYNC_REASON_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERR_USE_ITEM_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERR_USE_ITEM_TYPE>() {
  return ::Adoter::Asset::ERR_USE_ITEM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::POSITION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::POSITION_TYPE>() {
  return ::Adoter::Asset::POSITION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::LOAD_SCENE_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::LOAD_SCENE_TYPE>() {
  return ::Adoter::Asset::LOAD_SCENE_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERROR_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERROR_TYPE>() {
  return ::Adoter::Asset::ERROR_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERROR_SHOW_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERROR_SHOW_TYPE>() {
  return ::Adoter::Asset::ERROR_SHOW_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ERROR_CODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ERROR_CODE>() {
  return ::Adoter::Asset::ERROR_CODE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::META_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::META_TYPE>() {
  return ::Adoter::Asset::META_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ROOM_MODEL_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ROOM_MODEL_TYPE>() {
  return ::Adoter::Asset::ROOM_MODEL_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ROOM_EXTEND_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ROOM_EXTEND_TYPE>() {
  return ::Adoter::Asset::ROOM_EXTEND_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::PAI_CHECK_RETURN> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::PAI_CHECK_RETURN>() {
  return ::Adoter::Asset::PAI_CHECK_RETURN_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::GAME_OPER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::GAME_OPER_TYPE>() {
  return ::Adoter::Asset::GAME_OPER_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_P_5fProtocol_2eproto__INCLUDED
