// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P_Asset.proto

#ifndef PROTOBUF_P_5fAsset_2eproto__INCLUDED
#define PROTOBUF_P_5fAsset_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Adoter {
namespace Asset {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_P_5fAsset_2eproto();
void protobuf_AssignDesc_P_5fAsset_2eproto();
void protobuf_ShutdownFile_P_5fAsset_2eproto();

class AssetCommonProp;
class RoomLimit;
class CommonLimit;
class CoolDown;
class MJCard;
class MJCard_Card;
class CommonConst;
class CommonReward;
class CommonReward_Reward;
class CommonConsume;
class CommonConsume_Element;
class LuckyPlate;
class LuckyPlate_Plate;
class DailyBonus;
class Mall;
class RoomFan;
class RoomFan_FanElement;
class RoomModel;
class RoomOpen;
class RoomOpen_CardCost;
class VoiceAlter;
class VoiceAlter_VoiceElement;
class Face;
class Avatar;
class Activity;
class DailyAllowance;
class Recharge;
class DailySign;
class DailySign_ContinuousSign;
class Item_CommonProp;
class Item_Item;
class Item_Normal;
class Item_Potion;
class Item_RoomCard;

enum CommonLimit_COMMON_LIMIT_TYPE {
  CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT = 1,
  CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_LUCKY_PLATE = 2,
  CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_DIALY_BONUS = 3
};
bool CommonLimit_COMMON_LIMIT_TYPE_IsValid(int value);
const CommonLimit_COMMON_LIMIT_TYPE CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MIN = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT;
const CommonLimit_COMMON_LIMIT_TYPE CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MAX = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_DIALY_BONUS;
const int CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_ARRAYSIZE = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_COMMON_LIMIT_TYPE_descriptor();
inline const ::std::string& CommonLimit_COMMON_LIMIT_TYPE_Name(CommonLimit_COMMON_LIMIT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_COMMON_LIMIT_TYPE_descriptor(), value);
}
inline bool CommonLimit_COMMON_LIMIT_TYPE_Parse(
    const ::std::string& name, CommonLimit_COMMON_LIMIT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_COMMON_LIMIT_TYPE>(
    CommonLimit_COMMON_LIMIT_TYPE_descriptor(), name, value);
}
enum CommonLimit_COOL_DOWN_TYPE {
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_DAY = 1,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_WEEK = 2,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MONTH = 3,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_YEAR = 4,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_NEVER = 5
};
bool CommonLimit_COOL_DOWN_TYPE_IsValid(int value);
const CommonLimit_COOL_DOWN_TYPE CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MIN = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_DAY;
const CommonLimit_COOL_DOWN_TYPE CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MAX = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_NEVER;
const int CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_ARRAYSIZE = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_COOL_DOWN_TYPE_descriptor();
inline const ::std::string& CommonLimit_COOL_DOWN_TYPE_Name(CommonLimit_COOL_DOWN_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_COOL_DOWN_TYPE_descriptor(), value);
}
inline bool CommonLimit_COOL_DOWN_TYPE_Parse(
    const ::std::string& name, CommonLimit_COOL_DOWN_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_COOL_DOWN_TYPE>(
    CommonLimit_COOL_DOWN_TYPE_descriptor(), name, value);
}
enum CommonLimit_COOL_DOWN_CLEAR_TYPE {
  CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_ZERO_TIME = 1,
  CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_WHEN_OPER = 2
};
bool CommonLimit_COOL_DOWN_CLEAR_TYPE_IsValid(int value);
const CommonLimit_COOL_DOWN_CLEAR_TYPE CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_MIN = CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_ZERO_TIME;
const CommonLimit_COOL_DOWN_CLEAR_TYPE CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_MAX = CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_WHEN_OPER;
const int CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_ARRAYSIZE = CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_COOL_DOWN_CLEAR_TYPE_descriptor();
inline const ::std::string& CommonLimit_COOL_DOWN_CLEAR_TYPE_Name(CommonLimit_COOL_DOWN_CLEAR_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_COOL_DOWN_CLEAR_TYPE_descriptor(), value);
}
inline bool CommonLimit_COOL_DOWN_CLEAR_TYPE_Parse(
    const ::std::string& name, CommonLimit_COOL_DOWN_CLEAR_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_COOL_DOWN_CLEAR_TYPE>(
    CommonLimit_COOL_DOWN_CLEAR_TYPE_descriptor(), name, value);
}
enum CoolDown_COOL_DOWN_REASON {
  CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_NORMAL = 1
};
bool CoolDown_COOL_DOWN_REASON_IsValid(int value);
const CoolDown_COOL_DOWN_REASON CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_MIN = CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_NORMAL;
const CoolDown_COOL_DOWN_REASON CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_MAX = CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_NORMAL;
const int CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_ARRAYSIZE = CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_MAX + 1;

const ::google::protobuf::EnumDescriptor* CoolDown_COOL_DOWN_REASON_descriptor();
inline const ::std::string& CoolDown_COOL_DOWN_REASON_Name(CoolDown_COOL_DOWN_REASON value) {
  return ::google::protobuf::internal::NameOfEnum(
    CoolDown_COOL_DOWN_REASON_descriptor(), value);
}
inline bool CoolDown_COOL_DOWN_REASON_Parse(
    const ::std::string& name, CoolDown_COOL_DOWN_REASON* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoolDown_COOL_DOWN_REASON>(
    CoolDown_COOL_DOWN_REASON_descriptor(), name, value);
}
enum CommonReward_REWARD_TYPE {
  CommonReward_REWARD_TYPE_REWARD_TYPE_DIAMOND = 1,
  CommonReward_REWARD_TYPE_REWARD_TYPE_HUANLEDOU = 2,
  CommonReward_REWARD_TYPE_REWARD_TYPE_ITEM = 3
};
bool CommonReward_REWARD_TYPE_IsValid(int value);
const CommonReward_REWARD_TYPE CommonReward_REWARD_TYPE_REWARD_TYPE_MIN = CommonReward_REWARD_TYPE_REWARD_TYPE_DIAMOND;
const CommonReward_REWARD_TYPE CommonReward_REWARD_TYPE_REWARD_TYPE_MAX = CommonReward_REWARD_TYPE_REWARD_TYPE_ITEM;
const int CommonReward_REWARD_TYPE_REWARD_TYPE_ARRAYSIZE = CommonReward_REWARD_TYPE_REWARD_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonReward_REWARD_TYPE_descriptor();
inline const ::std::string& CommonReward_REWARD_TYPE_Name(CommonReward_REWARD_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonReward_REWARD_TYPE_descriptor(), value);
}
inline bool CommonReward_REWARD_TYPE_Parse(
    const ::std::string& name, CommonReward_REWARD_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonReward_REWARD_TYPE>(
    CommonReward_REWARD_TYPE_descriptor(), name, value);
}
enum CommonConsume_CONSUME_TYPE {
  CommonConsume_CONSUME_TYPE_CONSUME_TYPE_DIAMOND = 1,
  CommonConsume_CONSUME_TYPE_CONSUME_TYPE_HUANLEDOU = 2,
  CommonConsume_CONSUME_TYPE_CONSUME_TYPE_ITEM = 3
};
bool CommonConsume_CONSUME_TYPE_IsValid(int value);
const CommonConsume_CONSUME_TYPE CommonConsume_CONSUME_TYPE_CONSUME_TYPE_MIN = CommonConsume_CONSUME_TYPE_CONSUME_TYPE_DIAMOND;
const CommonConsume_CONSUME_TYPE CommonConsume_CONSUME_TYPE_CONSUME_TYPE_MAX = CommonConsume_CONSUME_TYPE_CONSUME_TYPE_ITEM;
const int CommonConsume_CONSUME_TYPE_CONSUME_TYPE_ARRAYSIZE = CommonConsume_CONSUME_TYPE_CONSUME_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonConsume_CONSUME_TYPE_descriptor();
inline const ::std::string& CommonConsume_CONSUME_TYPE_Name(CommonConsume_CONSUME_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonConsume_CONSUME_TYPE_descriptor(), value);
}
inline bool CommonConsume_CONSUME_TYPE_Parse(
    const ::std::string& name, CommonConsume_CONSUME_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonConsume_CONSUME_TYPE>(
    CommonConsume_CONSUME_TYPE_descriptor(), name, value);
}
enum Mall_GOODS_TYPE {
  Mall_GOODS_TYPE_GOODS_TYPE_HUANLEDOU = 1,
  Mall_GOODS_TYPE_GOODS_TYPE_NORMAL_ITEM = 2
};
bool Mall_GOODS_TYPE_IsValid(int value);
const Mall_GOODS_TYPE Mall_GOODS_TYPE_GOODS_TYPE_MIN = Mall_GOODS_TYPE_GOODS_TYPE_HUANLEDOU;
const Mall_GOODS_TYPE Mall_GOODS_TYPE_GOODS_TYPE_MAX = Mall_GOODS_TYPE_GOODS_TYPE_NORMAL_ITEM;
const int Mall_GOODS_TYPE_GOODS_TYPE_ARRAYSIZE = Mall_GOODS_TYPE_GOODS_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mall_GOODS_TYPE_descriptor();
inline const ::std::string& Mall_GOODS_TYPE_Name(Mall_GOODS_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mall_GOODS_TYPE_descriptor(), value);
}
inline bool Mall_GOODS_TYPE_Parse(
    const ::std::string& name, Mall_GOODS_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mall_GOODS_TYPE>(
    Mall_GOODS_TYPE_descriptor(), name, value);
}
enum Activity_ACTIVITY_TYPE {
  Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_STOP_TIME = 1
};
bool Activity_ACTIVITY_TYPE_IsValid(int value);
const Activity_ACTIVITY_TYPE Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_MIN = Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_STOP_TIME;
const Activity_ACTIVITY_TYPE Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_MAX = Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_STOP_TIME;
const int Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_ARRAYSIZE = Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Activity_ACTIVITY_TYPE_descriptor();
inline const ::std::string& Activity_ACTIVITY_TYPE_Name(Activity_ACTIVITY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Activity_ACTIVITY_TYPE_descriptor(), value);
}
inline bool Activity_ACTIVITY_TYPE_Parse(
    const ::std::string& name, Activity_ACTIVITY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Activity_ACTIVITY_TYPE>(
    Activity_ACTIVITY_TYPE_descriptor(), name, value);
}
enum Item_Potion_POTION_TYPE {
  Item_Potion_POTION_TYPE_POTION_TYPE_HEMO = 1,
  Item_Potion_POTION_TYPE_POTION_TYPE_MAGIC = 2,
  Item_Potion_POTION_TYPE_POTION_TYPE_PHYSICAL_STRENGTH = 3
};
bool Item_Potion_POTION_TYPE_IsValid(int value);
const Item_Potion_POTION_TYPE Item_Potion_POTION_TYPE_POTION_TYPE_MIN = Item_Potion_POTION_TYPE_POTION_TYPE_HEMO;
const Item_Potion_POTION_TYPE Item_Potion_POTION_TYPE_POTION_TYPE_MAX = Item_Potion_POTION_TYPE_POTION_TYPE_PHYSICAL_STRENGTH;
const int Item_Potion_POTION_TYPE_POTION_TYPE_ARRAYSIZE = Item_Potion_POTION_TYPE_POTION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Item_Potion_POTION_TYPE_descriptor();
inline const ::std::string& Item_Potion_POTION_TYPE_Name(Item_Potion_POTION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Item_Potion_POTION_TYPE_descriptor(), value);
}
inline bool Item_Potion_POTION_TYPE_Parse(
    const ::std::string& name, Item_Potion_POTION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Item_Potion_POTION_TYPE>(
    Item_Potion_POTION_TYPE_descriptor(), name, value);
}
enum INVENTORY_TYPE {
  INVENTORY_TYPE_BACKPACKAGE = 1,
  INVENTORY_TYPE_EQUIPMENT = 2,
  INVENTORY_TYPE_FASHION = 3,
  INVENTORY_TYPE_COUNT = 4
};
bool INVENTORY_TYPE_IsValid(int value);
const INVENTORY_TYPE INVENTORY_TYPE_MIN = INVENTORY_TYPE_BACKPACKAGE;
const INVENTORY_TYPE INVENTORY_TYPE_MAX = INVENTORY_TYPE_COUNT;
const int INVENTORY_TYPE_ARRAYSIZE = INVENTORY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* INVENTORY_TYPE_descriptor();
inline const ::std::string& INVENTORY_TYPE_Name(INVENTORY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    INVENTORY_TYPE_descriptor(), value);
}
inline bool INVENTORY_TYPE_Parse(
    const ::std::string& name, INVENTORY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<INVENTORY_TYPE>(
    INVENTORY_TYPE_descriptor(), name, value);
}
enum GENDER_TYPE {
  GENDER_TYPE_MAN = 1,
  GENDER_TYPE_WOMAN = 2
};
bool GENDER_TYPE_IsValid(int value);
const GENDER_TYPE GENDER_TYPE_MIN = GENDER_TYPE_MAN;
const GENDER_TYPE GENDER_TYPE_MAX = GENDER_TYPE_WOMAN;
const int GENDER_TYPE_ARRAYSIZE = GENDER_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* GENDER_TYPE_descriptor();
inline const ::std::string& GENDER_TYPE_Name(GENDER_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    GENDER_TYPE_descriptor(), value);
}
inline bool GENDER_TYPE_Parse(
    const ::std::string& name, GENDER_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GENDER_TYPE>(
    GENDER_TYPE_descriptor(), name, value);
}
enum VERSION_TYPE {
  VERSION_TYPE_GLOBAL = 1,
  VERSION_TYPE_MAINLAND = 2,
  VERSION_TYPE_TAIWAN = 3
};
bool VERSION_TYPE_IsValid(int value);
const VERSION_TYPE VERSION_TYPE_MIN = VERSION_TYPE_GLOBAL;
const VERSION_TYPE VERSION_TYPE_MAX = VERSION_TYPE_TAIWAN;
const int VERSION_TYPE_ARRAYSIZE = VERSION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* VERSION_TYPE_descriptor();
inline const ::std::string& VERSION_TYPE_Name(VERSION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    VERSION_TYPE_descriptor(), value);
}
inline bool VERSION_TYPE_Parse(
    const ::std::string& name, VERSION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VERSION_TYPE>(
    VERSION_TYPE_descriptor(), name, value);
}
enum ASSET_TYPE {
  ASSET_TYPE_BEGIN = 1,
  ASSET_TYPE_ROOM = 2,
  ASSET_TYPE_COMMON_LIMIT = 3,
  ASSET_TYPE_COMMON_REWARD = 4,
  ASSET_TYPE_COOL_DOWN = 5,
  ASSET_TYPE_MJ_CARD = 6,
  ASSET_TYPE_COMMON_CONST = 7,
  ASSET_TYPE_LUCKY_PLATE = 8,
  ASSET_TYPE_DAILY_BONUS = 9,
  ASSET_TYPE_MALL = 10,
  ASSET_TYPE_ROOM_FAN = 11,
  ASSET_TYPE_ROOM_MODEL = 12,
  ASSET_TYPE_ROOM_OPEN = 13,
  ASSET_TYPE_VOICE_ALTER = 14,
  ASSET_TYPE_FACE = 15,
  ASSET_TYPE_AVATAR = 16,
  ASSET_TYPE_ACTIVITY = 17,
  ASSET_TYPE_DAILY_ALLOWANCE = 18,
  ASSET_TYPE_COMMON_CONSUME = 19,
  ASSET_TYPE_RECHARGE = 20,
  ASSET_TYPE_DAILY_SIGN = 21,
  ASSET_TYPE_COUNT = 200,
  ITEM_TYPE_BEGIN = 201,
  ITEM_TYPE_POTION = 202,
  ITEM_TYPE_ROOM_CARD = 203,
  ITEM_TYPE_NORMAL = 204
};
bool ASSET_TYPE_IsValid(int value);
const ASSET_TYPE ASSET_TYPE_MIN = ASSET_TYPE_BEGIN;
const ASSET_TYPE ASSET_TYPE_MAX = ITEM_TYPE_NORMAL;
const int ASSET_TYPE_ARRAYSIZE = ASSET_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASSET_TYPE_descriptor();
inline const ::std::string& ASSET_TYPE_Name(ASSET_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASSET_TYPE_descriptor(), value);
}
inline bool ASSET_TYPE_Parse(
    const ::std::string& name, ASSET_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASSET_TYPE>(
    ASSET_TYPE_descriptor(), name, value);
}
enum ROOM_TYPE {
  ROOM_TYPE_FRIEND = 1,
  ROOM_TYPE_XINSHOU = 2,
  ROOM_TYPE_GAOSHOU = 3,
  ROOM_TYPE_DASHI = 4
};
bool ROOM_TYPE_IsValid(int value);
const ROOM_TYPE ROOM_TYPE_MIN = ROOM_TYPE_FRIEND;
const ROOM_TYPE ROOM_TYPE_MAX = ROOM_TYPE_DASHI;
const int ROOM_TYPE_ARRAYSIZE = ROOM_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ROOM_TYPE_descriptor();
inline const ::std::string& ROOM_TYPE_Name(ROOM_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ROOM_TYPE_descriptor(), value);
}
inline bool ROOM_TYPE_Parse(
    const ::std::string& name, ROOM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ROOM_TYPE>(
    ROOM_TYPE_descriptor(), name, value);
}
enum CARD_TYPE {
  CARD_TYPE_WANZI = 1,
  CARD_TYPE_BINGZI = 2,
  CARD_TYPE_TIAOZI = 3,
  CARD_TYPE_FENG = 4,
  CARD_TYPE_JIAN = 5
};
bool CARD_TYPE_IsValid(int value);
const CARD_TYPE CARD_TYPE_MIN = CARD_TYPE_WANZI;
const CARD_TYPE CARD_TYPE_MAX = CARD_TYPE_JIAN;
const int CARD_TYPE_ARRAYSIZE = CARD_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CARD_TYPE_descriptor();
inline const ::std::string& CARD_TYPE_Name(CARD_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CARD_TYPE_descriptor(), value);
}
inline bool CARD_TYPE_Parse(
    const ::std::string& name, CARD_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CARD_TYPE>(
    CARD_TYPE_descriptor(), name, value);
}
enum FAN_TYPE {
  FAN_TYPE_ZHUANG = 1,
  FAN_TYPE_DIAN_PAO = 2,
  FAN_TYPE_ZI_MO = 3,
  FAN_TYPE_SHANG_TING = 4,
  FAN_TYPE_BIMEN = 5,
  FAN_TYPE_HAI_DI_LAO = 6,
  FAN_TYPE_GANG_SHANG_KAI = 7,
  FAN_TYPE_LIU_LEI = 8,
  FAN_TYPE_LOU_BAO = 9,
  FAN_TYPE_PIAO_HU = 10,
  FAN_TYPE_SI_GUI_YI = 11,
  FAN_TYPE_MING_PIAO = 12,
  FAN_TYPE_SAN_JIA_BI_MEN = 13,
  FAN_TYPE_QING_YI_SE = 14,
  FAN_TYPE_MING_GANG = 15,
  FAN_TYPE_AN_GANG = 16,
  FAN_TYPE_JIN_BAO = 17
};
bool FAN_TYPE_IsValid(int value);
const FAN_TYPE FAN_TYPE_MIN = FAN_TYPE_ZHUANG;
const FAN_TYPE FAN_TYPE_MAX = FAN_TYPE_JIN_BAO;
const int FAN_TYPE_ARRAYSIZE = FAN_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* FAN_TYPE_descriptor();
inline const ::std::string& FAN_TYPE_Name(FAN_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    FAN_TYPE_descriptor(), value);
}
inline bool FAN_TYPE_Parse(
    const ::std::string& name, FAN_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FAN_TYPE>(
    FAN_TYPE_descriptor(), name, value);
}
// ===================================================================

class AssetCommonProp : public ::google::protobuf::Message {
 public:
  AssetCommonProp();
  virtual ~AssetCommonProp();

  AssetCommonProp(const AssetCommonProp& from);

  inline AssetCommonProp& operator=(const AssetCommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetCommonProp& default_instance();

  void Swap(AssetCommonProp* other);

  // implements Message ----------------------------------------------

  AssetCommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetCommonProp& from);
  void MergeFrom(const AssetCommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 global_id = 1;
  inline bool has_global_id() const;
  inline void clear_global_id();
  static const int kGlobalIdFieldNumber = 1;
  inline ::google::protobuf::int64 global_id() const;
  inline void set_global_id(::google::protobuf::int64 value);

  // required .Adoter.Asset.VERSION_TYPE version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::Adoter::Asset::VERSION_TYPE version() const;
  inline void set_version(::Adoter::Asset::VERSION_TYPE value);

  // required bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes show_name = 4;
  inline bool has_show_name() const;
  inline void clear_show_name();
  static const int kShowNameFieldNumber = 4;
  inline const ::std::string& show_name() const;
  inline void set_show_name(const ::std::string& value);
  inline void set_show_name(const char* value);
  inline void set_show_name(const void* value, size_t size);
  inline ::std::string* mutable_show_name();
  inline ::std::string* release_show_name();
  inline void set_allocated_show_name(::std::string* show_name);

  // optional bytes desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.AssetCommonProp)
 private:
  inline void set_has_global_id();
  inline void clear_has_global_id();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_show_name();
  inline void clear_has_show_name();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 global_id_;
  ::std::string* name_;
  ::std::string* show_name_;
  ::std::string* desc_;
  int version_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static AssetCommonProp* default_instance_;
};
// -------------------------------------------------------------------

class RoomLimit : public ::google::protobuf::Message {
 public:
  RoomLimit();
  virtual ~RoomLimit();

  RoomLimit(const RoomLimit& from);

  inline RoomLimit& operator=(const RoomLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomLimit& default_instance();

  void Swap(RoomLimit* other);

  // implements Message ----------------------------------------------

  RoomLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomLimit& from);
  void MergeFrom(const RoomLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.ROOM_TYPE room_type = 3;
  inline bool has_room_type() const;
  inline void clear_room_type();
  static const int kRoomTypeFieldNumber = 3;
  inline ::Adoter::Asset::ROOM_TYPE room_type() const;
  inline void set_room_type(::Adoter::Asset::ROOM_TYPE value);

  // optional int32 min_limit = 4;
  inline bool has_min_limit() const;
  inline void clear_min_limit();
  static const int kMinLimitFieldNumber = 4;
  inline ::google::protobuf::int32 min_limit() const;
  inline void set_min_limit(::google::protobuf::int32 value);

  // optional int32 max_limit = 5;
  inline bool has_max_limit() const;
  inline void clear_max_limit();
  static const int kMaxLimitFieldNumber = 5;
  inline ::google::protobuf::int32 max_limit() const;
  inline void set_max_limit(::google::protobuf::int32 value);

  // optional int32 max_fan = 6;
  inline bool has_max_fan() const;
  inline void clear_max_fan();
  static const int kMaxFanFieldNumber = 6;
  inline ::google::protobuf::int32 max_fan() const;
  inline void set_max_fan(::google::protobuf::int32 value);

  // optional int32 cost_count = 7;
  inline bool has_cost_count() const;
  inline void clear_cost_count();
  static const int kCostCountFieldNumber = 7;
  inline ::google::protobuf::int32 cost_count() const;
  inline void set_cost_count(::google::protobuf::int32 value);

  // optional int32 base_count = 8;
  inline bool has_base_count() const;
  inline void clear_base_count();
  static const int kBaseCountFieldNumber = 8;
  inline ::google::protobuf::int32 base_count() const;
  inline void set_base_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomLimit)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_room_type();
  inline void clear_has_room_type();
  inline void set_has_min_limit();
  inline void clear_has_min_limit();
  inline void set_has_max_limit();
  inline void clear_has_max_limit();
  inline void set_has_max_fan();
  inline void clear_has_max_fan();
  inline void set_has_cost_count();
  inline void clear_has_cost_count();
  inline void set_has_base_count();
  inline void clear_has_base_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int room_type_;
  ::google::protobuf::int32 min_limit_;
  ::google::protobuf::int32 max_limit_;
  ::google::protobuf::int32 max_fan_;
  ::google::protobuf::int32 cost_count_;
  ::google::protobuf::int32 base_count_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static RoomLimit* default_instance_;
};
// -------------------------------------------------------------------

class CommonLimit : public ::google::protobuf::Message {
 public:
  CommonLimit();
  virtual ~CommonLimit();

  CommonLimit(const CommonLimit& from);

  inline CommonLimit& operator=(const CommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonLimit& default_instance();

  void Swap(CommonLimit* other);

  // implements Message ----------------------------------------------

  CommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonLimit& from);
  void MergeFrom(const CommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommonLimit_COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE;
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_PLANT = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT;
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_LUCKY_PLATE = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_LUCKY_PLATE;
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_DIALY_BONUS = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_DIALY_BONUS;
  static inline bool COMMON_LIMIT_TYPE_IsValid(int value) {
    return CommonLimit_COMMON_LIMIT_TYPE_IsValid(value);
  }
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_MIN =
    CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MIN;
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_MAX =
    CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MAX;
  static const int COMMON_LIMIT_TYPE_ARRAYSIZE =
    CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COMMON_LIMIT_TYPE_descriptor() {
    return CommonLimit_COMMON_LIMIT_TYPE_descriptor();
  }
  static inline const ::std::string& COMMON_LIMIT_TYPE_Name(COMMON_LIMIT_TYPE value) {
    return CommonLimit_COMMON_LIMIT_TYPE_Name(value);
  }
  static inline bool COMMON_LIMIT_TYPE_Parse(const ::std::string& name,
      COMMON_LIMIT_TYPE* value) {
    return CommonLimit_COMMON_LIMIT_TYPE_Parse(name, value);
  }

  typedef CommonLimit_COOL_DOWN_TYPE COOL_DOWN_TYPE;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_DAY = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_DAY;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_WEEK = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_WEEK;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_MONTH = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MONTH;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_YEAR = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_YEAR;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_NEVER = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_NEVER;
  static inline bool COOL_DOWN_TYPE_IsValid(int value) {
    return CommonLimit_COOL_DOWN_TYPE_IsValid(value);
  }
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_MIN =
    CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MIN;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_MAX =
    CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MAX;
  static const int COOL_DOWN_TYPE_ARRAYSIZE =
    CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COOL_DOWN_TYPE_descriptor() {
    return CommonLimit_COOL_DOWN_TYPE_descriptor();
  }
  static inline const ::std::string& COOL_DOWN_TYPE_Name(COOL_DOWN_TYPE value) {
    return CommonLimit_COOL_DOWN_TYPE_Name(value);
  }
  static inline bool COOL_DOWN_TYPE_Parse(const ::std::string& name,
      COOL_DOWN_TYPE* value) {
    return CommonLimit_COOL_DOWN_TYPE_Parse(name, value);
  }

  typedef CommonLimit_COOL_DOWN_CLEAR_TYPE COOL_DOWN_CLEAR_TYPE;
  static const COOL_DOWN_CLEAR_TYPE COOL_DOWN_CLEAR_TYPE_ZERO_TIME = CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_ZERO_TIME;
  static const COOL_DOWN_CLEAR_TYPE COOL_DOWN_CLEAR_TYPE_WHEN_OPER = CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_WHEN_OPER;
  static inline bool COOL_DOWN_CLEAR_TYPE_IsValid(int value) {
    return CommonLimit_COOL_DOWN_CLEAR_TYPE_IsValid(value);
  }
  static const COOL_DOWN_CLEAR_TYPE COOL_DOWN_CLEAR_TYPE_MIN =
    CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_MIN;
  static const COOL_DOWN_CLEAR_TYPE COOL_DOWN_CLEAR_TYPE_MAX =
    CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_MAX;
  static const int COOL_DOWN_CLEAR_TYPE_ARRAYSIZE =
    CommonLimit_COOL_DOWN_CLEAR_TYPE_COOL_DOWN_CLEAR_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COOL_DOWN_CLEAR_TYPE_descriptor() {
    return CommonLimit_COOL_DOWN_CLEAR_TYPE_descriptor();
  }
  static inline const ::std::string& COOL_DOWN_CLEAR_TYPE_Name(COOL_DOWN_CLEAR_TYPE value) {
    return CommonLimit_COOL_DOWN_CLEAR_TYPE_Name(value);
  }
  static inline bool COOL_DOWN_CLEAR_TYPE_Parse(const ::std::string& name,
      COOL_DOWN_CLEAR_TYPE* value) {
    return CommonLimit_COOL_DOWN_CLEAR_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_LIMIT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.CommonLimit.COMMON_LIMIT_TYPE limit_type = 3;
  inline bool has_limit_type() const;
  inline void clear_limit_type();
  static const int kLimitTypeFieldNumber = 3;
  inline ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE limit_type() const;
  inline void set_limit_type(::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE value);

  // optional .Adoter.Asset.CommonLimit.COOL_DOWN_TYPE cool_down_type = 4;
  inline bool has_cool_down_type() const;
  inline void clear_cool_down_type();
  static const int kCoolDownTypeFieldNumber = 4;
  inline ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE cool_down_type() const;
  inline void set_cool_down_type(::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE value);

  // optional .Adoter.Asset.CommonLimit.COOL_DOWN_CLEAR_TYPE cool_down_clear_type = 5;
  inline bool has_cool_down_clear_type() const;
  inline void clear_cool_down_clear_type();
  static const int kCoolDownClearTypeFieldNumber = 5;
  inline ::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE cool_down_clear_type() const;
  inline void set_cool_down_clear_type(::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE value);

  // optional int32 max_count = 6;
  inline bool has_max_count() const;
  inline void clear_max_count();
  static const int kMaxCountFieldNumber = 6;
  inline ::google::protobuf::int32 max_count() const;
  inline void set_max_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonLimit)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_limit_type();
  inline void clear_has_limit_type();
  inline void set_has_cool_down_type();
  inline void clear_has_cool_down_type();
  inline void set_has_cool_down_clear_type();
  inline void clear_has_cool_down_clear_type();
  inline void set_has_max_count();
  inline void clear_has_max_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int limit_type_;
  int cool_down_type_;
  int cool_down_clear_type_;
  ::google::protobuf::int32 max_count_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class CoolDown : public ::google::protobuf::Message {
 public:
  CoolDown();
  virtual ~CoolDown();

  CoolDown(const CoolDown& from);

  inline CoolDown& operator=(const CoolDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoolDown& default_instance();

  void Swap(CoolDown* other);

  // implements Message ----------------------------------------------

  CoolDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoolDown& from);
  void MergeFrom(const CoolDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CoolDown_COOL_DOWN_REASON COOL_DOWN_REASON;
  static const COOL_DOWN_REASON COOL_DOWN_REASON_NORMAL = CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_NORMAL;
  static inline bool COOL_DOWN_REASON_IsValid(int value) {
    return CoolDown_COOL_DOWN_REASON_IsValid(value);
  }
  static const COOL_DOWN_REASON COOL_DOWN_REASON_MIN =
    CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_MIN;
  static const COOL_DOWN_REASON COOL_DOWN_REASON_MAX =
    CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_MAX;
  static const int COOL_DOWN_REASON_ARRAYSIZE =
    CoolDown_COOL_DOWN_REASON_COOL_DOWN_REASON_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COOL_DOWN_REASON_descriptor() {
    return CoolDown_COOL_DOWN_REASON_descriptor();
  }
  static inline const ::std::string& COOL_DOWN_REASON_Name(COOL_DOWN_REASON value) {
    return CoolDown_COOL_DOWN_REASON_Name(value);
  }
  static inline bool COOL_DOWN_REASON_Parse(const ::std::string& name,
      COOL_DOWN_REASON* value) {
    return CoolDown_COOL_DOWN_REASON_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COOL_DOWN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CoolDown)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 duration_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CoolDown* default_instance_;
};
// -------------------------------------------------------------------

class MJCard_Card : public ::google::protobuf::Message {
 public:
  MJCard_Card();
  virtual ~MJCard_Card();

  MJCard_Card(const MJCard_Card& from);

  inline MJCard_Card& operator=(const MJCard_Card& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MJCard_Card& default_instance();

  void Swap(MJCard_Card* other);

  // implements Message ----------------------------------------------

  MJCard_Card* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJCard_Card& from);
  void MergeFrom(const MJCard_Card& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // optional bytes model_path = 2;
  inline bool has_model_path() const;
  inline void clear_model_path();
  static const int kModelPathFieldNumber = 2;
  inline const ::std::string& model_path() const;
  inline void set_model_path(const ::std::string& value);
  inline void set_model_path(const char* value);
  inline void set_model_path(const void* value, size_t size);
  inline ::std::string* mutable_model_path();
  inline ::std::string* release_model_path();
  inline void set_allocated_model_path(::std::string* model_path);

  // optional bytes voice_path = 3;
  inline bool has_voice_path() const;
  inline void clear_voice_path();
  static const int kVoicePathFieldNumber = 3;
  inline const ::std::string& voice_path() const;
  inline void set_voice_path(const ::std::string& value);
  inline void set_voice_path(const char* value);
  inline void set_voice_path(const void* value, size_t size);
  inline ::std::string* mutable_voice_path();
  inline ::std::string* release_voice_path();
  inline void set_allocated_voice_path(::std::string* voice_path);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MJCard.Card)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_model_path();
  inline void clear_has_model_path();
  inline void set_has_voice_path();
  inline void clear_has_voice_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* model_path_;
  ::std::string* voice_path_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static MJCard_Card* default_instance_;
};
// -------------------------------------------------------------------

class MJCard : public ::google::protobuf::Message {
 public:
  MJCard();
  virtual ~MJCard();

  MJCard(const MJCard& from);

  inline MJCard& operator=(const MJCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MJCard& default_instance();

  void Swap(MJCard* other);

  // implements Message ----------------------------------------------

  MJCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MJCard& from);
  void MergeFrom(const MJCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MJCard_Card Card;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_MJ_CARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.CARD_TYPE card_type = 3;
  inline bool has_card_type() const;
  inline void clear_card_type();
  static const int kCardTypeFieldNumber = 3;
  inline ::Adoter::Asset::CARD_TYPE card_type() const;
  inline void set_card_type(::Adoter::Asset::CARD_TYPE value);

  // optional int32 group_count = 4 [default = 4];
  inline bool has_group_count() const;
  inline void clear_group_count();
  static const int kGroupCountFieldNumber = 4;
  inline ::google::protobuf::int32 group_count() const;
  inline void set_group_count(::google::protobuf::int32 value);

  // optional int32 cards_count = 5 [default = 9];
  inline bool has_cards_count() const;
  inline void clear_cards_count();
  static const int kCardsCountFieldNumber = 5;
  inline ::google::protobuf::int32 cards_count() const;
  inline void set_cards_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.MJCard.Card cards = 6;
  inline int cards_size() const;
  inline void clear_cards();
  static const int kCardsFieldNumber = 6;
  inline const ::Adoter::Asset::MJCard_Card& cards(int index) const;
  inline ::Adoter::Asset::MJCard_Card* mutable_cards(int index);
  inline ::Adoter::Asset::MJCard_Card* add_cards();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MJCard_Card >&
      cards() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MJCard_Card >*
      mutable_cards();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.MJCard)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_card_type();
  inline void clear_has_card_type();
  inline void set_has_group_count();
  inline void clear_has_group_count();
  inline void set_has_cards_count();
  inline void clear_has_cards_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int card_type_;
  ::google::protobuf::int32 group_count_;
  ::google::protobuf::int32 cards_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MJCard_Card > cards_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static MJCard* default_instance_;
};
// -------------------------------------------------------------------

class CommonConst : public ::google::protobuf::Message {
 public:
  CommonConst();
  virtual ~CommonConst();

  CommonConst(const CommonConst& from);

  inline CommonConst& operator=(const CommonConst& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonConst& default_instance();

  void Swap(CommonConst* other);

  // implements Message ----------------------------------------------

  CommonConst* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonConst& from);
  void MergeFrom(const CommonConst& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_CONST];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 max_cards_count = 3 [default = 136];
  inline bool has_max_cards_count() const;
  inline void clear_max_cards_count();
  static const int kMaxCardsCountFieldNumber = 3;
  inline ::google::protobuf::int32 max_cards_count() const;
  inline void set_max_cards_count(::google::protobuf::int32 value);

  // optional int64 daily_bonus_id = 4;
  inline bool has_daily_bonus_id() const;
  inline void clear_daily_bonus_id();
  static const int kDailyBonusIdFieldNumber = 4;
  inline ::google::protobuf::int64 daily_bonus_id() const;
  inline void set_daily_bonus_id(::google::protobuf::int64 value);

  // optional int64 daily_allowance_id = 5;
  inline bool has_daily_allowance_id() const;
  inline void clear_daily_allowance_id();
  static const int kDailyAllowanceIdFieldNumber = 5;
  inline ::google::protobuf::int64 daily_allowance_id() const;
  inline void set_daily_allowance_id(::google::protobuf::int64 value);

  // optional int32 time_out = 6 [default = 8];
  inline bool has_time_out() const;
  inline void clear_time_out();
  static const int kTimeOutFieldNumber = 6;
  inline ::google::protobuf::int32 time_out() const;
  inline void set_time_out(::google::protobuf::int32 value);

  // optional int64 daily_sign_id = 7;
  inline bool has_daily_sign_id() const;
  inline void clear_daily_sign_id();
  static const int kDailySignIdFieldNumber = 7;
  inline ::google::protobuf::int64 daily_sign_id() const;
  inline void set_daily_sign_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonConst)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_max_cards_count();
  inline void clear_has_max_cards_count();
  inline void set_has_daily_bonus_id();
  inline void clear_has_daily_bonus_id();
  inline void set_has_daily_allowance_id();
  inline void clear_has_daily_allowance_id();
  inline void set_has_time_out();
  inline void clear_has_time_out();
  inline void set_has_daily_sign_id();
  inline void clear_has_daily_sign_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 max_cards_count_;
  ::google::protobuf::int64 daily_bonus_id_;
  ::google::protobuf::int64 daily_allowance_id_;
  ::google::protobuf::int64 daily_sign_id_;
  ::google::protobuf::int32 time_out_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonConst* default_instance_;
};
// -------------------------------------------------------------------

class CommonReward_Reward : public ::google::protobuf::Message {
 public:
  CommonReward_Reward();
  virtual ~CommonReward_Reward();

  CommonReward_Reward(const CommonReward_Reward& from);

  inline CommonReward_Reward& operator=(const CommonReward_Reward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonReward_Reward& default_instance();

  void Swap(CommonReward_Reward* other);

  // implements Message ----------------------------------------------

  CommonReward_Reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonReward_Reward& from);
  void MergeFrom(const CommonReward_Reward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CommonReward.REWARD_TYPE reward_type = 1;
  inline bool has_reward_type() const;
  inline void clear_reward_type();
  static const int kRewardTypeFieldNumber = 1;
  inline ::Adoter::Asset::CommonReward_REWARD_TYPE reward_type() const;
  inline void set_reward_type(::Adoter::Asset::CommonReward_REWARD_TYPE value);

  // optional bytes comments = 2;
  inline bool has_comments() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 2;
  inline const ::std::string& comments() const;
  inline void set_comments(const ::std::string& value);
  inline void set_comments(const char* value);
  inline void set_comments(const void* value, size_t size);
  inline ::std::string* mutable_comments();
  inline ::std::string* release_comments();
  inline void set_allocated_comments(::std::string* comments);

  // optional bytes icon_name = 3;
  inline bool has_icon_name() const;
  inline void clear_icon_name();
  static const int kIconNameFieldNumber = 3;
  inline const ::std::string& icon_name() const;
  inline void set_icon_name(const ::std::string& value);
  inline void set_icon_name(const char* value);
  inline void set_icon_name(const void* value, size_t size);
  inline ::std::string* mutable_icon_name();
  inline ::std::string* release_icon_name();
  inline void set_allocated_icon_name(::std::string* icon_name);

  // optional int64 item_id = 4;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::int64 item_id() const;
  inline void set_item_id(::google::protobuf::int64 value);

  // optional int32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int64 common_limit_id = 6;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 6;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonReward.Reward)
 private:
  inline void set_has_reward_type();
  inline void clear_has_reward_type();
  inline void set_has_comments();
  inline void clear_has_comments();
  inline void set_has_icon_name();
  inline void clear_has_icon_name();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* comments_;
  ::std::string* icon_name_;
  int reward_type_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int64 item_id_;
  ::google::protobuf::int64 common_limit_id_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonReward_Reward* default_instance_;
};
// -------------------------------------------------------------------

class CommonReward : public ::google::protobuf::Message {
 public:
  CommonReward();
  virtual ~CommonReward();

  CommonReward(const CommonReward& from);

  inline CommonReward& operator=(const CommonReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonReward& default_instance();

  void Swap(CommonReward* other);

  // implements Message ----------------------------------------------

  CommonReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonReward& from);
  void MergeFrom(const CommonReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommonReward_Reward Reward;

  typedef CommonReward_REWARD_TYPE REWARD_TYPE;
  static const REWARD_TYPE REWARD_TYPE_DIAMOND = CommonReward_REWARD_TYPE_REWARD_TYPE_DIAMOND;
  static const REWARD_TYPE REWARD_TYPE_HUANLEDOU = CommonReward_REWARD_TYPE_REWARD_TYPE_HUANLEDOU;
  static const REWARD_TYPE REWARD_TYPE_ITEM = CommonReward_REWARD_TYPE_REWARD_TYPE_ITEM;
  static inline bool REWARD_TYPE_IsValid(int value) {
    return CommonReward_REWARD_TYPE_IsValid(value);
  }
  static const REWARD_TYPE REWARD_TYPE_MIN =
    CommonReward_REWARD_TYPE_REWARD_TYPE_MIN;
  static const REWARD_TYPE REWARD_TYPE_MAX =
    CommonReward_REWARD_TYPE_REWARD_TYPE_MAX;
  static const int REWARD_TYPE_ARRAYSIZE =
    CommonReward_REWARD_TYPE_REWARD_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  REWARD_TYPE_descriptor() {
    return CommonReward_REWARD_TYPE_descriptor();
  }
  static inline const ::std::string& REWARD_TYPE_Name(REWARD_TYPE value) {
    return CommonReward_REWARD_TYPE_Name(value);
  }
  static inline bool REWARD_TYPE_Parse(const ::std::string& name,
      REWARD_TYPE* value) {
    return CommonReward_REWARD_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_REWARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 rewards_count = 3 [default = 10];
  inline bool has_rewards_count() const;
  inline void clear_rewards_count();
  static const int kRewardsCountFieldNumber = 3;
  inline ::google::protobuf::int32 rewards_count() const;
  inline void set_rewards_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.CommonReward.Reward rewards = 4;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 4;
  inline const ::Adoter::Asset::CommonReward_Reward& rewards(int index) const;
  inline ::Adoter::Asset::CommonReward_Reward* mutable_rewards(int index);
  inline ::Adoter::Asset::CommonReward_Reward* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonReward_Reward >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonReward_Reward >*
      mutable_rewards();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonReward)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_rewards_count();
  inline void clear_has_rewards_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 rewards_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonReward_Reward > rewards_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonReward* default_instance_;
};
// -------------------------------------------------------------------

class CommonConsume_Element : public ::google::protobuf::Message {
 public:
  CommonConsume_Element();
  virtual ~CommonConsume_Element();

  CommonConsume_Element(const CommonConsume_Element& from);

  inline CommonConsume_Element& operator=(const CommonConsume_Element& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonConsume_Element& default_instance();

  void Swap(CommonConsume_Element* other);

  // implements Message ----------------------------------------------

  CommonConsume_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonConsume_Element& from);
  void MergeFrom(const CommonConsume_Element& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.CommonConsume.CONSUME_TYPE consume_type = 1;
  inline bool has_consume_type() const;
  inline void clear_consume_type();
  static const int kConsumeTypeFieldNumber = 1;
  inline ::Adoter::Asset::CommonConsume_CONSUME_TYPE consume_type() const;
  inline void set_consume_type(::Adoter::Asset::CommonConsume_CONSUME_TYPE value);

  // optional int32 item_id = 2;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 consume_count = 3;
  inline bool has_consume_count() const;
  inline void clear_consume_count();
  static const int kConsumeCountFieldNumber = 3;
  inline ::google::protobuf::int32 consume_count() const;
  inline void set_consume_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonConsume.Element)
 private:
  inline void set_has_consume_type();
  inline void clear_has_consume_type();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_consume_count();
  inline void clear_has_consume_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int consume_type_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 consume_count_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonConsume_Element* default_instance_;
};
// -------------------------------------------------------------------

class CommonConsume : public ::google::protobuf::Message {
 public:
  CommonConsume();
  virtual ~CommonConsume();

  CommonConsume(const CommonConsume& from);

  inline CommonConsume& operator=(const CommonConsume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonConsume& default_instance();

  void Swap(CommonConsume* other);

  // implements Message ----------------------------------------------

  CommonConsume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonConsume& from);
  void MergeFrom(const CommonConsume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommonConsume_Element Element;

  typedef CommonConsume_CONSUME_TYPE CONSUME_TYPE;
  static const CONSUME_TYPE CONSUME_TYPE_DIAMOND = CommonConsume_CONSUME_TYPE_CONSUME_TYPE_DIAMOND;
  static const CONSUME_TYPE CONSUME_TYPE_HUANLEDOU = CommonConsume_CONSUME_TYPE_CONSUME_TYPE_HUANLEDOU;
  static const CONSUME_TYPE CONSUME_TYPE_ITEM = CommonConsume_CONSUME_TYPE_CONSUME_TYPE_ITEM;
  static inline bool CONSUME_TYPE_IsValid(int value) {
    return CommonConsume_CONSUME_TYPE_IsValid(value);
  }
  static const CONSUME_TYPE CONSUME_TYPE_MIN =
    CommonConsume_CONSUME_TYPE_CONSUME_TYPE_MIN;
  static const CONSUME_TYPE CONSUME_TYPE_MAX =
    CommonConsume_CONSUME_TYPE_CONSUME_TYPE_MAX;
  static const int CONSUME_TYPE_ARRAYSIZE =
    CommonConsume_CONSUME_TYPE_CONSUME_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONSUME_TYPE_descriptor() {
    return CommonConsume_CONSUME_TYPE_descriptor();
  }
  static inline const ::std::string& CONSUME_TYPE_Name(CONSUME_TYPE value) {
    return CommonConsume_CONSUME_TYPE_Name(value);
  }
  static inline bool CONSUME_TYPE_Parse(const ::std::string& name,
      CONSUME_TYPE* value) {
    return CommonConsume_CONSUME_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_CONSUME];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 elements_count = 3 [default = 3];
  inline bool has_elements_count() const;
  inline void clear_elements_count();
  static const int kElementsCountFieldNumber = 3;
  inline ::google::protobuf::int32 elements_count() const;
  inline void set_elements_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.CommonConsume.Element elements = 4;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 4;
  inline const ::Adoter::Asset::CommonConsume_Element& elements(int index) const;
  inline ::Adoter::Asset::CommonConsume_Element* mutable_elements(int index);
  inline ::Adoter::Asset::CommonConsume_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonConsume_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonConsume_Element >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonConsume)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_elements_count();
  inline void clear_has_elements_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 elements_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonConsume_Element > elements_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonConsume* default_instance_;
};
// -------------------------------------------------------------------

class LuckyPlate_Plate : public ::google::protobuf::Message {
 public:
  LuckyPlate_Plate();
  virtual ~LuckyPlate_Plate();

  LuckyPlate_Plate(const LuckyPlate_Plate& from);

  inline LuckyPlate_Plate& operator=(const LuckyPlate_Plate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LuckyPlate_Plate& default_instance();

  void Swap(LuckyPlate_Plate* other);

  // implements Message ----------------------------------------------

  LuckyPlate_Plate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LuckyPlate_Plate& from);
  void MergeFrom(const LuckyPlate_Plate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional int64 common_reward_id = 2;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 2;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LuckyPlate.Plate)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_reward_id_;
  ::google::protobuf::int32 weight_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static LuckyPlate_Plate* default_instance_;
};
// -------------------------------------------------------------------

class LuckyPlate : public ::google::protobuf::Message {
 public:
  LuckyPlate();
  virtual ~LuckyPlate();

  LuckyPlate(const LuckyPlate& from);

  inline LuckyPlate& operator=(const LuckyPlate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LuckyPlate& default_instance();

  void Swap(LuckyPlate* other);

  // implements Message ----------------------------------------------

  LuckyPlate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LuckyPlate& from);
  void MergeFrom(const LuckyPlate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LuckyPlate_Plate Plate;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_LUCKY_PLATE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 plates_count = 3 [default = 10];
  inline bool has_plates_count() const;
  inline void clear_plates_count();
  static const int kPlatesCountFieldNumber = 3;
  inline ::google::protobuf::int32 plates_count() const;
  inline void set_plates_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.LuckyPlate.Plate plates = 4;
  inline int plates_size() const;
  inline void clear_plates();
  static const int kPlatesFieldNumber = 4;
  inline const ::Adoter::Asset::LuckyPlate_Plate& plates(int index) const;
  inline ::Adoter::Asset::LuckyPlate_Plate* mutable_plates(int index);
  inline ::Adoter::Asset::LuckyPlate_Plate* add_plates();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LuckyPlate_Plate >&
      plates() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LuckyPlate_Plate >*
      mutable_plates();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LuckyPlate)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_plates_count();
  inline void clear_has_plates_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 plates_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LuckyPlate_Plate > plates_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static LuckyPlate* default_instance_;
};
// -------------------------------------------------------------------

class DailyBonus : public ::google::protobuf::Message {
 public:
  DailyBonus();
  virtual ~DailyBonus();

  DailyBonus(const DailyBonus& from);

  inline DailyBonus& operator=(const DailyBonus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyBonus& default_instance();

  void Swap(DailyBonus* other);

  // implements Message ----------------------------------------------

  DailyBonus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailyBonus& from);
  void MergeFrom(const DailyBonus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_DAILY_BONUS];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int64 common_reward_id = 3;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 3;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // optional int64 common_limit_id = 4;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 4;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.DailyBonus)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  ::google::protobuf::int64 common_reward_id_;
  ::google::protobuf::int64 common_limit_id_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static DailyBonus* default_instance_;
};
// -------------------------------------------------------------------

class Mall : public ::google::protobuf::Message {
 public:
  Mall();
  virtual ~Mall();

  Mall(const Mall& from);

  inline Mall& operator=(const Mall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mall& default_instance();

  void Swap(Mall* other);

  // implements Message ----------------------------------------------

  Mall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mall& from);
  void MergeFrom(const Mall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Mall_GOODS_TYPE GOODS_TYPE;
  static const GOODS_TYPE GOODS_TYPE_HUANLEDOU = Mall_GOODS_TYPE_GOODS_TYPE_HUANLEDOU;
  static const GOODS_TYPE GOODS_TYPE_NORMAL_ITEM = Mall_GOODS_TYPE_GOODS_TYPE_NORMAL_ITEM;
  static inline bool GOODS_TYPE_IsValid(int value) {
    return Mall_GOODS_TYPE_IsValid(value);
  }
  static const GOODS_TYPE GOODS_TYPE_MIN =
    Mall_GOODS_TYPE_GOODS_TYPE_MIN;
  static const GOODS_TYPE GOODS_TYPE_MAX =
    Mall_GOODS_TYPE_GOODS_TYPE_MAX;
  static const int GOODS_TYPE_ARRAYSIZE =
    Mall_GOODS_TYPE_GOODS_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GOODS_TYPE_descriptor() {
    return Mall_GOODS_TYPE_descriptor();
  }
  static inline const ::std::string& GOODS_TYPE_Name(GOODS_TYPE value) {
    return Mall_GOODS_TYPE_Name(value);
  }
  static inline bool GOODS_TYPE_Parse(const ::std::string& name,
      GOODS_TYPE* value) {
    return Mall_GOODS_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_MALL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.Mall.GOODS_TYPE goods_type = 3;
  inline bool has_goods_type() const;
  inline void clear_goods_type();
  static const int kGoodsTypeFieldNumber = 3;
  inline ::Adoter::Asset::Mall_GOODS_TYPE goods_type() const;
  inline void set_goods_type(::Adoter::Asset::Mall_GOODS_TYPE value);

  // optional int64 item_id = 4;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::int64 item_id() const;
  inline void set_item_id(::google::protobuf::int64 value);

  // optional int32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 diamond = 6;
  inline bool has_diamond() const;
  inline void clear_diamond();
  static const int kDiamondFieldNumber = 6;
  inline ::google::protobuf::int32 diamond() const;
  inline void set_diamond(::google::protobuf::int32 value);

  // optional int32 diamond_show = 7;
  inline bool has_diamond_show() const;
  inline void clear_diamond_show();
  static const int kDiamondShowFieldNumber = 7;
  inline ::google::protobuf::int32 diamond_show() const;
  inline void set_diamond_show(::google::protobuf::int32 value);

  // optional int32 huanledou = 8;
  inline bool has_huanledou() const;
  inline void clear_huanledou();
  static const int kHuanledouFieldNumber = 8;
  inline ::google::protobuf::int32 huanledou() const;
  inline void set_huanledou(::google::protobuf::int32 value);

  // optional int32 huanledou_show = 9;
  inline bool has_huanledou_show() const;
  inline void clear_huanledou_show();
  static const int kHuanledouShowFieldNumber = 9;
  inline ::google::protobuf::int32 huanledou_show() const;
  inline void set_huanledou_show(::google::protobuf::int32 value);

  // optional int64 activity_id = 10;
  inline bool has_activity_id() const;
  inline void clear_activity_id();
  static const int kActivityIdFieldNumber = 10;
  inline ::google::protobuf::int64 activity_id() const;
  inline void set_activity_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Mall)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_goods_type();
  inline void clear_has_goods_type();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_diamond();
  inline void clear_has_diamond();
  inline void set_has_diamond_show();
  inline void clear_has_diamond_show();
  inline void set_has_huanledou();
  inline void clear_has_huanledou();
  inline void set_has_huanledou_show();
  inline void clear_has_huanledou_show();
  inline void set_has_activity_id();
  inline void clear_has_activity_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int goods_type_;
  ::google::protobuf::int64 item_id_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 diamond_;
  ::google::protobuf::int32 diamond_show_;
  ::google::protobuf::int32 huanledou_;
  ::google::protobuf::int64 activity_id_;
  ::google::protobuf::int32 huanledou_show_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Mall* default_instance_;
};
// -------------------------------------------------------------------

class RoomFan_FanElement : public ::google::protobuf::Message {
 public:
  RoomFan_FanElement();
  virtual ~RoomFan_FanElement();

  RoomFan_FanElement(const RoomFan_FanElement& from);

  inline RoomFan_FanElement& operator=(const RoomFan_FanElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomFan_FanElement& default_instance();

  void Swap(RoomFan_FanElement* other);

  // implements Message ----------------------------------------------

  RoomFan_FanElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomFan_FanElement& from);
  void MergeFrom(const RoomFan_FanElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.FAN_TYPE fan_type = 3;
  inline bool has_fan_type() const;
  inline void clear_fan_type();
  static const int kFanTypeFieldNumber = 3;
  inline ::Adoter::Asset::FAN_TYPE fan_type() const;
  inline void set_fan_type(::Adoter::Asset::FAN_TYPE value);

  // optional bytes name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 multiple = 5;
  inline bool has_multiple() const;
  inline void clear_multiple();
  static const int kMultipleFieldNumber = 5;
  inline ::google::protobuf::int32 multiple() const;
  inline void set_multiple(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomFan.FanElement)
 private:
  inline void set_has_fan_type();
  inline void clear_has_fan_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_multiple();
  inline void clear_has_multiple();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  int fan_type_;
  ::google::protobuf::int32 multiple_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static RoomFan_FanElement* default_instance_;
};
// -------------------------------------------------------------------

class RoomFan : public ::google::protobuf::Message {
 public:
  RoomFan();
  virtual ~RoomFan();

  RoomFan(const RoomFan& from);

  inline RoomFan& operator=(const RoomFan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomFan& default_instance();

  void Swap(RoomFan* other);

  // implements Message ----------------------------------------------

  RoomFan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomFan& from);
  void MergeFrom(const RoomFan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomFan_FanElement FanElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM_FAN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 fans_count = 3 [default = 20];
  inline bool has_fans_count() const;
  inline void clear_fans_count();
  static const int kFansCountFieldNumber = 3;
  inline ::google::protobuf::int32 fans_count() const;
  inline void set_fans_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.RoomFan.FanElement fans = 4;
  inline int fans_size() const;
  inline void clear_fans();
  static const int kFansFieldNumber = 4;
  inline const ::Adoter::Asset::RoomFan_FanElement& fans(int index) const;
  inline ::Adoter::Asset::RoomFan_FanElement* mutable_fans(int index);
  inline ::Adoter::Asset::RoomFan_FanElement* add_fans();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomFan_FanElement >&
      fans() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomFan_FanElement >*
      mutable_fans();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomFan)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_fans_count();
  inline void clear_has_fans_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 fans_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomFan_FanElement > fans_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static RoomFan* default_instance_;
};
// -------------------------------------------------------------------

class RoomModel : public ::google::protobuf::Message {
 public:
  RoomModel();
  virtual ~RoomModel();

  RoomModel(const RoomModel& from);

  inline RoomModel& operator=(const RoomModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomModel& default_instance();

  void Swap(RoomModel* other);

  // implements Message ----------------------------------------------

  RoomModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomModel& from);
  void MergeFrom(const RoomModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM_MODEL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomModel)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static RoomModel* default_instance_;
};
// -------------------------------------------------------------------

class RoomOpen_CardCost : public ::google::protobuf::Message {
 public:
  RoomOpen_CardCost();
  virtual ~RoomOpen_CardCost();

  RoomOpen_CardCost(const RoomOpen_CardCost& from);

  inline RoomOpen_CardCost& operator=(const RoomOpen_CardCost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomOpen_CardCost& default_instance();

  void Swap(RoomOpen_CardCost* other);

  // implements Message ----------------------------------------------

  RoomOpen_CardCost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomOpen_CardCost& from);
  void MergeFrom(const RoomOpen_CardCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rounds = 1;
  inline bool has_rounds() const;
  inline void clear_rounds();
  static const int kRoundsFieldNumber = 1;
  inline ::google::protobuf::int32 rounds() const;
  inline void set_rounds(::google::protobuf::int32 value);

  // optional int32 room_cards_count = 2;
  inline bool has_room_cards_count() const;
  inline void clear_room_cards_count();
  static const int kRoomCardsCountFieldNumber = 2;
  inline ::google::protobuf::int32 room_cards_count() const;
  inline void set_room_cards_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomOpen.CardCost)
 private:
  inline void set_has_rounds();
  inline void clear_has_rounds();
  inline void set_has_room_cards_count();
  inline void clear_has_room_cards_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 rounds_;
  ::google::protobuf::int32 room_cards_count_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static RoomOpen_CardCost* default_instance_;
};
// -------------------------------------------------------------------

class RoomOpen : public ::google::protobuf::Message {
 public:
  RoomOpen();
  virtual ~RoomOpen();

  RoomOpen(const RoomOpen& from);

  inline RoomOpen& operator=(const RoomOpen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomOpen& default_instance();

  void Swap(RoomOpen* other);

  // implements Message ----------------------------------------------

  RoomOpen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomOpen& from);
  void MergeFrom(const RoomOpen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomOpen_CardCost CardCost;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM_OPEN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 costs_count = 3 [default = 10];
  inline bool has_costs_count() const;
  inline void clear_costs_count();
  static const int kCostsCountFieldNumber = 3;
  inline ::google::protobuf::int32 costs_count() const;
  inline void set_costs_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.RoomOpen.CardCost costs = 4;
  inline int costs_size() const;
  inline void clear_costs();
  static const int kCostsFieldNumber = 4;
  inline const ::Adoter::Asset::RoomOpen_CardCost& costs(int index) const;
  inline ::Adoter::Asset::RoomOpen_CardCost* mutable_costs(int index);
  inline ::Adoter::Asset::RoomOpen_CardCost* add_costs();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomOpen_CardCost >&
      costs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomOpen_CardCost >*
      mutable_costs();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.RoomOpen)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_costs_count();
  inline void clear_has_costs_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 costs_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomOpen_CardCost > costs_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static RoomOpen* default_instance_;
};
// -------------------------------------------------------------------

class VoiceAlter_VoiceElement : public ::google::protobuf::Message {
 public:
  VoiceAlter_VoiceElement();
  virtual ~VoiceAlter_VoiceElement();

  VoiceAlter_VoiceElement(const VoiceAlter_VoiceElement& from);

  inline VoiceAlter_VoiceElement& operator=(const VoiceAlter_VoiceElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceAlter_VoiceElement& default_instance();

  void Swap(VoiceAlter_VoiceElement* other);

  // implements Message ----------------------------------------------

  VoiceAlter_VoiceElement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoiceAlter_VoiceElement& from);
  void MergeFrom(const VoiceAlter_VoiceElement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes voice_path = 2;
  inline bool has_voice_path() const;
  inline void clear_voice_path();
  static const int kVoicePathFieldNumber = 2;
  inline const ::std::string& voice_path() const;
  inline void set_voice_path(const ::std::string& value);
  inline void set_voice_path(const char* value);
  inline void set_voice_path(const void* value, size_t size);
  inline ::std::string* mutable_voice_path();
  inline ::std::string* release_voice_path();
  inline void set_allocated_voice_path(::std::string* voice_path);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.VoiceAlter.VoiceElement)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_voice_path();
  inline void clear_has_voice_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* voice_path_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static VoiceAlter_VoiceElement* default_instance_;
};
// -------------------------------------------------------------------

class VoiceAlter : public ::google::protobuf::Message {
 public:
  VoiceAlter();
  virtual ~VoiceAlter();

  VoiceAlter(const VoiceAlter& from);

  inline VoiceAlter& operator=(const VoiceAlter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceAlter& default_instance();

  void Swap(VoiceAlter* other);

  // implements Message ----------------------------------------------

  VoiceAlter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoiceAlter& from);
  void MergeFrom(const VoiceAlter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VoiceAlter_VoiceElement VoiceElement;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_VOICE_ALTER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 voices_count = 3 [default = 10];
  inline bool has_voices_count() const;
  inline void clear_voices_count();
  static const int kVoicesCountFieldNumber = 3;
  inline ::google::protobuf::int32 voices_count() const;
  inline void set_voices_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.VoiceAlter.VoiceElement voices = 4;
  inline int voices_size() const;
  inline void clear_voices();
  static const int kVoicesFieldNumber = 4;
  inline const ::Adoter::Asset::VoiceAlter_VoiceElement& voices(int index) const;
  inline ::Adoter::Asset::VoiceAlter_VoiceElement* mutable_voices(int index);
  inline ::Adoter::Asset::VoiceAlter_VoiceElement* add_voices();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::VoiceAlter_VoiceElement >&
      voices() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::VoiceAlter_VoiceElement >*
      mutable_voices();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.VoiceAlter)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_voices_count();
  inline void clear_has_voices_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 voices_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::VoiceAlter_VoiceElement > voices_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static VoiceAlter* default_instance_;
};
// -------------------------------------------------------------------

class Face : public ::google::protobuf::Message {
 public:
  Face();
  virtual ~Face();

  Face(const Face& from);

  inline Face& operator=(const Face& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Face& default_instance();

  void Swap(Face* other);

  // implements Message ----------------------------------------------

  Face* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Face& from);
  void MergeFrom(const Face& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_FACE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 faces_count = 3 [default = 20];
  inline bool has_faces_count() const;
  inline void clear_faces_count();
  static const int kFacesCountFieldNumber = 3;
  inline ::google::protobuf::int32 faces_count() const;
  inline void set_faces_count(::google::protobuf::int32 value);

  // repeated bytes faces = 4;
  inline int faces_size() const;
  inline void clear_faces();
  static const int kFacesFieldNumber = 4;
  inline const ::std::string& faces(int index) const;
  inline ::std::string* mutable_faces(int index);
  inline void set_faces(int index, const ::std::string& value);
  inline void set_faces(int index, const char* value);
  inline void set_faces(int index, const void* value, size_t size);
  inline ::std::string* add_faces();
  inline void add_faces(const ::std::string& value);
  inline void add_faces(const char* value);
  inline void add_faces(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& faces() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_faces();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Face)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_faces_count();
  inline void clear_has_faces_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 faces_count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> faces_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Face* default_instance_;
};
// -------------------------------------------------------------------

class Avatar : public ::google::protobuf::Message {
 public:
  Avatar();
  virtual ~Avatar();

  Avatar(const Avatar& from);

  inline Avatar& operator=(const Avatar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Avatar& default_instance();

  void Swap(Avatar* other);

  // implements Message ----------------------------------------------

  Avatar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Avatar& from);
  void MergeFrom(const Avatar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_AVATAR];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 avatars_count = 3 [default = 20];
  inline bool has_avatars_count() const;
  inline void clear_avatars_count();
  static const int kAvatarsCountFieldNumber = 3;
  inline ::google::protobuf::int32 avatars_count() const;
  inline void set_avatars_count(::google::protobuf::int32 value);

  // repeated bytes avatars = 4;
  inline int avatars_size() const;
  inline void clear_avatars();
  static const int kAvatarsFieldNumber = 4;
  inline const ::std::string& avatars(int index) const;
  inline ::std::string* mutable_avatars(int index);
  inline void set_avatars(int index, const ::std::string& value);
  inline void set_avatars(int index, const char* value);
  inline void set_avatars(int index, const void* value, size_t size);
  inline ::std::string* add_avatars();
  inline void add_avatars(const ::std::string& value);
  inline void add_avatars(const char* value);
  inline void add_avatars(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& avatars() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_avatars();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Avatar)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_avatars_count();
  inline void clear_has_avatars_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 avatars_count_;
  ::google::protobuf::RepeatedPtrField< ::std::string> avatars_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Avatar* default_instance_;
};
// -------------------------------------------------------------------

class Activity : public ::google::protobuf::Message {
 public:
  Activity();
  virtual ~Activity();

  Activity(const Activity& from);

  inline Activity& operator=(const Activity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Activity& default_instance();

  void Swap(Activity* other);

  // implements Message ----------------------------------------------

  Activity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Activity& from);
  void MergeFrom(const Activity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Activity_ACTIVITY_TYPE ACTIVITY_TYPE;
  static const ACTIVITY_TYPE ACTIVITY_TYPE_STOP_TIME = Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_STOP_TIME;
  static inline bool ACTIVITY_TYPE_IsValid(int value) {
    return Activity_ACTIVITY_TYPE_IsValid(value);
  }
  static const ACTIVITY_TYPE ACTIVITY_TYPE_MIN =
    Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_MIN;
  static const ACTIVITY_TYPE ACTIVITY_TYPE_MAX =
    Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_MAX;
  static const int ACTIVITY_TYPE_ARRAYSIZE =
    Activity_ACTIVITY_TYPE_ACTIVITY_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ACTIVITY_TYPE_descriptor() {
    return Activity_ACTIVITY_TYPE_descriptor();
  }
  static inline const ::std::string& ACTIVITY_TYPE_Name(ACTIVITY_TYPE value) {
    return Activity_ACTIVITY_TYPE_Name(value);
  }
  static inline bool ACTIVITY_TYPE_Parse(const ::std::string& name,
      ACTIVITY_TYPE* value) {
    return Activity_ACTIVITY_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ACTIVITY];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.Activity.ACTIVITY_TYPE activity_type = 3;
  inline bool has_activity_type() const;
  inline void clear_activity_type();
  static const int kActivityTypeFieldNumber = 3;
  inline ::Adoter::Asset::Activity_ACTIVITY_TYPE activity_type() const;
  inline void set_activity_type(::Adoter::Asset::Activity_ACTIVITY_TYPE value);

  // optional bytes start_time = 4;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const void* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // optional bytes stop_time = 5;
  inline bool has_stop_time() const;
  inline void clear_stop_time();
  static const int kStopTimeFieldNumber = 5;
  inline const ::std::string& stop_time() const;
  inline void set_stop_time(const ::std::string& value);
  inline void set_stop_time(const char* value);
  inline void set_stop_time(const void* value, size_t size);
  inline ::std::string* mutable_stop_time();
  inline ::std::string* release_stop_time();
  inline void set_allocated_stop_time(::std::string* stop_time);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Activity)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_activity_type();
  inline void clear_has_activity_type();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_stop_time();
  inline void clear_has_stop_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int activity_type_;
  ::std::string* start_time_;
  ::std::string* stop_time_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Activity* default_instance_;
};
// -------------------------------------------------------------------

class DailyAllowance : public ::google::protobuf::Message {
 public:
  DailyAllowance();
  virtual ~DailyAllowance();

  DailyAllowance(const DailyAllowance& from);

  inline DailyAllowance& operator=(const DailyAllowance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyAllowance& default_instance();

  void Swap(DailyAllowance* other);

  // implements Message ----------------------------------------------

  DailyAllowance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailyAllowance& from);
  void MergeFrom(const DailyAllowance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_DAILY_ALLOWANCE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 huanledou_below = 3 [default = 2000];
  inline bool has_huanledou_below() const;
  inline void clear_huanledou_below();
  static const int kHuanledouBelowFieldNumber = 3;
  inline ::google::protobuf::int32 huanledou_below() const;
  inline void set_huanledou_below(::google::protobuf::int32 value);

  // optional int64 common_reward_id = 4;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 4;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // optional int64 common_limit_id = 5;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 5;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.DailyAllowance)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_huanledou_below();
  inline void clear_has_huanledou_below();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 huanledou_below_;
  ::google::protobuf::int64 common_reward_id_;
  ::google::protobuf::int64 common_limit_id_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static DailyAllowance* default_instance_;
};
// -------------------------------------------------------------------

class Recharge : public ::google::protobuf::Message {
 public:
  Recharge();
  virtual ~Recharge();

  Recharge(const Recharge& from);

  inline Recharge& operator=(const Recharge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Recharge& default_instance();

  void Swap(Recharge* other);

  // implements Message ----------------------------------------------

  Recharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Recharge& from);
  void MergeFrom(const Recharge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_RECHARGE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional bytes plat_name = 3;
  inline bool has_plat_name() const;
  inline void clear_plat_name();
  static const int kPlatNameFieldNumber = 3;
  inline const ::std::string& plat_name() const;
  inline void set_plat_name(const ::std::string& value);
  inline void set_plat_name(const char* value);
  inline void set_plat_name(const void* value, size_t size);
  inline ::std::string* mutable_plat_name();
  inline ::std::string* release_plat_name();
  inline void set_allocated_plat_name(::std::string* plat_name);

  // optional bytes product_id = 4;
  inline bool has_product_id() const;
  inline void clear_product_id();
  static const int kProductIdFieldNumber = 4;
  inline const ::std::string& product_id() const;
  inline void set_product_id(const ::std::string& value);
  inline void set_product_id(const char* value);
  inline void set_product_id(const void* value, size_t size);
  inline ::std::string* mutable_product_id();
  inline ::std::string* release_product_id();
  inline void set_allocated_product_id(::std::string* product_id);

  // optional bytes icon_name = 5;
  inline bool has_icon_name() const;
  inline void clear_icon_name();
  static const int kIconNameFieldNumber = 5;
  inline const ::std::string& icon_name() const;
  inline void set_icon_name(const ::std::string& value);
  inline void set_icon_name(const char* value);
  inline void set_icon_name(const void* value, size_t size);
  inline ::std::string* mutable_icon_name();
  inline ::std::string* release_icon_name();
  inline void set_allocated_icon_name(::std::string* icon_name);

  // optional int32 price = 6;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 6;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 price_show = 7;
  inline bool has_price_show() const;
  inline void clear_price_show();
  static const int kPriceShowFieldNumber = 7;
  inline ::google::protobuf::int32 price_show() const;
  inline void set_price_show(::google::protobuf::int32 value);

  // optional int32 gain_diamond = 8;
  inline bool has_gain_diamond() const;
  inline void clear_gain_diamond();
  static const int kGainDiamondFieldNumber = 8;
  inline ::google::protobuf::int32 gain_diamond() const;
  inline void set_gain_diamond(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Recharge)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_plat_name();
  inline void clear_has_plat_name();
  inline void set_has_product_id();
  inline void clear_has_product_id();
  inline void set_has_icon_name();
  inline void clear_has_icon_name();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_price_show();
  inline void clear_has_price_show();
  inline void set_has_gain_diamond();
  inline void clear_has_gain_diamond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  ::std::string* plat_name_;
  int type_t_;
  ::google::protobuf::int32 price_;
  ::std::string* product_id_;
  ::std::string* icon_name_;
  ::google::protobuf::int32 price_show_;
  ::google::protobuf::int32 gain_diamond_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Recharge* default_instance_;
};
// -------------------------------------------------------------------

class DailySign_ContinuousSign : public ::google::protobuf::Message {
 public:
  DailySign_ContinuousSign();
  virtual ~DailySign_ContinuousSign();

  DailySign_ContinuousSign(const DailySign_ContinuousSign& from);

  inline DailySign_ContinuousSign& operator=(const DailySign_ContinuousSign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailySign_ContinuousSign& default_instance();

  void Swap(DailySign_ContinuousSign* other);

  // implements Message ----------------------------------------------

  DailySign_ContinuousSign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailySign_ContinuousSign& from);
  void MergeFrom(const DailySign_ContinuousSign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int64 common_reward_id = 2;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 2;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // optional int64 common_limit_id = 3;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 3;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.DailySign.ContinuousSign)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 common_reward_id_;
  ::google::protobuf::int64 common_limit_id_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static DailySign_ContinuousSign* default_instance_;
};
// -------------------------------------------------------------------

class DailySign : public ::google::protobuf::Message {
 public:
  DailySign();
  virtual ~DailySign();

  DailySign(const DailySign& from);

  inline DailySign& operator=(const DailySign& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailySign& default_instance();

  void Swap(DailySign* other);

  // implements Message ----------------------------------------------

  DailySign* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailySign& from);
  void MergeFrom(const DailySign& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DailySign_ContinuousSign ContinuousSign;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_DAILY_SIGN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int64 common_reward_id = 3;
  inline bool has_common_reward_id() const;
  inline void clear_common_reward_id();
  static const int kCommonRewardIdFieldNumber = 3;
  inline ::google::protobuf::int64 common_reward_id() const;
  inline void set_common_reward_id(::google::protobuf::int64 value);

  // optional int64 common_limit_id = 4;
  inline bool has_common_limit_id() const;
  inline void clear_common_limit_id();
  static const int kCommonLimitIdFieldNumber = 4;
  inline ::google::protobuf::int64 common_limit_id() const;
  inline void set_common_limit_id(::google::protobuf::int64 value);

  // optional int32 signs_count = 5 [default = 10];
  inline bool has_signs_count() const;
  inline void clear_signs_count();
  static const int kSignsCountFieldNumber = 5;
  inline ::google::protobuf::int32 signs_count() const;
  inline void set_signs_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.DailySign.ContinuousSign signs = 6;
  inline int signs_size() const;
  inline void clear_signs();
  static const int kSignsFieldNumber = 6;
  inline const ::Adoter::Asset::DailySign_ContinuousSign& signs(int index) const;
  inline ::Adoter::Asset::DailySign_ContinuousSign* mutable_signs(int index);
  inline ::Adoter::Asset::DailySign_ContinuousSign* add_signs();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::DailySign_ContinuousSign >&
      signs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::DailySign_ContinuousSign >*
      mutable_signs();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.DailySign)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_common_reward_id();
  inline void clear_has_common_reward_id();
  inline void set_has_common_limit_id();
  inline void clear_has_common_limit_id();
  inline void set_has_signs_count();
  inline void clear_has_signs_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  ::google::protobuf::int64 common_reward_id_;
  int type_t_;
  ::google::protobuf::int32 signs_count_;
  ::google::protobuf::int64 common_limit_id_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::DailySign_ContinuousSign > signs_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static DailySign* default_instance_;
};
// -------------------------------------------------------------------

class Item_CommonProp : public ::google::protobuf::Message {
 public:
  Item_CommonProp();
  virtual ~Item_CommonProp();

  Item_CommonProp(const Item_CommonProp& from);

  inline Item_CommonProp& operator=(const Item_CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_CommonProp& default_instance();

  void Swap(Item_CommonProp* other);

  // implements Message ----------------------------------------------

  Item_CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_CommonProp& from);
  void MergeFrom(const Item_CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.AssetCommonProp common_prop = 1;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 1;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 quality = 2 [default = 1];
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 min_level_limit = 3;
  inline bool has_min_level_limit() const;
  inline void clear_min_level_limit();
  static const int kMinLevelLimitFieldNumber = 3;
  inline ::google::protobuf::int32 min_level_limit() const;
  inline void set_min_level_limit(::google::protobuf::int32 value);

  // optional int32 max_level_limit = 4;
  inline bool has_max_level_limit() const;
  inline void clear_max_level_limit();
  static const int kMaxLevelLimitFieldNumber = 4;
  inline ::google::protobuf::int32 max_level_limit() const;
  inline void set_max_level_limit(::google::protobuf::int32 value);

  // optional int32 pile_max = 5 [default = 1];
  inline bool has_pile_max() const;
  inline void clear_pile_max();
  static const int kPileMaxFieldNumber = 5;
  inline ::google::protobuf::int32 pile_max() const;
  inline void set_pile_max(::google::protobuf::int32 value);

  // optional int32 count = 6 [default = 1];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 6;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional bool batch_use = 7;
  inline bool has_batch_use() const;
  inline void clear_batch_use();
  static const int kBatchUseFieldNumber = 7;
  inline bool batch_use() const;
  inline void set_batch_use(bool value);

  // optional bool auto_use = 8;
  inline bool has_auto_use() const;
  inline void clear_auto_use();
  static const int kAutoUseFieldNumber = 8;
  inline bool auto_use() const;
  inline void set_auto_use(bool value);

  // optional int64 cool_down_id = 9;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 9;
  inline ::google::protobuf::int64 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.INVENTORY_TYPE inventory = 10;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 10;
  inline ::Adoter::Asset::INVENTORY_TYPE inventory() const;
  inline void set_inventory(::Adoter::Asset::INVENTORY_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_CommonProp)
 private:
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_min_level_limit();
  inline void clear_has_min_level_limit();
  inline void set_has_max_level_limit();
  inline void clear_has_max_level_limit();
  inline void set_has_pile_max();
  inline void clear_has_pile_max();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_batch_use();
  inline void clear_has_batch_use();
  inline void set_has_auto_use();
  inline void clear_has_auto_use();
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_inventory();
  inline void clear_has_inventory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 min_level_limit_;
  ::google::protobuf::int32 max_level_limit_;
  ::google::protobuf::int32 pile_max_;
  ::google::protobuf::int32 count_;
  bool batch_use_;
  bool auto_use_;
  ::google::protobuf::int64 cool_down_id_;
  int inventory_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class Item_Item : public ::google::protobuf::Message {
 public:
  Item_Item();
  virtual ~Item_Item();

  Item_Item(const Item_Item& from);

  inline Item_Item& operator=(const Item_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Item& default_instance();

  void Swap(Item_Item* other);

  // implements Message ----------------------------------------------

  Item_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Item& from);
  void MergeFrom(const Item_Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_BEGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional bytes stuff = 2;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 2;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const void* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // optional bytes stuff_extra = 3;
  inline bool has_stuff_extra() const;
  inline void clear_stuff_extra();
  static const int kStuffExtraFieldNumber = 3;
  inline const ::std::string& stuff_extra() const;
  inline void set_stuff_extra(const ::std::string& value);
  inline void set_stuff_extra(const char* value);
  inline void set_stuff_extra(const void* value, size_t size);
  inline ::std::string* mutable_stuff_extra();
  inline ::std::string* release_stuff_extra();
  inline void set_allocated_stuff_extra(::std::string* stuff_extra);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_Item)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_stuff();
  inline void clear_has_stuff();
  inline void set_has_stuff_extra();
  inline void clear_has_stuff_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stuff_;
  ::std::string* stuff_extra_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_Item* default_instance_;
};
// -------------------------------------------------------------------

class Item_Normal : public ::google::protobuf::Message {
 public:
  Item_Normal();
  virtual ~Item_Normal();

  Item_Normal(const Item_Normal& from);

  inline Item_Normal& operator=(const Item_Normal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Normal& default_instance();

  void Swap(Item_Normal* other);

  // implements Message ----------------------------------------------

  Item_Normal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Normal& from);
  void MergeFrom(const Item_Normal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_NORMAL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::Item_CommonProp& item_common_prop() const;
  inline ::Adoter::Asset::Item_CommonProp* mutable_item_common_prop();
  inline ::Adoter::Asset::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_Normal)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Item_CommonProp* item_common_prop_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_Normal* default_instance_;
};
// -------------------------------------------------------------------

class Item_Potion : public ::google::protobuf::Message {
 public:
  Item_Potion();
  virtual ~Item_Potion();

  Item_Potion(const Item_Potion& from);

  inline Item_Potion& operator=(const Item_Potion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Potion& default_instance();

  void Swap(Item_Potion* other);

  // implements Message ----------------------------------------------

  Item_Potion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Potion& from);
  void MergeFrom(const Item_Potion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Item_Potion_POTION_TYPE POTION_TYPE;
  static const POTION_TYPE POTION_TYPE_HEMO = Item_Potion_POTION_TYPE_POTION_TYPE_HEMO;
  static const POTION_TYPE POTION_TYPE_MAGIC = Item_Potion_POTION_TYPE_POTION_TYPE_MAGIC;
  static const POTION_TYPE POTION_TYPE_PHYSICAL_STRENGTH = Item_Potion_POTION_TYPE_POTION_TYPE_PHYSICAL_STRENGTH;
  static inline bool POTION_TYPE_IsValid(int value) {
    return Item_Potion_POTION_TYPE_IsValid(value);
  }
  static const POTION_TYPE POTION_TYPE_MIN =
    Item_Potion_POTION_TYPE_POTION_TYPE_MIN;
  static const POTION_TYPE POTION_TYPE_MAX =
    Item_Potion_POTION_TYPE_POTION_TYPE_MAX;
  static const int POTION_TYPE_ARRAYSIZE =
    Item_Potion_POTION_TYPE_POTION_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  POTION_TYPE_descriptor() {
    return Item_Potion_POTION_TYPE_descriptor();
  }
  static inline const ::std::string& POTION_TYPE_Name(POTION_TYPE value) {
    return Item_Potion_POTION_TYPE_Name(value);
  }
  static inline bool POTION_TYPE_Parse(const ::std::string& name,
      POTION_TYPE* value) {
    return Item_Potion_POTION_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_POTION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::Item_CommonProp& item_common_prop() const;
  inline ::Adoter::Asset::Item_CommonProp* mutable_item_common_prop();
  inline ::Adoter::Asset::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop);

  // optional .Adoter.Asset.Item_Potion.POTION_TYPE potion_type = 3;
  inline bool has_potion_type() const;
  inline void clear_potion_type();
  static const int kPotionTypeFieldNumber = 3;
  inline ::Adoter::Asset::Item_Potion_POTION_TYPE potion_type() const;
  inline void set_potion_type(::Adoter::Asset::Item_Potion_POTION_TYPE value);

  // optional int32 increase_value = 4 [default = 1];
  inline bool has_increase_value() const;
  inline void clear_increase_value();
  static const int kIncreaseValueFieldNumber = 4;
  inline ::google::protobuf::int32 increase_value() const;
  inline void set_increase_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_Potion)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();
  inline void set_has_potion_type();
  inline void clear_has_potion_type();
  inline void set_has_increase_value();
  inline void clear_has_increase_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Item_CommonProp* item_common_prop_;
  int type_t_;
  int potion_type_;
  ::google::protobuf::int32 increase_value_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_Potion* default_instance_;
};
// -------------------------------------------------------------------

class Item_RoomCard : public ::google::protobuf::Message {
 public:
  Item_RoomCard();
  virtual ~Item_RoomCard();

  Item_RoomCard(const Item_RoomCard& from);

  inline Item_RoomCard& operator=(const Item_RoomCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_RoomCard& default_instance();

  void Swap(Item_RoomCard* other);

  // implements Message ----------------------------------------------

  Item_RoomCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_RoomCard& from);
  void MergeFrom(const Item_RoomCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_ROOM_CARD];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::Item_CommonProp& item_common_prop() const;
  inline ::Adoter::Asset::Item_CommonProp* mutable_item_common_prop();
  inline ::Adoter::Asset::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop);

  // optional int32 rounds = 3 [default = 1];
  inline bool has_rounds() const;
  inline void clear_rounds();
  static const int kRoundsFieldNumber = 3;
  inline ::google::protobuf::int32 rounds() const;
  inline void set_rounds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_RoomCard)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();
  inline void set_has_rounds();
  inline void clear_has_rounds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Item_CommonProp* item_common_prop_;
  int type_t_;
  ::google::protobuf::int32 rounds_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_RoomCard* default_instance_;
};
// ===================================================================


// ===================================================================

// AssetCommonProp

// required int64 global_id = 1;
inline bool AssetCommonProp::has_global_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssetCommonProp::set_has_global_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssetCommonProp::clear_has_global_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssetCommonProp::clear_global_id() {
  global_id_ = GOOGLE_LONGLONG(0);
  clear_has_global_id();
}
inline ::google::protobuf::int64 AssetCommonProp::global_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.global_id)
  return global_id_;
}
inline void AssetCommonProp::set_global_id(::google::protobuf::int64 value) {
  set_has_global_id();
  global_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.global_id)
}

// required .Adoter.Asset.VERSION_TYPE version = 2;
inline bool AssetCommonProp::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssetCommonProp::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssetCommonProp::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssetCommonProp::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::Adoter::Asset::VERSION_TYPE AssetCommonProp::version() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.version)
  return static_cast< ::Adoter::Asset::VERSION_TYPE >(version_);
}
inline void AssetCommonProp::set_version(::Adoter::Asset::VERSION_TYPE value) {
  assert(::Adoter::Asset::VERSION_TYPE_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.version)
}

// required bytes name = 3;
inline bool AssetCommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssetCommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssetCommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssetCommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AssetCommonProp::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.name)
  return *name_;
}
inline void AssetCommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.name)
}
inline void AssetCommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.AssetCommonProp.name)
}
inline void AssetCommonProp::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.AssetCommonProp.name)
}
inline ::std::string* AssetCommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.AssetCommonProp.name)
  return name_;
}
inline ::std::string* AssetCommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssetCommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.AssetCommonProp.name)
}

// optional bytes show_name = 4;
inline bool AssetCommonProp::has_show_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssetCommonProp::set_has_show_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssetCommonProp::clear_has_show_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssetCommonProp::clear_show_name() {
  if (show_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_->clear();
  }
  clear_has_show_name();
}
inline const ::std::string& AssetCommonProp::show_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.show_name)
  return *show_name_;
}
inline void AssetCommonProp::set_show_name(const ::std::string& value) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.show_name)
}
inline void AssetCommonProp::set_show_name(const char* value) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.AssetCommonProp.show_name)
}
inline void AssetCommonProp::set_show_name(const void* value, size_t size) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.AssetCommonProp.show_name)
}
inline ::std::string* AssetCommonProp::mutable_show_name() {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.AssetCommonProp.show_name)
  return show_name_;
}
inline ::std::string* AssetCommonProp::release_show_name() {
  clear_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = show_name_;
    show_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssetCommonProp::set_allocated_show_name(::std::string* show_name) {
  if (show_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete show_name_;
  }
  if (show_name) {
    set_has_show_name();
    show_name_ = show_name;
  } else {
    clear_has_show_name();
    show_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.AssetCommonProp.show_name)
}

// optional bytes desc = 5;
inline bool AssetCommonProp::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssetCommonProp::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssetCommonProp::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssetCommonProp::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& AssetCommonProp::desc() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.desc)
  return *desc_;
}
inline void AssetCommonProp::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.desc)
}
inline void AssetCommonProp::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.AssetCommonProp.desc)
}
inline void AssetCommonProp::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.AssetCommonProp.desc)
}
inline ::std::string* AssetCommonProp::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.AssetCommonProp.desc)
  return desc_;
}
inline ::std::string* AssetCommonProp::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssetCommonProp::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.AssetCommonProp.desc)
}

// -------------------------------------------------------------------

// RoomLimit

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM];
inline bool RoomLimit::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomLimit::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomLimit::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomLimit::clear_type_t() {
  type_t_ = 2;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE RoomLimit::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void RoomLimit::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool RoomLimit::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomLimit::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomLimit::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomLimit::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& RoomLimit::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomLimit::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomLimit.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomLimit::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void RoomLimit::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomLimit.common_prop)
}

// optional .Adoter.Asset.ROOM_TYPE room_type = 3;
inline bool RoomLimit::has_room_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomLimit::set_has_room_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomLimit::clear_has_room_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomLimit::clear_room_type() {
  room_type_ = 1;
  clear_has_room_type();
}
inline ::Adoter::Asset::ROOM_TYPE RoomLimit::room_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.room_type)
  return static_cast< ::Adoter::Asset::ROOM_TYPE >(room_type_);
}
inline void RoomLimit::set_room_type(::Adoter::Asset::ROOM_TYPE value) {
  assert(::Adoter::Asset::ROOM_TYPE_IsValid(value));
  set_has_room_type();
  room_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.room_type)
}

// optional int32 min_limit = 4;
inline bool RoomLimit::has_min_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomLimit::set_has_min_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomLimit::clear_has_min_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomLimit::clear_min_limit() {
  min_limit_ = 0;
  clear_has_min_limit();
}
inline ::google::protobuf::int32 RoomLimit::min_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.min_limit)
  return min_limit_;
}
inline void RoomLimit::set_min_limit(::google::protobuf::int32 value) {
  set_has_min_limit();
  min_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.min_limit)
}

// optional int32 max_limit = 5;
inline bool RoomLimit::has_max_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomLimit::set_has_max_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomLimit::clear_has_max_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomLimit::clear_max_limit() {
  max_limit_ = 0;
  clear_has_max_limit();
}
inline ::google::protobuf::int32 RoomLimit::max_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.max_limit)
  return max_limit_;
}
inline void RoomLimit::set_max_limit(::google::protobuf::int32 value) {
  set_has_max_limit();
  max_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.max_limit)
}

// optional int32 max_fan = 6;
inline bool RoomLimit::has_max_fan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomLimit::set_has_max_fan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomLimit::clear_has_max_fan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomLimit::clear_max_fan() {
  max_fan_ = 0;
  clear_has_max_fan();
}
inline ::google::protobuf::int32 RoomLimit::max_fan() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.max_fan)
  return max_fan_;
}
inline void RoomLimit::set_max_fan(::google::protobuf::int32 value) {
  set_has_max_fan();
  max_fan_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.max_fan)
}

// optional int32 cost_count = 7;
inline bool RoomLimit::has_cost_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomLimit::set_has_cost_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomLimit::clear_has_cost_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomLimit::clear_cost_count() {
  cost_count_ = 0;
  clear_has_cost_count();
}
inline ::google::protobuf::int32 RoomLimit::cost_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.cost_count)
  return cost_count_;
}
inline void RoomLimit::set_cost_count(::google::protobuf::int32 value) {
  set_has_cost_count();
  cost_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.cost_count)
}

// optional int32 base_count = 8;
inline bool RoomLimit::has_base_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomLimit::set_has_base_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomLimit::clear_has_base_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomLimit::clear_base_count() {
  base_count_ = 0;
  clear_has_base_count();
}
inline ::google::protobuf::int32 RoomLimit::base_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomLimit.base_count)
  return base_count_;
}
inline void RoomLimit::set_base_count(::google::protobuf::int32 value) {
  set_has_base_count();
  base_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomLimit.base_count)
}

// -------------------------------------------------------------------

// CommonLimit

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_LIMIT];
inline bool CommonLimit::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonLimit::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonLimit::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonLimit::clear_type_t() {
  type_t_ = 3;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CommonLimit::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CommonLimit::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CommonLimit::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonLimit::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonLimit::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonLimit::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CommonLimit::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonLimit::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonLimit.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonLimit::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonLimit::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonLimit.common_prop)
}

// optional .Adoter.Asset.CommonLimit.COMMON_LIMIT_TYPE limit_type = 3;
inline bool CommonLimit::has_limit_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonLimit::set_has_limit_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonLimit::clear_has_limit_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonLimit::clear_limit_type() {
  limit_type_ = 1;
  clear_has_limit_type();
}
inline ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE CommonLimit::limit_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.limit_type)
  return static_cast< ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE >(limit_type_);
}
inline void CommonLimit::set_limit_type(::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE value) {
  assert(::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE_IsValid(value));
  set_has_limit_type();
  limit_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.limit_type)
}

// optional .Adoter.Asset.CommonLimit.COOL_DOWN_TYPE cool_down_type = 4;
inline bool CommonLimit::has_cool_down_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonLimit::set_has_cool_down_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonLimit::clear_has_cool_down_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonLimit::clear_cool_down_type() {
  cool_down_type_ = 1;
  clear_has_cool_down_type();
}
inline ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE CommonLimit::cool_down_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.cool_down_type)
  return static_cast< ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE >(cool_down_type_);
}
inline void CommonLimit::set_cool_down_type(::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE value) {
  assert(::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE_IsValid(value));
  set_has_cool_down_type();
  cool_down_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.cool_down_type)
}

// optional .Adoter.Asset.CommonLimit.COOL_DOWN_CLEAR_TYPE cool_down_clear_type = 5;
inline bool CommonLimit::has_cool_down_clear_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonLimit::set_has_cool_down_clear_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonLimit::clear_has_cool_down_clear_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonLimit::clear_cool_down_clear_type() {
  cool_down_clear_type_ = 1;
  clear_has_cool_down_clear_type();
}
inline ::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE CommonLimit::cool_down_clear_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.cool_down_clear_type)
  return static_cast< ::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE >(cool_down_clear_type_);
}
inline void CommonLimit::set_cool_down_clear_type(::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE value) {
  assert(::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE_IsValid(value));
  set_has_cool_down_clear_type();
  cool_down_clear_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.cool_down_clear_type)
}

// optional int32 max_count = 6;
inline bool CommonLimit::has_max_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonLimit::set_has_max_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonLimit::clear_has_max_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonLimit::clear_max_count() {
  max_count_ = 0;
  clear_has_max_count();
}
inline ::google::protobuf::int32 CommonLimit::max_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.max_count)
  return max_count_;
}
inline void CommonLimit::set_max_count(::google::protobuf::int32 value) {
  set_has_max_count();
  max_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.max_count)
}

// -------------------------------------------------------------------

// CoolDown

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COOL_DOWN];
inline bool CoolDown::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoolDown::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoolDown::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoolDown::clear_type_t() {
  type_t_ = 5;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CoolDown::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CoolDown.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CoolDown::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CoolDown.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CoolDown::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoolDown::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoolDown::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoolDown::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CoolDown::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CoolDown.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CoolDown::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CoolDown.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CoolDown::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CoolDown::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CoolDown.common_prop)
}

// optional int32 duration = 4;
inline bool CoolDown::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoolDown::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoolDown::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoolDown::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 CoolDown::duration() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CoolDown.duration)
  return duration_;
}
inline void CoolDown::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CoolDown.duration)
}

// -------------------------------------------------------------------

// MJCard_Card

// optional int32 value = 1;
inline bool MJCard_Card::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJCard_Card::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJCard_Card::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJCard_Card::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 MJCard_Card::value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.Card.value)
  return value_;
}
inline void MJCard_Card::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.Card.value)
}

// optional bytes model_path = 2;
inline bool MJCard_Card::has_model_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJCard_Card::set_has_model_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJCard_Card::clear_has_model_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJCard_Card::clear_model_path() {
  if (model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_path_->clear();
  }
  clear_has_model_path();
}
inline const ::std::string& MJCard_Card::model_path() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.Card.model_path)
  return *model_path_;
}
inline void MJCard_Card::set_model_path(const ::std::string& value) {
  set_has_model_path();
  if (model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_path_ = new ::std::string;
  }
  model_path_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.Card.model_path)
}
inline void MJCard_Card::set_model_path(const char* value) {
  set_has_model_path();
  if (model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_path_ = new ::std::string;
  }
  model_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.MJCard.Card.model_path)
}
inline void MJCard_Card::set_model_path(const void* value, size_t size) {
  set_has_model_path();
  if (model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_path_ = new ::std::string;
  }
  model_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.MJCard.Card.model_path)
}
inline ::std::string* MJCard_Card::mutable_model_path() {
  set_has_model_path();
  if (model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MJCard.Card.model_path)
  return model_path_;
}
inline ::std::string* MJCard_Card::release_model_path() {
  clear_has_model_path();
  if (model_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_path_;
    model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MJCard_Card::set_allocated_model_path(::std::string* model_path) {
  if (model_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_path_;
  }
  if (model_path) {
    set_has_model_path();
    model_path_ = model_path;
  } else {
    clear_has_model_path();
    model_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.MJCard.Card.model_path)
}

// optional bytes voice_path = 3;
inline bool MJCard_Card::has_voice_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJCard_Card::set_has_voice_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJCard_Card::clear_has_voice_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJCard_Card::clear_voice_path() {
  if (voice_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_->clear();
  }
  clear_has_voice_path();
}
inline const ::std::string& MJCard_Card::voice_path() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.Card.voice_path)
  return *voice_path_;
}
inline void MJCard_Card::set_voice_path(const ::std::string& value) {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  voice_path_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.Card.voice_path)
}
inline void MJCard_Card::set_voice_path(const char* value) {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  voice_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.MJCard.Card.voice_path)
}
inline void MJCard_Card::set_voice_path(const void* value, size_t size) {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  voice_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.MJCard.Card.voice_path)
}
inline ::std::string* MJCard_Card::mutable_voice_path() {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MJCard.Card.voice_path)
  return voice_path_;
}
inline ::std::string* MJCard_Card::release_voice_path() {
  clear_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = voice_path_;
    voice_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MJCard_Card::set_allocated_voice_path(::std::string* voice_path) {
  if (voice_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete voice_path_;
  }
  if (voice_path) {
    set_has_voice_path();
    voice_path_ = voice_path;
  } else {
    clear_has_voice_path();
    voice_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.MJCard.Card.voice_path)
}

// -------------------------------------------------------------------

// MJCard

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_MJ_CARD];
inline bool MJCard::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MJCard::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MJCard::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MJCard::clear_type_t() {
  type_t_ = 6;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE MJCard::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void MJCard::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool MJCard::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MJCard::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MJCard::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MJCard::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& MJCard::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* MJCard::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MJCard.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* MJCard::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void MJCard::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.MJCard.common_prop)
}

// optional .Adoter.Asset.CARD_TYPE card_type = 3;
inline bool MJCard::has_card_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MJCard::set_has_card_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MJCard::clear_has_card_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MJCard::clear_card_type() {
  card_type_ = 1;
  clear_has_card_type();
}
inline ::Adoter::Asset::CARD_TYPE MJCard::card_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.card_type)
  return static_cast< ::Adoter::Asset::CARD_TYPE >(card_type_);
}
inline void MJCard::set_card_type(::Adoter::Asset::CARD_TYPE value) {
  assert(::Adoter::Asset::CARD_TYPE_IsValid(value));
  set_has_card_type();
  card_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.card_type)
}

// optional int32 group_count = 4 [default = 4];
inline bool MJCard::has_group_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MJCard::set_has_group_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MJCard::clear_has_group_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MJCard::clear_group_count() {
  group_count_ = 4;
  clear_has_group_count();
}
inline ::google::protobuf::int32 MJCard::group_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.group_count)
  return group_count_;
}
inline void MJCard::set_group_count(::google::protobuf::int32 value) {
  set_has_group_count();
  group_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.group_count)
}

// optional int32 cards_count = 5 [default = 9];
inline bool MJCard::has_cards_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MJCard::set_has_cards_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MJCard::clear_has_cards_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MJCard::clear_cards_count() {
  cards_count_ = 9;
  clear_has_cards_count();
}
inline ::google::protobuf::int32 MJCard::cards_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.cards_count)
  return cards_count_;
}
inline void MJCard::set_cards_count(::google::protobuf::int32 value) {
  set_has_cards_count();
  cards_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.MJCard.cards_count)
}

// repeated .Adoter.Asset.MJCard.Card cards = 6;
inline int MJCard::cards_size() const {
  return cards_.size();
}
inline void MJCard::clear_cards() {
  cards_.Clear();
}
inline const ::Adoter::Asset::MJCard_Card& MJCard::cards(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.MJCard.cards)
  return cards_.Get(index);
}
inline ::Adoter::Asset::MJCard_Card* MJCard::mutable_cards(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.MJCard.cards)
  return cards_.Mutable(index);
}
inline ::Adoter::Asset::MJCard_Card* MJCard::add_cards() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.MJCard.cards)
  return cards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MJCard_Card >&
MJCard::cards() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.MJCard.cards)
  return cards_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::MJCard_Card >*
MJCard::mutable_cards() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.MJCard.cards)
  return &cards_;
}

// -------------------------------------------------------------------

// CommonConst

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_CONST];
inline bool CommonConst::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonConst::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonConst::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonConst::clear_type_t() {
  type_t_ = 7;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CommonConst::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CommonConst::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConst.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CommonConst::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonConst::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonConst::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonConst::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CommonConst::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonConst::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonConst.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonConst::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonConst::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonConst.common_prop)
}

// optional int32 max_cards_count = 3 [default = 136];
inline bool CommonConst::has_max_cards_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonConst::set_has_max_cards_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonConst::clear_has_max_cards_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonConst::clear_max_cards_count() {
  max_cards_count_ = 136;
  clear_has_max_cards_count();
}
inline ::google::protobuf::int32 CommonConst::max_cards_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.max_cards_count)
  return max_cards_count_;
}
inline void CommonConst::set_max_cards_count(::google::protobuf::int32 value) {
  set_has_max_cards_count();
  max_cards_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConst.max_cards_count)
}

// optional int64 daily_bonus_id = 4;
inline bool CommonConst::has_daily_bonus_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonConst::set_has_daily_bonus_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonConst::clear_has_daily_bonus_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonConst::clear_daily_bonus_id() {
  daily_bonus_id_ = GOOGLE_LONGLONG(0);
  clear_has_daily_bonus_id();
}
inline ::google::protobuf::int64 CommonConst::daily_bonus_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.daily_bonus_id)
  return daily_bonus_id_;
}
inline void CommonConst::set_daily_bonus_id(::google::protobuf::int64 value) {
  set_has_daily_bonus_id();
  daily_bonus_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConst.daily_bonus_id)
}

// optional int64 daily_allowance_id = 5;
inline bool CommonConst::has_daily_allowance_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonConst::set_has_daily_allowance_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonConst::clear_has_daily_allowance_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonConst::clear_daily_allowance_id() {
  daily_allowance_id_ = GOOGLE_LONGLONG(0);
  clear_has_daily_allowance_id();
}
inline ::google::protobuf::int64 CommonConst::daily_allowance_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.daily_allowance_id)
  return daily_allowance_id_;
}
inline void CommonConst::set_daily_allowance_id(::google::protobuf::int64 value) {
  set_has_daily_allowance_id();
  daily_allowance_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConst.daily_allowance_id)
}

// optional int32 time_out = 6 [default = 8];
inline bool CommonConst::has_time_out() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonConst::set_has_time_out() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonConst::clear_has_time_out() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonConst::clear_time_out() {
  time_out_ = 8;
  clear_has_time_out();
}
inline ::google::protobuf::int32 CommonConst::time_out() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.time_out)
  return time_out_;
}
inline void CommonConst::set_time_out(::google::protobuf::int32 value) {
  set_has_time_out();
  time_out_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConst.time_out)
}

// optional int64 daily_sign_id = 7;
inline bool CommonConst::has_daily_sign_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonConst::set_has_daily_sign_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonConst::clear_has_daily_sign_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonConst::clear_daily_sign_id() {
  daily_sign_id_ = GOOGLE_LONGLONG(0);
  clear_has_daily_sign_id();
}
inline ::google::protobuf::int64 CommonConst::daily_sign_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConst.daily_sign_id)
  return daily_sign_id_;
}
inline void CommonConst::set_daily_sign_id(::google::protobuf::int64 value) {
  set_has_daily_sign_id();
  daily_sign_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConst.daily_sign_id)
}

// -------------------------------------------------------------------

// CommonReward_Reward

// optional .Adoter.Asset.CommonReward.REWARD_TYPE reward_type = 1;
inline bool CommonReward_Reward::has_reward_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonReward_Reward::set_has_reward_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonReward_Reward::clear_has_reward_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonReward_Reward::clear_reward_type() {
  reward_type_ = 1;
  clear_has_reward_type();
}
inline ::Adoter::Asset::CommonReward_REWARD_TYPE CommonReward_Reward::reward_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.Reward.reward_type)
  return static_cast< ::Adoter::Asset::CommonReward_REWARD_TYPE >(reward_type_);
}
inline void CommonReward_Reward::set_reward_type(::Adoter::Asset::CommonReward_REWARD_TYPE value) {
  assert(::Adoter::Asset::CommonReward_REWARD_TYPE_IsValid(value));
  set_has_reward_type();
  reward_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.Reward.reward_type)
}

// optional bytes comments = 2;
inline bool CommonReward_Reward::has_comments() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonReward_Reward::set_has_comments() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonReward_Reward::clear_has_comments() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonReward_Reward::clear_comments() {
  if (comments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comments_->clear();
  }
  clear_has_comments();
}
inline const ::std::string& CommonReward_Reward::comments() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.Reward.comments)
  return *comments_;
}
inline void CommonReward_Reward::set_comments(const ::std::string& value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.Reward.comments)
}
inline void CommonReward_Reward::set_comments(const char* value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.CommonReward.Reward.comments)
}
inline void CommonReward_Reward::set_comments(const void* value, size_t size) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comments_ = new ::std::string;
  }
  comments_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.CommonReward.Reward.comments)
}
inline ::std::string* CommonReward_Reward::mutable_comments() {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comments_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonReward.Reward.comments)
  return comments_;
}
inline ::std::string* CommonReward_Reward::release_comments() {
  clear_has_comments();
  if (comments_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comments_;
    comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonReward_Reward::set_allocated_comments(::std::string* comments) {
  if (comments_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comments_;
  }
  if (comments) {
    set_has_comments();
    comments_ = comments;
  } else {
    clear_has_comments();
    comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonReward.Reward.comments)
}

// optional bytes icon_name = 3;
inline bool CommonReward_Reward::has_icon_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonReward_Reward::set_has_icon_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonReward_Reward::clear_has_icon_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonReward_Reward::clear_icon_name() {
  if (icon_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_->clear();
  }
  clear_has_icon_name();
}
inline const ::std::string& CommonReward_Reward::icon_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.Reward.icon_name)
  return *icon_name_;
}
inline void CommonReward_Reward::set_icon_name(const ::std::string& value) {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  icon_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.Reward.icon_name)
}
inline void CommonReward_Reward::set_icon_name(const char* value) {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  icon_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.CommonReward.Reward.icon_name)
}
inline void CommonReward_Reward::set_icon_name(const void* value, size_t size) {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  icon_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.CommonReward.Reward.icon_name)
}
inline ::std::string* CommonReward_Reward::mutable_icon_name() {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonReward.Reward.icon_name)
  return icon_name_;
}
inline ::std::string* CommonReward_Reward::release_icon_name() {
  clear_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_name_;
    icon_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonReward_Reward::set_allocated_icon_name(::std::string* icon_name) {
  if (icon_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_name_;
  }
  if (icon_name) {
    set_has_icon_name();
    icon_name_ = icon_name;
  } else {
    clear_has_icon_name();
    icon_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonReward.Reward.icon_name)
}

// optional int64 item_id = 4;
inline bool CommonReward_Reward::has_item_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonReward_Reward::set_has_item_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonReward_Reward::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonReward_Reward::clear_item_id() {
  item_id_ = GOOGLE_LONGLONG(0);
  clear_has_item_id();
}
inline ::google::protobuf::int64 CommonReward_Reward::item_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.Reward.item_id)
  return item_id_;
}
inline void CommonReward_Reward::set_item_id(::google::protobuf::int64 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.Reward.item_id)
}

// optional int32 count = 5;
inline bool CommonReward_Reward::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonReward_Reward::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonReward_Reward::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonReward_Reward::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 CommonReward_Reward::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.Reward.count)
  return count_;
}
inline void CommonReward_Reward::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.Reward.count)
}

// optional int64 common_limit_id = 6;
inline bool CommonReward_Reward::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonReward_Reward::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonReward_Reward::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonReward_Reward::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 CommonReward_Reward::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.Reward.common_limit_id)
  return common_limit_id_;
}
inline void CommonReward_Reward::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.Reward.common_limit_id)
}

// -------------------------------------------------------------------

// CommonReward

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_REWARD];
inline bool CommonReward::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonReward::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonReward::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonReward::clear_type_t() {
  type_t_ = 4;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CommonReward::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CommonReward::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CommonReward::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonReward::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonReward::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonReward::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CommonReward::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonReward::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonReward.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonReward::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonReward::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonReward.common_prop)
}

// optional int32 rewards_count = 3 [default = 10];
inline bool CommonReward::has_rewards_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonReward::set_has_rewards_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonReward::clear_has_rewards_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonReward::clear_rewards_count() {
  rewards_count_ = 10;
  clear_has_rewards_count();
}
inline ::google::protobuf::int32 CommonReward::rewards_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.rewards_count)
  return rewards_count_;
}
inline void CommonReward::set_rewards_count(::google::protobuf::int32 value) {
  set_has_rewards_count();
  rewards_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonReward.rewards_count)
}

// repeated .Adoter.Asset.CommonReward.Reward rewards = 4;
inline int CommonReward::rewards_size() const {
  return rewards_.size();
}
inline void CommonReward::clear_rewards() {
  rewards_.Clear();
}
inline const ::Adoter::Asset::CommonReward_Reward& CommonReward::rewards(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonReward.rewards)
  return rewards_.Get(index);
}
inline ::Adoter::Asset::CommonReward_Reward* CommonReward::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonReward.rewards)
  return rewards_.Mutable(index);
}
inline ::Adoter::Asset::CommonReward_Reward* CommonReward::add_rewards() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.CommonReward.rewards)
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonReward_Reward >&
CommonReward::rewards() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.CommonReward.rewards)
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonReward_Reward >*
CommonReward::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.CommonReward.rewards)
  return &rewards_;
}

// -------------------------------------------------------------------

// CommonConsume_Element

// optional .Adoter.Asset.CommonConsume.CONSUME_TYPE consume_type = 1;
inline bool CommonConsume_Element::has_consume_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonConsume_Element::set_has_consume_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonConsume_Element::clear_has_consume_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonConsume_Element::clear_consume_type() {
  consume_type_ = 1;
  clear_has_consume_type();
}
inline ::Adoter::Asset::CommonConsume_CONSUME_TYPE CommonConsume_Element::consume_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.Element.consume_type)
  return static_cast< ::Adoter::Asset::CommonConsume_CONSUME_TYPE >(consume_type_);
}
inline void CommonConsume_Element::set_consume_type(::Adoter::Asset::CommonConsume_CONSUME_TYPE value) {
  assert(::Adoter::Asset::CommonConsume_CONSUME_TYPE_IsValid(value));
  set_has_consume_type();
  consume_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConsume.Element.consume_type)
}

// optional int32 item_id = 2;
inline bool CommonConsume_Element::has_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonConsume_Element::set_has_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonConsume_Element::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonConsume_Element::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 CommonConsume_Element::item_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.Element.item_id)
  return item_id_;
}
inline void CommonConsume_Element::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConsume.Element.item_id)
}

// optional int32 consume_count = 3;
inline bool CommonConsume_Element::has_consume_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonConsume_Element::set_has_consume_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonConsume_Element::clear_has_consume_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonConsume_Element::clear_consume_count() {
  consume_count_ = 0;
  clear_has_consume_count();
}
inline ::google::protobuf::int32 CommonConsume_Element::consume_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.Element.consume_count)
  return consume_count_;
}
inline void CommonConsume_Element::set_consume_count(::google::protobuf::int32 value) {
  set_has_consume_count();
  consume_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConsume.Element.consume_count)
}

// -------------------------------------------------------------------

// CommonConsume

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_CONSUME];
inline bool CommonConsume::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonConsume::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonConsume::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonConsume::clear_type_t() {
  type_t_ = 19;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CommonConsume::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CommonConsume::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConsume.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CommonConsume::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonConsume::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonConsume::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonConsume::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CommonConsume::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonConsume::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonConsume.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonConsume::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonConsume::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonConsume.common_prop)
}

// optional int32 elements_count = 3 [default = 3];
inline bool CommonConsume::has_elements_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonConsume::set_has_elements_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonConsume::clear_has_elements_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonConsume::clear_elements_count() {
  elements_count_ = 3;
  clear_has_elements_count();
}
inline ::google::protobuf::int32 CommonConsume::elements_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.elements_count)
  return elements_count_;
}
inline void CommonConsume::set_elements_count(::google::protobuf::int32 value) {
  set_has_elements_count();
  elements_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonConsume.elements_count)
}

// repeated .Adoter.Asset.CommonConsume.Element elements = 4;
inline int CommonConsume::elements_size() const {
  return elements_.size();
}
inline void CommonConsume::clear_elements() {
  elements_.Clear();
}
inline const ::Adoter::Asset::CommonConsume_Element& CommonConsume::elements(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonConsume.elements)
  return elements_.Get(index);
}
inline ::Adoter::Asset::CommonConsume_Element* CommonConsume::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonConsume.elements)
  return elements_.Mutable(index);
}
inline ::Adoter::Asset::CommonConsume_Element* CommonConsume::add_elements() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.CommonConsume.elements)
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonConsume_Element >&
CommonConsume::elements() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.CommonConsume.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::CommonConsume_Element >*
CommonConsume::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.CommonConsume.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// LuckyPlate_Plate

// optional int32 weight = 1;
inline bool LuckyPlate_Plate::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LuckyPlate_Plate::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LuckyPlate_Plate::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LuckyPlate_Plate::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 LuckyPlate_Plate::weight() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LuckyPlate.Plate.weight)
  return weight_;
}
inline void LuckyPlate_Plate::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LuckyPlate.Plate.weight)
}

// optional int64 common_reward_id = 2;
inline bool LuckyPlate_Plate::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LuckyPlate_Plate::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LuckyPlate_Plate::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LuckyPlate_Plate::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 LuckyPlate_Plate::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LuckyPlate.Plate.common_reward_id)
  return common_reward_id_;
}
inline void LuckyPlate_Plate::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LuckyPlate.Plate.common_reward_id)
}

// -------------------------------------------------------------------

// LuckyPlate

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_LUCKY_PLATE];
inline bool LuckyPlate::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LuckyPlate::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LuckyPlate::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LuckyPlate::clear_type_t() {
  type_t_ = 8;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE LuckyPlate::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LuckyPlate.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void LuckyPlate::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LuckyPlate.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool LuckyPlate::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LuckyPlate::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LuckyPlate::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LuckyPlate::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& LuckyPlate::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LuckyPlate.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* LuckyPlate::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.LuckyPlate.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* LuckyPlate::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void LuckyPlate::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.LuckyPlate.common_prop)
}

// optional int32 plates_count = 3 [default = 10];
inline bool LuckyPlate::has_plates_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LuckyPlate::set_has_plates_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LuckyPlate::clear_has_plates_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LuckyPlate::clear_plates_count() {
  plates_count_ = 10;
  clear_has_plates_count();
}
inline ::google::protobuf::int32 LuckyPlate::plates_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LuckyPlate.plates_count)
  return plates_count_;
}
inline void LuckyPlate::set_plates_count(::google::protobuf::int32 value) {
  set_has_plates_count();
  plates_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LuckyPlate.plates_count)
}

// repeated .Adoter.Asset.LuckyPlate.Plate plates = 4;
inline int LuckyPlate::plates_size() const {
  return plates_.size();
}
inline void LuckyPlate::clear_plates() {
  plates_.Clear();
}
inline const ::Adoter::Asset::LuckyPlate_Plate& LuckyPlate::plates(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LuckyPlate.plates)
  return plates_.Get(index);
}
inline ::Adoter::Asset::LuckyPlate_Plate* LuckyPlate::mutable_plates(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.LuckyPlate.plates)
  return plates_.Mutable(index);
}
inline ::Adoter::Asset::LuckyPlate_Plate* LuckyPlate::add_plates() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.LuckyPlate.plates)
  return plates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LuckyPlate_Plate >&
LuckyPlate::plates() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.LuckyPlate.plates)
  return plates_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LuckyPlate_Plate >*
LuckyPlate::mutable_plates() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.LuckyPlate.plates)
  return &plates_;
}

// -------------------------------------------------------------------

// DailyBonus

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_DAILY_BONUS];
inline bool DailyBonus::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyBonus::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyBonus::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyBonus::clear_type_t() {
  type_t_ = 9;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE DailyBonus::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyBonus.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void DailyBonus::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyBonus.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool DailyBonus::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyBonus::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyBonus::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyBonus::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& DailyBonus::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyBonus.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* DailyBonus::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.DailyBonus.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* DailyBonus::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void DailyBonus::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.DailyBonus.common_prop)
}

// optional int64 common_reward_id = 3;
inline bool DailyBonus::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyBonus::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyBonus::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyBonus::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 DailyBonus::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyBonus.common_reward_id)
  return common_reward_id_;
}
inline void DailyBonus::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyBonus.common_reward_id)
}

// optional int64 common_limit_id = 4;
inline bool DailyBonus::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyBonus::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyBonus::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyBonus::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 DailyBonus::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyBonus.common_limit_id)
  return common_limit_id_;
}
inline void DailyBonus::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyBonus.common_limit_id)
}

// -------------------------------------------------------------------

// Mall

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_MALL];
inline bool Mall::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mall::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mall::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mall::clear_type_t() {
  type_t_ = 10;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Mall::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Mall::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Mall::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mall::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mall::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mall::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Mall::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Mall::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Mall.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Mall::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Mall::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Mall.common_prop)
}

// optional .Adoter.Asset.Mall.GOODS_TYPE goods_type = 3;
inline bool Mall::has_goods_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mall::set_has_goods_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mall::clear_has_goods_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mall::clear_goods_type() {
  goods_type_ = 1;
  clear_has_goods_type();
}
inline ::Adoter::Asset::Mall_GOODS_TYPE Mall::goods_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.goods_type)
  return static_cast< ::Adoter::Asset::Mall_GOODS_TYPE >(goods_type_);
}
inline void Mall::set_goods_type(::Adoter::Asset::Mall_GOODS_TYPE value) {
  assert(::Adoter::Asset::Mall_GOODS_TYPE_IsValid(value));
  set_has_goods_type();
  goods_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.goods_type)
}

// optional int64 item_id = 4;
inline bool Mall::has_item_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mall::set_has_item_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mall::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mall::clear_item_id() {
  item_id_ = GOOGLE_LONGLONG(0);
  clear_has_item_id();
}
inline ::google::protobuf::int64 Mall::item_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.item_id)
  return item_id_;
}
inline void Mall::set_item_id(::google::protobuf::int64 value) {
  set_has_item_id();
  item_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.item_id)
}

// optional int32 count = 5;
inline bool Mall::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mall::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mall::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mall::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Mall::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.count)
  return count_;
}
inline void Mall::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.count)
}

// optional int32 diamond = 6;
inline bool Mall::has_diamond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mall::set_has_diamond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Mall::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Mall::clear_diamond() {
  diamond_ = 0;
  clear_has_diamond();
}
inline ::google::protobuf::int32 Mall::diamond() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.diamond)
  return diamond_;
}
inline void Mall::set_diamond(::google::protobuf::int32 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.diamond)
}

// optional int32 diamond_show = 7;
inline bool Mall::has_diamond_show() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Mall::set_has_diamond_show() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Mall::clear_has_diamond_show() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Mall::clear_diamond_show() {
  diamond_show_ = 0;
  clear_has_diamond_show();
}
inline ::google::protobuf::int32 Mall::diamond_show() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.diamond_show)
  return diamond_show_;
}
inline void Mall::set_diamond_show(::google::protobuf::int32 value) {
  set_has_diamond_show();
  diamond_show_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.diamond_show)
}

// optional int32 huanledou = 8;
inline bool Mall::has_huanledou() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Mall::set_has_huanledou() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Mall::clear_has_huanledou() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Mall::clear_huanledou() {
  huanledou_ = 0;
  clear_has_huanledou();
}
inline ::google::protobuf::int32 Mall::huanledou() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.huanledou)
  return huanledou_;
}
inline void Mall::set_huanledou(::google::protobuf::int32 value) {
  set_has_huanledou();
  huanledou_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.huanledou)
}

// optional int32 huanledou_show = 9;
inline bool Mall::has_huanledou_show() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Mall::set_has_huanledou_show() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Mall::clear_has_huanledou_show() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Mall::clear_huanledou_show() {
  huanledou_show_ = 0;
  clear_has_huanledou_show();
}
inline ::google::protobuf::int32 Mall::huanledou_show() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.huanledou_show)
  return huanledou_show_;
}
inline void Mall::set_huanledou_show(::google::protobuf::int32 value) {
  set_has_huanledou_show();
  huanledou_show_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.huanledou_show)
}

// optional int64 activity_id = 10;
inline bool Mall::has_activity_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Mall::set_has_activity_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Mall::clear_has_activity_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Mall::clear_activity_id() {
  activity_id_ = GOOGLE_LONGLONG(0);
  clear_has_activity_id();
}
inline ::google::protobuf::int64 Mall::activity_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Mall.activity_id)
  return activity_id_;
}
inline void Mall::set_activity_id(::google::protobuf::int64 value) {
  set_has_activity_id();
  activity_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Mall.activity_id)
}

// -------------------------------------------------------------------

// RoomFan_FanElement

// optional .Adoter.Asset.FAN_TYPE fan_type = 3;
inline bool RoomFan_FanElement::has_fan_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomFan_FanElement::set_has_fan_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomFan_FanElement::clear_has_fan_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomFan_FanElement::clear_fan_type() {
  fan_type_ = 1;
  clear_has_fan_type();
}
inline ::Adoter::Asset::FAN_TYPE RoomFan_FanElement::fan_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.FanElement.fan_type)
  return static_cast< ::Adoter::Asset::FAN_TYPE >(fan_type_);
}
inline void RoomFan_FanElement::set_fan_type(::Adoter::Asset::FAN_TYPE value) {
  assert(::Adoter::Asset::FAN_TYPE_IsValid(value));
  set_has_fan_type();
  fan_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomFan.FanElement.fan_type)
}

// optional bytes name = 4;
inline bool RoomFan_FanElement::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomFan_FanElement::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomFan_FanElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomFan_FanElement::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomFan_FanElement::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.FanElement.name)
  return *name_;
}
inline void RoomFan_FanElement::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomFan.FanElement.name)
}
inline void RoomFan_FanElement::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.RoomFan.FanElement.name)
}
inline void RoomFan_FanElement::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.RoomFan.FanElement.name)
}
inline ::std::string* RoomFan_FanElement::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomFan.FanElement.name)
  return name_;
}
inline ::std::string* RoomFan_FanElement::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RoomFan_FanElement::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomFan.FanElement.name)
}

// optional int32 multiple = 5;
inline bool RoomFan_FanElement::has_multiple() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomFan_FanElement::set_has_multiple() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomFan_FanElement::clear_has_multiple() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomFan_FanElement::clear_multiple() {
  multiple_ = 0;
  clear_has_multiple();
}
inline ::google::protobuf::int32 RoomFan_FanElement::multiple() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.FanElement.multiple)
  return multiple_;
}
inline void RoomFan_FanElement::set_multiple(::google::protobuf::int32 value) {
  set_has_multiple();
  multiple_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomFan.FanElement.multiple)
}

// -------------------------------------------------------------------

// RoomFan

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM_FAN];
inline bool RoomFan::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomFan::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomFan::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomFan::clear_type_t() {
  type_t_ = 11;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE RoomFan::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void RoomFan::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomFan.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool RoomFan::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomFan::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomFan::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomFan::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& RoomFan::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomFan::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomFan.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomFan::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void RoomFan::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomFan.common_prop)
}

// optional int32 fans_count = 3 [default = 20];
inline bool RoomFan::has_fans_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomFan::set_has_fans_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomFan::clear_has_fans_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomFan::clear_fans_count() {
  fans_count_ = 20;
  clear_has_fans_count();
}
inline ::google::protobuf::int32 RoomFan::fans_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.fans_count)
  return fans_count_;
}
inline void RoomFan::set_fans_count(::google::protobuf::int32 value) {
  set_has_fans_count();
  fans_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomFan.fans_count)
}

// repeated .Adoter.Asset.RoomFan.FanElement fans = 4;
inline int RoomFan::fans_size() const {
  return fans_.size();
}
inline void RoomFan::clear_fans() {
  fans_.Clear();
}
inline const ::Adoter::Asset::RoomFan_FanElement& RoomFan::fans(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomFan.fans)
  return fans_.Get(index);
}
inline ::Adoter::Asset::RoomFan_FanElement* RoomFan::mutable_fans(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomFan.fans)
  return fans_.Mutable(index);
}
inline ::Adoter::Asset::RoomFan_FanElement* RoomFan::add_fans() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomFan.fans)
  return fans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomFan_FanElement >&
RoomFan::fans() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomFan.fans)
  return fans_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomFan_FanElement >*
RoomFan::mutable_fans() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomFan.fans)
  return &fans_;
}

// -------------------------------------------------------------------

// RoomModel

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM_MODEL];
inline bool RoomModel::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomModel::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomModel::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomModel::clear_type_t() {
  type_t_ = 12;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE RoomModel::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomModel.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void RoomModel::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomModel.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool RoomModel::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomModel::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomModel::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomModel::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& RoomModel::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomModel.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomModel::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomModel.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomModel::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void RoomModel::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomModel.common_prop)
}

// -------------------------------------------------------------------

// RoomOpen_CardCost

// optional int32 rounds = 1;
inline bool RoomOpen_CardCost::has_rounds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomOpen_CardCost::set_has_rounds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomOpen_CardCost::clear_has_rounds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomOpen_CardCost::clear_rounds() {
  rounds_ = 0;
  clear_has_rounds();
}
inline ::google::protobuf::int32 RoomOpen_CardCost::rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOpen.CardCost.rounds)
  return rounds_;
}
inline void RoomOpen_CardCost::set_rounds(::google::protobuf::int32 value) {
  set_has_rounds();
  rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOpen.CardCost.rounds)
}

// optional int32 room_cards_count = 2;
inline bool RoomOpen_CardCost::has_room_cards_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomOpen_CardCost::set_has_room_cards_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomOpen_CardCost::clear_has_room_cards_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomOpen_CardCost::clear_room_cards_count() {
  room_cards_count_ = 0;
  clear_has_room_cards_count();
}
inline ::google::protobuf::int32 RoomOpen_CardCost::room_cards_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOpen.CardCost.room_cards_count)
  return room_cards_count_;
}
inline void RoomOpen_CardCost::set_room_cards_count(::google::protobuf::int32 value) {
  set_has_room_cards_count();
  room_cards_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOpen.CardCost.room_cards_count)
}

// -------------------------------------------------------------------

// RoomOpen

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ROOM_OPEN];
inline bool RoomOpen::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomOpen::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomOpen::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomOpen::clear_type_t() {
  type_t_ = 13;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE RoomOpen::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOpen.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void RoomOpen::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOpen.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool RoomOpen::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomOpen::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomOpen::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomOpen::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& RoomOpen::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOpen.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomOpen::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomOpen.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* RoomOpen::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void RoomOpen::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.RoomOpen.common_prop)
}

// optional int32 costs_count = 3 [default = 10];
inline bool RoomOpen::has_costs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomOpen::set_has_costs_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomOpen::clear_has_costs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomOpen::clear_costs_count() {
  costs_count_ = 10;
  clear_has_costs_count();
}
inline ::google::protobuf::int32 RoomOpen::costs_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOpen.costs_count)
  return costs_count_;
}
inline void RoomOpen::set_costs_count(::google::protobuf::int32 value) {
  set_has_costs_count();
  costs_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.RoomOpen.costs_count)
}

// repeated .Adoter.Asset.RoomOpen.CardCost costs = 4;
inline int RoomOpen::costs_size() const {
  return costs_.size();
}
inline void RoomOpen::clear_costs() {
  costs_.Clear();
}
inline const ::Adoter::Asset::RoomOpen_CardCost& RoomOpen::costs(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.RoomOpen.costs)
  return costs_.Get(index);
}
inline ::Adoter::Asset::RoomOpen_CardCost* RoomOpen::mutable_costs(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.RoomOpen.costs)
  return costs_.Mutable(index);
}
inline ::Adoter::Asset::RoomOpen_CardCost* RoomOpen::add_costs() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.RoomOpen.costs)
  return costs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomOpen_CardCost >&
RoomOpen::costs() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.RoomOpen.costs)
  return costs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::RoomOpen_CardCost >*
RoomOpen::mutable_costs() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.RoomOpen.costs)
  return &costs_;
}

// -------------------------------------------------------------------

// VoiceAlter_VoiceElement

// optional bytes name = 1;
inline bool VoiceAlter_VoiceElement::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoiceAlter_VoiceElement::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoiceAlter_VoiceElement::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoiceAlter_VoiceElement::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VoiceAlter_VoiceElement::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.VoiceAlter.VoiceElement.name)
  return *name_;
}
inline void VoiceAlter_VoiceElement::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.VoiceAlter.VoiceElement.name)
}
inline void VoiceAlter_VoiceElement::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.VoiceAlter.VoiceElement.name)
}
inline void VoiceAlter_VoiceElement::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.VoiceAlter.VoiceElement.name)
}
inline ::std::string* VoiceAlter_VoiceElement::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.VoiceAlter.VoiceElement.name)
  return name_;
}
inline ::std::string* VoiceAlter_VoiceElement::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VoiceAlter_VoiceElement::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.VoiceAlter.VoiceElement.name)
}

// optional bytes voice_path = 2;
inline bool VoiceAlter_VoiceElement::has_voice_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoiceAlter_VoiceElement::set_has_voice_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoiceAlter_VoiceElement::clear_has_voice_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoiceAlter_VoiceElement::clear_voice_path() {
  if (voice_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_->clear();
  }
  clear_has_voice_path();
}
inline const ::std::string& VoiceAlter_VoiceElement::voice_path() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.VoiceAlter.VoiceElement.voice_path)
  return *voice_path_;
}
inline void VoiceAlter_VoiceElement::set_voice_path(const ::std::string& value) {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  voice_path_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.VoiceAlter.VoiceElement.voice_path)
}
inline void VoiceAlter_VoiceElement::set_voice_path(const char* value) {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  voice_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.VoiceAlter.VoiceElement.voice_path)
}
inline void VoiceAlter_VoiceElement::set_voice_path(const void* value, size_t size) {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  voice_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.VoiceAlter.VoiceElement.voice_path)
}
inline ::std::string* VoiceAlter_VoiceElement::mutable_voice_path() {
  set_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voice_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.VoiceAlter.VoiceElement.voice_path)
  return voice_path_;
}
inline ::std::string* VoiceAlter_VoiceElement::release_voice_path() {
  clear_has_voice_path();
  if (voice_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = voice_path_;
    voice_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VoiceAlter_VoiceElement::set_allocated_voice_path(::std::string* voice_path) {
  if (voice_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete voice_path_;
  }
  if (voice_path) {
    set_has_voice_path();
    voice_path_ = voice_path;
  } else {
    clear_has_voice_path();
    voice_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.VoiceAlter.VoiceElement.voice_path)
}

// -------------------------------------------------------------------

// VoiceAlter

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_VOICE_ALTER];
inline bool VoiceAlter::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoiceAlter::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VoiceAlter::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VoiceAlter::clear_type_t() {
  type_t_ = 14;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE VoiceAlter::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.VoiceAlter.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void VoiceAlter::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.VoiceAlter.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool VoiceAlter::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoiceAlter::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VoiceAlter::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VoiceAlter::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& VoiceAlter::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.VoiceAlter.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* VoiceAlter::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.VoiceAlter.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* VoiceAlter::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void VoiceAlter::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.VoiceAlter.common_prop)
}

// optional int32 voices_count = 3 [default = 10];
inline bool VoiceAlter::has_voices_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoiceAlter::set_has_voices_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VoiceAlter::clear_has_voices_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VoiceAlter::clear_voices_count() {
  voices_count_ = 10;
  clear_has_voices_count();
}
inline ::google::protobuf::int32 VoiceAlter::voices_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.VoiceAlter.voices_count)
  return voices_count_;
}
inline void VoiceAlter::set_voices_count(::google::protobuf::int32 value) {
  set_has_voices_count();
  voices_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.VoiceAlter.voices_count)
}

// repeated .Adoter.Asset.VoiceAlter.VoiceElement voices = 4;
inline int VoiceAlter::voices_size() const {
  return voices_.size();
}
inline void VoiceAlter::clear_voices() {
  voices_.Clear();
}
inline const ::Adoter::Asset::VoiceAlter_VoiceElement& VoiceAlter::voices(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.VoiceAlter.voices)
  return voices_.Get(index);
}
inline ::Adoter::Asset::VoiceAlter_VoiceElement* VoiceAlter::mutable_voices(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.VoiceAlter.voices)
  return voices_.Mutable(index);
}
inline ::Adoter::Asset::VoiceAlter_VoiceElement* VoiceAlter::add_voices() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.VoiceAlter.voices)
  return voices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::VoiceAlter_VoiceElement >&
VoiceAlter::voices() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.VoiceAlter.voices)
  return voices_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::VoiceAlter_VoiceElement >*
VoiceAlter::mutable_voices() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.VoiceAlter.voices)
  return &voices_;
}

// -------------------------------------------------------------------

// Face

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_FACE];
inline bool Face::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Face::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Face::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Face::clear_type_t() {
  type_t_ = 15;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Face::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Face.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Face::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Face.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Face::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Face::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Face::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Face::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Face::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Face.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Face::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Face.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Face::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Face::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Face.common_prop)
}

// optional int32 faces_count = 3 [default = 20];
inline bool Face::has_faces_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Face::set_has_faces_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Face::clear_has_faces_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Face::clear_faces_count() {
  faces_count_ = 20;
  clear_has_faces_count();
}
inline ::google::protobuf::int32 Face::faces_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Face.faces_count)
  return faces_count_;
}
inline void Face::set_faces_count(::google::protobuf::int32 value) {
  set_has_faces_count();
  faces_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Face.faces_count)
}

// repeated bytes faces = 4;
inline int Face::faces_size() const {
  return faces_.size();
}
inline void Face::clear_faces() {
  faces_.Clear();
}
inline const ::std::string& Face::faces(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Face.faces)
  return faces_.Get(index);
}
inline ::std::string* Face::mutable_faces(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Face.faces)
  return faces_.Mutable(index);
}
inline void Face::set_faces(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.Face.faces)
  faces_.Mutable(index)->assign(value);
}
inline void Face::set_faces(int index, const char* value) {
  faces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Face.faces)
}
inline void Face::set_faces(int index, const void* value, size_t size) {
  faces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Face.faces)
}
inline ::std::string* Face::add_faces() {
  return faces_.Add();
}
inline void Face::add_faces(const ::std::string& value) {
  faces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Face.faces)
}
inline void Face::add_faces(const char* value) {
  faces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.Face.faces)
}
inline void Face::add_faces(const void* value, size_t size) {
  faces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.Face.faces)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Face::faces() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Face.faces)
  return faces_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Face::mutable_faces() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Face.faces)
  return &faces_;
}

// -------------------------------------------------------------------

// Avatar

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_AVATAR];
inline bool Avatar::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Avatar::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Avatar::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Avatar::clear_type_t() {
  type_t_ = 16;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Avatar::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Avatar.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Avatar::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Avatar.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Avatar::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Avatar::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Avatar::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Avatar::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Avatar::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Avatar.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Avatar::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Avatar.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Avatar::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Avatar::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Avatar.common_prop)
}

// optional int32 avatars_count = 3 [default = 20];
inline bool Avatar::has_avatars_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Avatar::set_has_avatars_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Avatar::clear_has_avatars_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Avatar::clear_avatars_count() {
  avatars_count_ = 20;
  clear_has_avatars_count();
}
inline ::google::protobuf::int32 Avatar::avatars_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Avatar.avatars_count)
  return avatars_count_;
}
inline void Avatar::set_avatars_count(::google::protobuf::int32 value) {
  set_has_avatars_count();
  avatars_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Avatar.avatars_count)
}

// repeated bytes avatars = 4;
inline int Avatar::avatars_size() const {
  return avatars_.size();
}
inline void Avatar::clear_avatars() {
  avatars_.Clear();
}
inline const ::std::string& Avatar::avatars(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Avatar.avatars)
  return avatars_.Get(index);
}
inline ::std::string* Avatar::mutable_avatars(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Avatar.avatars)
  return avatars_.Mutable(index);
}
inline void Avatar::set_avatars(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Adoter.Asset.Avatar.avatars)
  avatars_.Mutable(index)->assign(value);
}
inline void Avatar::set_avatars(int index, const char* value) {
  avatars_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Avatar.avatars)
}
inline void Avatar::set_avatars(int index, const void* value, size_t size) {
  avatars_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Avatar.avatars)
}
inline ::std::string* Avatar::add_avatars() {
  return avatars_.Add();
}
inline void Avatar::add_avatars(const ::std::string& value) {
  avatars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.Avatar.avatars)
}
inline void Avatar::add_avatars(const char* value) {
  avatars_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Adoter.Asset.Avatar.avatars)
}
inline void Avatar::add_avatars(const void* value, size_t size) {
  avatars_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Adoter.Asset.Avatar.avatars)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Avatar::avatars() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.Avatar.avatars)
  return avatars_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Avatar::mutable_avatars() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.Avatar.avatars)
  return &avatars_;
}

// -------------------------------------------------------------------

// Activity

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_ACTIVITY];
inline bool Activity::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Activity::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Activity::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Activity::clear_type_t() {
  type_t_ = 17;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Activity::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Activity.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Activity::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Activity.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Activity::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Activity::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Activity::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Activity::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Activity::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Activity.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Activity::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Activity.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Activity::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Activity::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Activity.common_prop)
}

// optional .Adoter.Asset.Activity.ACTIVITY_TYPE activity_type = 3;
inline bool Activity::has_activity_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Activity::set_has_activity_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Activity::clear_has_activity_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Activity::clear_activity_type() {
  activity_type_ = 1;
  clear_has_activity_type();
}
inline ::Adoter::Asset::Activity_ACTIVITY_TYPE Activity::activity_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Activity.activity_type)
  return static_cast< ::Adoter::Asset::Activity_ACTIVITY_TYPE >(activity_type_);
}
inline void Activity::set_activity_type(::Adoter::Asset::Activity_ACTIVITY_TYPE value) {
  assert(::Adoter::Asset::Activity_ACTIVITY_TYPE_IsValid(value));
  set_has_activity_type();
  activity_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Activity.activity_type)
}

// optional bytes start_time = 4;
inline bool Activity::has_start_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Activity::set_has_start_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Activity::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Activity::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& Activity::start_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Activity.start_time)
  return *start_time_;
}
inline void Activity::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Activity.start_time)
}
inline void Activity::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Activity.start_time)
}
inline void Activity::set_start_time(const void* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Activity.start_time)
}
inline ::std::string* Activity::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Activity.start_time)
  return start_time_;
}
inline ::std::string* Activity::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Activity::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Activity.start_time)
}

// optional bytes stop_time = 5;
inline bool Activity::has_stop_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Activity::set_has_stop_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Activity::clear_has_stop_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Activity::clear_stop_time() {
  if (stop_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_->clear();
  }
  clear_has_stop_time();
}
inline const ::std::string& Activity::stop_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Activity.stop_time)
  return *stop_time_;
}
inline void Activity::set_stop_time(const ::std::string& value) {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  stop_time_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Activity.stop_time)
}
inline void Activity::set_stop_time(const char* value) {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  stop_time_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Activity.stop_time)
}
inline void Activity::set_stop_time(const void* value, size_t size) {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  stop_time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Activity.stop_time)
}
inline ::std::string* Activity::mutable_stop_time() {
  set_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stop_time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Activity.stop_time)
  return stop_time_;
}
inline ::std::string* Activity::release_stop_time() {
  clear_has_stop_time();
  if (stop_time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stop_time_;
    stop_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Activity::set_allocated_stop_time(::std::string* stop_time) {
  if (stop_time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stop_time_;
  }
  if (stop_time) {
    set_has_stop_time();
    stop_time_ = stop_time;
  } else {
    clear_has_stop_time();
    stop_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Activity.stop_time)
}

// -------------------------------------------------------------------

// DailyAllowance

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_DAILY_ALLOWANCE];
inline bool DailyAllowance::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyAllowance::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyAllowance::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyAllowance::clear_type_t() {
  type_t_ = 18;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE DailyAllowance::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyAllowance.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void DailyAllowance::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyAllowance.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool DailyAllowance::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyAllowance::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyAllowance::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyAllowance::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& DailyAllowance::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyAllowance.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* DailyAllowance::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.DailyAllowance.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* DailyAllowance::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void DailyAllowance::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.DailyAllowance.common_prop)
}

// optional int32 huanledou_below = 3 [default = 2000];
inline bool DailyAllowance::has_huanledou_below() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyAllowance::set_has_huanledou_below() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyAllowance::clear_has_huanledou_below() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyAllowance::clear_huanledou_below() {
  huanledou_below_ = 2000;
  clear_has_huanledou_below();
}
inline ::google::protobuf::int32 DailyAllowance::huanledou_below() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyAllowance.huanledou_below)
  return huanledou_below_;
}
inline void DailyAllowance::set_huanledou_below(::google::protobuf::int32 value) {
  set_has_huanledou_below();
  huanledou_below_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyAllowance.huanledou_below)
}

// optional int64 common_reward_id = 4;
inline bool DailyAllowance::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyAllowance::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyAllowance::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyAllowance::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 DailyAllowance::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyAllowance.common_reward_id)
  return common_reward_id_;
}
inline void DailyAllowance::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyAllowance.common_reward_id)
}

// optional int64 common_limit_id = 5;
inline bool DailyAllowance::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DailyAllowance::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DailyAllowance::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DailyAllowance::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 DailyAllowance::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailyAllowance.common_limit_id)
  return common_limit_id_;
}
inline void DailyAllowance::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailyAllowance.common_limit_id)
}

// -------------------------------------------------------------------

// Recharge

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_RECHARGE];
inline bool Recharge::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Recharge::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Recharge::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Recharge::clear_type_t() {
  type_t_ = 20;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Recharge::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Recharge::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Recharge::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Recharge::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Recharge::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Recharge::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Recharge::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Recharge::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Recharge.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Recharge::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Recharge::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Recharge.common_prop)
}

// optional bytes plat_name = 3;
inline bool Recharge::has_plat_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Recharge::set_has_plat_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Recharge::clear_has_plat_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Recharge::clear_plat_name() {
  if (plat_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plat_name_->clear();
  }
  clear_has_plat_name();
}
inline const ::std::string& Recharge::plat_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.plat_name)
  return *plat_name_;
}
inline void Recharge::set_plat_name(const ::std::string& value) {
  set_has_plat_name();
  if (plat_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plat_name_ = new ::std::string;
  }
  plat_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.plat_name)
}
inline void Recharge::set_plat_name(const char* value) {
  set_has_plat_name();
  if (plat_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plat_name_ = new ::std::string;
  }
  plat_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Recharge.plat_name)
}
inline void Recharge::set_plat_name(const void* value, size_t size) {
  set_has_plat_name();
  if (plat_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plat_name_ = new ::std::string;
  }
  plat_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Recharge.plat_name)
}
inline ::std::string* Recharge::mutable_plat_name() {
  set_has_plat_name();
  if (plat_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    plat_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Recharge.plat_name)
  return plat_name_;
}
inline ::std::string* Recharge::release_plat_name() {
  clear_has_plat_name();
  if (plat_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = plat_name_;
    plat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recharge::set_allocated_plat_name(::std::string* plat_name) {
  if (plat_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete plat_name_;
  }
  if (plat_name) {
    set_has_plat_name();
    plat_name_ = plat_name;
  } else {
    clear_has_plat_name();
    plat_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Recharge.plat_name)
}

// optional bytes product_id = 4;
inline bool Recharge::has_product_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Recharge::set_has_product_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Recharge::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Recharge::clear_product_id() {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_->clear();
  }
  clear_has_product_id();
}
inline const ::std::string& Recharge::product_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.product_id)
  return *product_id_;
}
inline void Recharge::set_product_id(const ::std::string& value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.product_id)
}
inline void Recharge::set_product_id(const char* value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Recharge.product_id)
}
inline void Recharge::set_product_id(const void* value, size_t size) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Recharge.product_id)
}
inline ::std::string* Recharge::mutable_product_id() {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Recharge.product_id)
  return product_id_;
}
inline ::std::string* Recharge::release_product_id() {
  clear_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_id_;
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recharge::set_allocated_product_id(::std::string* product_id) {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_id_;
  }
  if (product_id) {
    set_has_product_id();
    product_id_ = product_id;
  } else {
    clear_has_product_id();
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Recharge.product_id)
}

// optional bytes icon_name = 5;
inline bool Recharge::has_icon_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Recharge::set_has_icon_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Recharge::clear_has_icon_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Recharge::clear_icon_name() {
  if (icon_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_->clear();
  }
  clear_has_icon_name();
}
inline const ::std::string& Recharge::icon_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.icon_name)
  return *icon_name_;
}
inline void Recharge::set_icon_name(const ::std::string& value) {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  icon_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.icon_name)
}
inline void Recharge::set_icon_name(const char* value) {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  icon_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Recharge.icon_name)
}
inline void Recharge::set_icon_name(const void* value, size_t size) {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  icon_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Recharge.icon_name)
}
inline ::std::string* Recharge::mutable_icon_name() {
  set_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Recharge.icon_name)
  return icon_name_;
}
inline ::std::string* Recharge::release_icon_name() {
  clear_has_icon_name();
  if (icon_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_name_;
    icon_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recharge::set_allocated_icon_name(::std::string* icon_name) {
  if (icon_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_name_;
  }
  if (icon_name) {
    set_has_icon_name();
    icon_name_ = icon_name;
  } else {
    clear_has_icon_name();
    icon_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Recharge.icon_name)
}

// optional int32 price = 6;
inline bool Recharge::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Recharge::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Recharge::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Recharge::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 Recharge::price() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.price)
  return price_;
}
inline void Recharge::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.price)
}

// optional int32 price_show = 7;
inline bool Recharge::has_price_show() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Recharge::set_has_price_show() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Recharge::clear_has_price_show() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Recharge::clear_price_show() {
  price_show_ = 0;
  clear_has_price_show();
}
inline ::google::protobuf::int32 Recharge::price_show() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.price_show)
  return price_show_;
}
inline void Recharge::set_price_show(::google::protobuf::int32 value) {
  set_has_price_show();
  price_show_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.price_show)
}

// optional int32 gain_diamond = 8;
inline bool Recharge::has_gain_diamond() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Recharge::set_has_gain_diamond() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Recharge::clear_has_gain_diamond() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Recharge::clear_gain_diamond() {
  gain_diamond_ = 0;
  clear_has_gain_diamond();
}
inline ::google::protobuf::int32 Recharge::gain_diamond() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Recharge.gain_diamond)
  return gain_diamond_;
}
inline void Recharge::set_gain_diamond(::google::protobuf::int32 value) {
  set_has_gain_diamond();
  gain_diamond_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Recharge.gain_diamond)
}

// -------------------------------------------------------------------

// DailySign_ContinuousSign

// optional int32 count = 1;
inline bool DailySign_ContinuousSign::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailySign_ContinuousSign::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailySign_ContinuousSign::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailySign_ContinuousSign::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 DailySign_ContinuousSign::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.ContinuousSign.count)
  return count_;
}
inline void DailySign_ContinuousSign::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.ContinuousSign.count)
}

// optional int64 common_reward_id = 2;
inline bool DailySign_ContinuousSign::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailySign_ContinuousSign::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailySign_ContinuousSign::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailySign_ContinuousSign::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 DailySign_ContinuousSign::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.ContinuousSign.common_reward_id)
  return common_reward_id_;
}
inline void DailySign_ContinuousSign::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.ContinuousSign.common_reward_id)
}

// optional int64 common_limit_id = 3;
inline bool DailySign_ContinuousSign::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailySign_ContinuousSign::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailySign_ContinuousSign::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailySign_ContinuousSign::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 DailySign_ContinuousSign::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.ContinuousSign.common_limit_id)
  return common_limit_id_;
}
inline void DailySign_ContinuousSign::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.ContinuousSign.common_limit_id)
}

// -------------------------------------------------------------------

// DailySign

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_DAILY_SIGN];
inline bool DailySign::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailySign::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailySign::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailySign::clear_type_t() {
  type_t_ = 21;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE DailySign::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void DailySign::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool DailySign::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailySign::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailySign::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailySign::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& DailySign::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* DailySign::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.DailySign.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* DailySign::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void DailySign::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.DailySign.common_prop)
}

// optional int64 common_reward_id = 3;
inline bool DailySign::has_common_reward_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailySign::set_has_common_reward_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailySign::clear_has_common_reward_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailySign::clear_common_reward_id() {
  common_reward_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_reward_id();
}
inline ::google::protobuf::int64 DailySign::common_reward_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.common_reward_id)
  return common_reward_id_;
}
inline void DailySign::set_common_reward_id(::google::protobuf::int64 value) {
  set_has_common_reward_id();
  common_reward_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.common_reward_id)
}

// optional int64 common_limit_id = 4;
inline bool DailySign::has_common_limit_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailySign::set_has_common_limit_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailySign::clear_has_common_limit_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailySign::clear_common_limit_id() {
  common_limit_id_ = GOOGLE_LONGLONG(0);
  clear_has_common_limit_id();
}
inline ::google::protobuf::int64 DailySign::common_limit_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.common_limit_id)
  return common_limit_id_;
}
inline void DailySign::set_common_limit_id(::google::protobuf::int64 value) {
  set_has_common_limit_id();
  common_limit_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.common_limit_id)
}

// optional int32 signs_count = 5 [default = 10];
inline bool DailySign::has_signs_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DailySign::set_has_signs_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DailySign::clear_has_signs_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DailySign::clear_signs_count() {
  signs_count_ = 10;
  clear_has_signs_count();
}
inline ::google::protobuf::int32 DailySign::signs_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.signs_count)
  return signs_count_;
}
inline void DailySign::set_signs_count(::google::protobuf::int32 value) {
  set_has_signs_count();
  signs_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.DailySign.signs_count)
}

// repeated .Adoter.Asset.DailySign.ContinuousSign signs = 6;
inline int DailySign::signs_size() const {
  return signs_.size();
}
inline void DailySign::clear_signs() {
  signs_.Clear();
}
inline const ::Adoter::Asset::DailySign_ContinuousSign& DailySign::signs(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.DailySign.signs)
  return signs_.Get(index);
}
inline ::Adoter::Asset::DailySign_ContinuousSign* DailySign::mutable_signs(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.DailySign.signs)
  return signs_.Mutable(index);
}
inline ::Adoter::Asset::DailySign_ContinuousSign* DailySign::add_signs() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.DailySign.signs)
  return signs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::DailySign_ContinuousSign >&
DailySign::signs() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.DailySign.signs)
  return signs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::DailySign_ContinuousSign >*
DailySign::mutable_signs() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.DailySign.signs)
  return &signs_;
}

// -------------------------------------------------------------------

// Item_CommonProp

// optional .Adoter.Asset.AssetCommonProp common_prop = 1;
inline bool Item_CommonProp::has_common_prop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_CommonProp::set_has_common_prop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_CommonProp::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_CommonProp::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Item_CommonProp::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Item_CommonProp::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_CommonProp.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Item_CommonProp::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Item_CommonProp::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_CommonProp.common_prop)
}

// optional int32 quality = 2 [default = 1];
inline bool Item_CommonProp::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_CommonProp::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_CommonProp::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_CommonProp::clear_quality() {
  quality_ = 1;
  clear_has_quality();
}
inline ::google::protobuf::int32 Item_CommonProp::quality() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.quality)
  return quality_;
}
inline void Item_CommonProp::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.quality)
}

// optional int32 min_level_limit = 3;
inline bool Item_CommonProp::has_min_level_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_CommonProp::set_has_min_level_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_CommonProp::clear_has_min_level_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_CommonProp::clear_min_level_limit() {
  min_level_limit_ = 0;
  clear_has_min_level_limit();
}
inline ::google::protobuf::int32 Item_CommonProp::min_level_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.min_level_limit)
  return min_level_limit_;
}
inline void Item_CommonProp::set_min_level_limit(::google::protobuf::int32 value) {
  set_has_min_level_limit();
  min_level_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.min_level_limit)
}

// optional int32 max_level_limit = 4;
inline bool Item_CommonProp::has_max_level_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item_CommonProp::set_has_max_level_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item_CommonProp::clear_has_max_level_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item_CommonProp::clear_max_level_limit() {
  max_level_limit_ = 0;
  clear_has_max_level_limit();
}
inline ::google::protobuf::int32 Item_CommonProp::max_level_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.max_level_limit)
  return max_level_limit_;
}
inline void Item_CommonProp::set_max_level_limit(::google::protobuf::int32 value) {
  set_has_max_level_limit();
  max_level_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.max_level_limit)
}

// optional int32 pile_max = 5 [default = 1];
inline bool Item_CommonProp::has_pile_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item_CommonProp::set_has_pile_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item_CommonProp::clear_has_pile_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item_CommonProp::clear_pile_max() {
  pile_max_ = 1;
  clear_has_pile_max();
}
inline ::google::protobuf::int32 Item_CommonProp::pile_max() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.pile_max)
  return pile_max_;
}
inline void Item_CommonProp::set_pile_max(::google::protobuf::int32 value) {
  set_has_pile_max();
  pile_max_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.pile_max)
}

// optional int32 count = 6 [default = 1];
inline bool Item_CommonProp::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item_CommonProp::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item_CommonProp::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item_CommonProp::clear_count() {
  count_ = 1;
  clear_has_count();
}
inline ::google::protobuf::int32 Item_CommonProp::count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.count)
  return count_;
}
inline void Item_CommonProp::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.count)
}

// optional bool batch_use = 7;
inline bool Item_CommonProp::has_batch_use() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Item_CommonProp::set_has_batch_use() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Item_CommonProp::clear_has_batch_use() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Item_CommonProp::clear_batch_use() {
  batch_use_ = false;
  clear_has_batch_use();
}
inline bool Item_CommonProp::batch_use() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.batch_use)
  return batch_use_;
}
inline void Item_CommonProp::set_batch_use(bool value) {
  set_has_batch_use();
  batch_use_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.batch_use)
}

// optional bool auto_use = 8;
inline bool Item_CommonProp::has_auto_use() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Item_CommonProp::set_has_auto_use() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Item_CommonProp::clear_has_auto_use() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Item_CommonProp::clear_auto_use() {
  auto_use_ = false;
  clear_has_auto_use();
}
inline bool Item_CommonProp::auto_use() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.auto_use)
  return auto_use_;
}
inline void Item_CommonProp::set_auto_use(bool value) {
  set_has_auto_use();
  auto_use_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.auto_use)
}

// optional int64 cool_down_id = 9;
inline bool Item_CommonProp::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Item_CommonProp::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Item_CommonProp::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Item_CommonProp::clear_cool_down_id() {
  cool_down_id_ = GOOGLE_LONGLONG(0);
  clear_has_cool_down_id();
}
inline ::google::protobuf::int64 Item_CommonProp::cool_down_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.cool_down_id)
  return cool_down_id_;
}
inline void Item_CommonProp::set_cool_down_id(::google::protobuf::int64 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.cool_down_id)
}

// optional .Adoter.Asset.INVENTORY_TYPE inventory = 10;
inline bool Item_CommonProp::has_inventory() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Item_CommonProp::set_has_inventory() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Item_CommonProp::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Item_CommonProp::clear_inventory() {
  inventory_ = 1;
  clear_has_inventory();
}
inline ::Adoter::Asset::INVENTORY_TYPE Item_CommonProp::inventory() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.inventory)
  return static_cast< ::Adoter::Asset::INVENTORY_TYPE >(inventory_);
}
inline void Item_CommonProp::set_inventory(::Adoter::Asset::INVENTORY_TYPE value) {
  assert(::Adoter::Asset::INVENTORY_TYPE_IsValid(value));
  set_has_inventory();
  inventory_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.inventory)
}

// -------------------------------------------------------------------

// Item_Item

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_BEGIN];
inline bool Item_Item::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Item::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Item::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Item::clear_type_t() {
  type_t_ = 201;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_Item::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Item.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_Item::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Item.type_t)
}

// optional bytes stuff = 2;
inline bool Item_Item::has_stuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Item::set_has_stuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Item::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Item::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& Item_Item::stuff() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Item.stuff)
  return *stuff_;
}
inline void Item_Item::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Item.stuff)
}
inline void Item_Item::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Item_Item.stuff)
}
inline void Item_Item::set_stuff(const void* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Item_Item.stuff)
}
inline ::std::string* Item_Item::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Item.stuff)
  return stuff_;
}
inline ::std::string* Item_Item::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_Item::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Item.stuff)
}

// optional bytes stuff_extra = 3;
inline bool Item_Item::has_stuff_extra() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Item::set_has_stuff_extra() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Item::clear_has_stuff_extra() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Item::clear_stuff_extra() {
  if (stuff_extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_->clear();
  }
  clear_has_stuff_extra();
}
inline const ::std::string& Item_Item::stuff_extra() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Item.stuff_extra)
  return *stuff_extra_;
}
inline void Item_Item::set_stuff_extra(const ::std::string& value) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Item.stuff_extra)
}
inline void Item_Item::set_stuff_extra(const char* value) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Item_Item.stuff_extra)
}
inline void Item_Item::set_stuff_extra(const void* value, size_t size) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Item_Item.stuff_extra)
}
inline ::std::string* Item_Item::mutable_stuff_extra() {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Item.stuff_extra)
  return stuff_extra_;
}
inline ::std::string* Item_Item::release_stuff_extra() {
  clear_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_extra_;
    stuff_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_Item::set_allocated_stuff_extra(::std::string* stuff_extra) {
  if (stuff_extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_extra_;
  }
  if (stuff_extra) {
    set_has_stuff_extra();
    stuff_extra_ = stuff_extra;
  } else {
    clear_has_stuff_extra();
    stuff_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Item.stuff_extra)
}

// -------------------------------------------------------------------

// Item_Normal

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_NORMAL];
inline bool Item_Normal::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Normal::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Normal::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Normal::clear_type_t() {
  type_t_ = 204;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_Normal::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Normal.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_Normal::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Normal.type_t)
}

// optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
inline bool Item_Normal::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Normal::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Normal::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Normal::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::Adoter::Asset::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::Adoter::Asset::Item_CommonProp& Item_Normal::item_common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Normal.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Normal::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::Adoter::Asset::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Normal.item_common_prop)
  return item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Normal::release_item_common_prop() {
  clear_has_item_common_prop();
  ::Adoter::Asset::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_Normal::set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Normal.item_common_prop)
}

// -------------------------------------------------------------------

// Item_Potion

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_POTION];
inline bool Item_Potion::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Potion::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Potion::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Potion::clear_type_t() {
  type_t_ = 202;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_Potion::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_Potion::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Potion.type_t)
}

// optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
inline bool Item_Potion::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Potion::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Potion::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Potion::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::Adoter::Asset::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::Adoter::Asset::Item_CommonProp& Item_Potion::item_common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Potion::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::Adoter::Asset::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Potion.item_common_prop)
  return item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Potion::release_item_common_prop() {
  clear_has_item_common_prop();
  ::Adoter::Asset::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_Potion::set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Potion.item_common_prop)
}

// optional .Adoter.Asset.Item_Potion.POTION_TYPE potion_type = 3;
inline bool Item_Potion::has_potion_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Potion::set_has_potion_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Potion::clear_has_potion_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Potion::clear_potion_type() {
  potion_type_ = 1;
  clear_has_potion_type();
}
inline ::Adoter::Asset::Item_Potion_POTION_TYPE Item_Potion::potion_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.potion_type)
  return static_cast< ::Adoter::Asset::Item_Potion_POTION_TYPE >(potion_type_);
}
inline void Item_Potion::set_potion_type(::Adoter::Asset::Item_Potion_POTION_TYPE value) {
  assert(::Adoter::Asset::Item_Potion_POTION_TYPE_IsValid(value));
  set_has_potion_type();
  potion_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Potion.potion_type)
}

// optional int32 increase_value = 4 [default = 1];
inline bool Item_Potion::has_increase_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item_Potion::set_has_increase_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item_Potion::clear_has_increase_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item_Potion::clear_increase_value() {
  increase_value_ = 1;
  clear_has_increase_value();
}
inline ::google::protobuf::int32 Item_Potion::increase_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.increase_value)
  return increase_value_;
}
inline void Item_Potion::set_increase_value(::google::protobuf::int32 value) {
  set_has_increase_value();
  increase_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Potion.increase_value)
}

// -------------------------------------------------------------------

// Item_RoomCard

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_ROOM_CARD];
inline bool Item_RoomCard::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_RoomCard::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_RoomCard::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_RoomCard::clear_type_t() {
  type_t_ = 203;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_RoomCard::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_RoomCard.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_RoomCard::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_RoomCard.type_t)
}

// optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
inline bool Item_RoomCard::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_RoomCard::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_RoomCard::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_RoomCard::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::Adoter::Asset::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::Adoter::Asset::Item_CommonProp& Item_RoomCard::item_common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_RoomCard.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_RoomCard::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::Adoter::Asset::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_RoomCard.item_common_prop)
  return item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_RoomCard::release_item_common_prop() {
  clear_has_item_common_prop();
  ::Adoter::Asset::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_RoomCard::set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_RoomCard.item_common_prop)
}

// optional int32 rounds = 3 [default = 1];
inline bool Item_RoomCard::has_rounds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_RoomCard::set_has_rounds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_RoomCard::clear_has_rounds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_RoomCard::clear_rounds() {
  rounds_ = 1;
  clear_has_rounds();
}
inline ::google::protobuf::int32 Item_RoomCard::rounds() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_RoomCard.rounds)
  return rounds_;
}
inline void Item_RoomCard::set_rounds(::google::protobuf::int32 value) {
  set_has_rounds();
  rounds_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_RoomCard.rounds)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Asset
}  // namespace Adoter

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE>() {
  return ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE>() {
  return ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE>() {
  return ::Adoter::Asset::CommonLimit_COOL_DOWN_CLEAR_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CoolDown_COOL_DOWN_REASON> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CoolDown_COOL_DOWN_REASON>() {
  return ::Adoter::Asset::CoolDown_COOL_DOWN_REASON_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CommonReward_REWARD_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonReward_REWARD_TYPE>() {
  return ::Adoter::Asset::CommonReward_REWARD_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CommonConsume_CONSUME_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonConsume_CONSUME_TYPE>() {
  return ::Adoter::Asset::CommonConsume_CONSUME_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::Mall_GOODS_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::Mall_GOODS_TYPE>() {
  return ::Adoter::Asset::Mall_GOODS_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::Activity_ACTIVITY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::Activity_ACTIVITY_TYPE>() {
  return ::Adoter::Asset::Activity_ACTIVITY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::Item_Potion_POTION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::Item_Potion_POTION_TYPE>() {
  return ::Adoter::Asset::Item_Potion_POTION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::INVENTORY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::INVENTORY_TYPE>() {
  return ::Adoter::Asset::INVENTORY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::GENDER_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::GENDER_TYPE>() {
  return ::Adoter::Asset::GENDER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::VERSION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::VERSION_TYPE>() {
  return ::Adoter::Asset::VERSION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ASSET_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ASSET_TYPE>() {
  return ::Adoter::Asset::ASSET_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ROOM_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ROOM_TYPE>() {
  return ::Adoter::Asset::ROOM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CARD_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CARD_TYPE>() {
  return ::Adoter::Asset::CARD_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::FAN_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::FAN_TYPE>() {
  return ::Adoter::Asset::FAN_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_P_5fAsset_2eproto__INCLUDED
